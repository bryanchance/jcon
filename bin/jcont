#!/bin/ksh -p
#
#  jcont -- compile Icon program
#
#  usage:  jcont [-bcdhjsvEJPS] [-f flags] [-o exe] file... [-x [args]]
#
#     file:	filename.icn (Icon source) or filename.zip (translated code)
#
#     -b	generate backwards-compatible .u1/u2 files; implies -c
#     -c	compile only: don't produce an executable
#     -f flags	enable features indicated by letters in "flags":
#			-f a	all features, equivalent to -f den
#			-f d	display() and variable() functions
#			-f e	error conversion to failure
#			-f n	file and line number tracking
#     -h	print this usage message and exit
#     -j	produce .jar file instead of executable script
#     -o exe	specify output file for executable
#     -s	silent: suppress commentary
#     -x	execute after compilation
#     -E	preprocess only
#
#  The following are mainly for debugging jcont:
#
#     -d	debug jcont: use ./jtmp for temp files, and don't delete
#     -v	verbose: echo shell commands, trace linking steps
#		    (this option is not for the squeamish)
#     -J	use jcon-built versions of jtran and jlink, if available
#     -P	pessimize: don't optimize the generated Java code
#     -S	also generate .jvm file listing generated Java code
#
#  Jcont translates Icon source files into .zip files, and links .zip
#  files to make an excutable program.  Jcont is similar to icont in
#  concept and behavior; think of a .zip file as analogous to a .u1/.u2
#  pair from icont.
#
#  "java" and "jar" must be in the search path, and "javap" if -S is used.
#
#  Normally, jcont produces a directly executable Korn Shell script
#  containing an embedded ZIP file.  Running the script executes the
#  compiled Icon program, and arguments can be passed as usual.  The
#  JXOPTS environment variable can be set to pass an arbitrary string
#  of options to the Java interpreter.
#
#  If -j is passed to jcont, the final output file is given a .jar
#  extension and the header is omitted to facilitate manipulation as a
#  ZIP archive.  Execution is accomplished by naming the file in the
#  CLASSPATH (with the runtime files) and then running java:
#	jcont -j myprog.icn
#	setenv CLASSPATH myprog.jar:/myhome/jcon/bin/rts.zip
#	java myprog
#

# command names
JAVAC="javac -nowarn"
JAVA="java -verify"
JAR="jar"
TRAN="jtran"
LINK="jlink"

# check OS type and set shell variables accordingly
# WARNING: the Windows code once worked, but has not been maintained
case `uname` in
    Windows* | OS/2 | DOS)
	set -K		# use "Korn shell" mode in MKS, not POSIX
	FILESEP=\\
	PATHSEP=\;
	NULLFILE=NUL
	TMPVAR='$TMP'
	ICONX=iconx
	;;
    *)
	FILESEP=/
	PATHSEP=:
	NULLFILE=/dev/null
	TMPVAR='${TMPDIR:-/tmp}'
	ICONX=
	;;
esac

# determine installed directory
SCRIPT=`whence $0`
IDIR=`dirname $SCRIPT`
case $IDIR in
    /*)		;;			# Unix-style absolute path
    ?:*)	;;			# DOS-style absolute path
    *)		IDIR=`pwd`/$IDIR;;	# relative path
esac

# using script location, define handler for usage error
function usage {	# usage: print header above, and exit
    sed -n '
       1,3d
       /^$/q
       /^[^#]/q
       s/^#/ /p
    ' 1>&2 $SCRIPT
    exit 1
}

# save command line, user IPATH, user TRACE
CMDLINE="$0 $*"
UIPATH="$IPATH"
UTRACE="$TRACE"

#  set reasonably large regions for use by jtran
export BLKSIZE=6000000
export STRSIZE=1000000
export COEXPSIZE=50000

# clear other environment variables that might affect jtran
unset ICONCORE TRACE IPATH NOERRBUF
unset HEAPSIZE BLOCKSIZE MSTKSIZE QLSIZE

# set tracing modes and other defaults
ANNOUNCE=echo
CMDTRACE=
TARGET="bytecode"
LINKTRACE=
OFLAG=-O
JVMDUMP=
TFLAGS=

# set temporary directory name, and assume its deletion
TDIR=./jcon$$
NODELETE=

# assume an executable script is created
XTYPE=.ksh
XFILE=
NOLINK=

# assume no subsequent execution
NOEXECUTE=exit

# process options, changing default values set above

while getopts "bcdjsvEJPSo:f:" c 2>$NULLFILE; do
    case $c in
	b)	TARGET="ucode"; NOLINK="exit";;
	c)	NOLINK="exit";;
	d)	TDIR=./jtmp; NODELETE=":";;
	f)	TFLAGS="$TFLAGS -f$OPTARG";;
	j)	XTYPE=.jar;;
	s)	ANNOUNCE=":";;
	v)	CMDTRACE="set -x"; LINKTRACE="-t";;
	E)	TARGET="ppsrc"; NOLINK="exit";;
	J)	TRAN="jjtran"; LINK="jjlink";;
	P)	OFLAG="";;
	S)	JVMDUMP="javap -c -private -verbose";;
	o)	XFILE="$OPTARG";;
    	\?)	usage;;
    esac
done

# check that at least one file argument was given
shift `expr $OPTIND - 1`
if [ $# = 0 ]; then
    usage
fi

# get name of main class from first file argument
MAIN="${1%.icn}"
MAIN="${MAIN%.zip}"
MAIN="${MAIN##*/}"

# set output file name, if not specified
if [ "$XFILE" = "" ]; then
    XFILE="$MAIN${XTYPE%.ksh}"
fi

# accumulate .icn and .zip file names
IFILES=
ZFILES=
ZBUILT=
ROOTS=
for FNAME; do
    case $FNAME in
	-x)	NOEXECUTE=
		shift
		break
		;;
	*.zip)	BASE=${FNAME%.zip}
		ZFILES="$ZFILES $BASE.zip"
		ROOTS="$ROOTS l\$${BASE##*/}"
		shift
		;;
	*)	BASE=${FNAME%.icn}
		IFILES="$IFILES $BASE"
		ZFILES="$ZFILES $BASE.zip"
		ZBUILT="$ZBUILT $BASE.zip"
		ROOTS="$ROOTS l\$${BASE##*/}"
		shift
		;;
    esac
done

# set paths for translator and for runtime files
JTRAN="$ICONX $IDIR${FILESEP}$TRAN"
JLINK="$ICONX $IDIR${FILESEP}$LINK"
JRTS="$IDIR${FILESEP}rts.zip"

# estimate the needed header size
HBASE=480		# approximate size of fixed text, plus breathing room
(( HDRSIZE = $HBASE + ${#CMDLINE} ))	# estimate total size in bytes
(( HDRSIZE = (HDRSIZE + 15) & ~15 ))	# round to multiple of 16

# conditionalize "Translating:" announcement
if [ "$IFILES" != "" ]; then
    TANNOUNCE="$ANNOUNCE"
else
    TANNOUNCE=":"
fi

# arrange deletion of temporary directory, if NODELETE is not set
$NODELETE trap "rm -rf $TDIR" 0 1 2 15

# now, finally, do some work
set -e
$CMDTRACE
export CLASSPATH="$JRTS"

# create temporary directory
if [ -d $TDIR ]; then
    rm -rf $TDIR/*
else
    mkdir $TDIR
fi

# translate each .icn file in turn
$TANNOUNCE 1>&2 "Translating:"
ERREXIT=":"
for FNAME in $IFILES; do
    $ANNOUNCE 1>&2 $FNAME.icn:
    rm -f $TDIR/*.class
    case $TARGET in
	ppsrc)
	    $JTRAN preproc $FNAME.icn : stdout
	    ;;
	ucode)
	    $JTRAN preproc $FNAME.icn : yylex : parse : u_gen_File -out:$FNAME
	    ;;
	bytecode)
	    if $JTRAN preproc $FNAME.icn : yylex : parse : ast2ir : \
		bc_File $OFLAG $TFLAGS -class:l\$${FNAME##*/} -dir:$TDIR/; then
		# bundle .class files (and linkage info) into .zip file
		(cd $TDIR; $JAR cfM ../$FNAME.zip links *.class)
		# disassemble if requested
		if [ "$JVMDUMP" != "" ]; then (
		    cd $TDIR
		    JVM=../$FNAME.jvm
		    cat $NULLFILE >$JVM
		    for c in l*class [cp]_l*class; do
			echo "======================================" $c >>$JVM
			echo "" >>$JVM
			CLASSNAME=`basename $c .class`
			CLASSPATH=$JRTS:. $JVMDUMP >>../$FNAME.jvm $CLASSNAME
			echo "" >>$JVM
			echo "" >>$JVM
			echo "" >>$JVM
		    done
		    )
		fi
	    else
		false	
	    fi
	    ;;
	"" | *)
	    echo "TARGET=$TARGET unrecognized"
	    exit 1
	    ;;
    esac || ERREXIT="exit"
done
$ERREXIT 1
$TANNOUNCE 1>&2 "No errors"

# exit here if no linking wanted
$NOLINK
$ANNOUNCE 1>&2 "Linking:"

# generate list of files needed for linking
$JAVA rts.FindFiles $LINKTRACE "$UIPATH" $ZFILES >$TDIR/zip.list

# unpack all those .zip files
rm -f $TDIR/*.class
for FNAME in `<$TDIR/zip.list`; do
    (cd $TDIR; $JAR xf $FNAME)
done

# create $MAIN class
(cd $TDIR; $JLINK $MAIN $ROOTS)

# combine the class files to make a new .zip file
(cd $TDIR; $JAR cfM combined.zip $MAIN.class [lpc]*.class)

# write the output file
case $XTYPE in

    *.jar)
	# For a .jar file, the output file is just a copy of the
	# zip file and is not directly executable
	cp $TDIR/combined.zip $XFILE
	;;

    *.ksh)
	# combine a header (padded via dd) with that zip file to make a script
	# (if making significant changes here, also adjust HBASE above)
	(dd bs=$HDRSIZE conv=sync 2>$NULLFILE; cat $TDIR/combined.zip) \
	    <<=====EOF===== >$XFILE
#!/bin/ksh -p

# built by:  $CMDLINE

WHENCE=\`whence \$0\`
case \$WHENCE in
    /*)		THISFILE=\$WHENCE;;
    ?:*)	THISFILE=\$WHENCE;;
    *)		THISFILE=\`pwd\`/\$WHENCE;;
esac

TZIP="$TMPVAR${FILESEP}jcon\$\$.zip"
trap "rm -rf \$TZIP" 0 1 2 15
dd bs=$HDRSIZE skip=1 <\$THISFILE >\$TZIP 2>$NULLFILE

export CLASSPATH="\$TZIP${PATHSEP}$JRTS${PATHSEP}\$CLASSPATH"
$JAVA -DTRACE="\$TRACE" \$JXOPTS $MAIN "\$@"
exit

[binary data follows]

%%%%
=====EOF=====

	# verify that the header was big enough
	dd bs=$HDRSIZE count=1 <$XFILE 2>$NULLFILE | grep '%%%%' >$NULLFILE ||
	    (echo 1>&2 "internal error in $0: header too small" && exit 1)

	# the process was successful
	# mark the script as executable 
	chmod +x $XFILE
	;;

esac	# case $XTYPE

# delete built .zip files
$NODELETE rm -f $ZBUILT

# execute, or don't
$NOEXECUTE
$NODELETE rm -rf $TDIR
$ANNOUNCE 1>&2 "Executing:"

case $XTYPE in
   *.jar) CLASSPATH=$XFILE$PATHSEP$JRTS exec java -DTRACE="$UTRACE" $MAIN "$@";;
   *.ksh) export TRACE="$UTRACE"; exec ./$XFILE "$@";;
esac
