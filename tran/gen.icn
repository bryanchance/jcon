procedure main(L)
	nodes := []
	while s := read() do {
		s ? {
			="record" | stop("ERROR record")
			tab(many(' \t')) | stop("ERROR whitespace")
			name := tab(upto('(')) | stop("ERROR name")
			move(1)
			fields := []
			repeat {
				tab(many(' \t'))
				f := tab(upto(' \t,)')) | stop("ERROR field")
				if f == "" then break
				put(fields, f)
				tab(many(' \t'))
				sep := move(1)
				if sep == ")" then break
			}
		}
		put(nodes, [name,fields])
	}
	every i := !L do {
		if "ir" == i then {
			every x := !nodes do {
				gen_ir(x[1], x[2])
			}
			dispatch(i, nodes)
		} else if find("verbose", i) then {
			write("procedure ", i, "(p, name, indent)")
			write("\tcase type(p) of {")
			every x := !nodes do {
				gen_verbose(i, x[1], x[2])
			}
			write("\t\"list\" : { s := indent || name || \" = list(\" || *p || \")\"")
			write("\t\tevery i := 1 to *p do {")
			write("\t\t\ts ||:= \"\\n\" || ", i, "(p[i], name || \"[\" || i || \"]\", indent)")
			write("\t\t}")
			write("\t}")
			write("\tdefault : s := indent || name || \" = \" || image(p)")
			write("\t}")
			write("\treturn s")
			write("end")
		} else if find("dump", i) then {
			write("procedure ", i, "(p)")
			write("\tcase type(p) of {")
			every x := !nodes do {
				gen_dump(i, x[1], x[2])
			}
			write("\t\"list\" : { s := \"[\" ")
			write("\t\tevery i := 1 to *p do {")
			write("\t\t\ts ||:= ", i, "(p[i])")
			write("\t\t\tif \\p[i+1] then s ||:= \", \"")
			write("\t\t}")
			write("\t\ts ||:= \"]\"")
			write("\t}")
			write("\tdefault : s := image(p)")
			write("\t}")
			write("\treturn s")
			write("end")
		} else {
			every x := !nodes do {
				walker(i, x[1], x[2])
			}
			dispatch(i, nodes)
		}
	}
end

procedure walker(fn, name, fields)
	comment(name, fields)
	write("procedure ", fn, "_", name, "(p)")
	visit(fn, fields)
	write("\tdo_", fn, "(p)")
	write("\treturn p")
	write("end")
	write()
end

procedure dispatch(fn, nodes)
	write("procedure ", fn, "(p)")
	write("\tcase type(p) of {")
	every n := !nodes do {
		x := n[1]
		writes("\t", image(x), " : { ")
		writes(" # ", x, " : (")
		every writes(" ", !n[2])
		write(" )")
		write("\t\treturn ", fn, "_", x, "(p)")
		write("\t\t}")
	}
	write("\tdefault : stop(\"ERROR in ", fn, ": \", image(type(p)), \"[\", image(p), \"]\")")
	write("\t}")
	write("end")
end

procedure comment(name, fields)
	writes("# record ", name, "(")
	every writes(" ", !fields)
	write(" )")
end

procedure visit(fn, fields)
	every f := !fields do {
		if find("List", f) then {
			write("\tevery ", fn, "(!p.", f, ")")
		} else {
			write("\t", fn, "(p.", f, ")")
		}
	}
end

procedure gen_verbose(fn, name, fields)
	writes("\t", image(name), " : s := indent || name || ", image(" = " || name))
	if *fields > 0 then {
		writes(" || \"\\n\"")
		every f := 1 to *fields do {
			writes(" || ", fn, "(p.", fields[f], ", ", image(fields[f]), ", indent || \"| \")")
			if \fields[f+1] then writes(" || \"\\n\"")
		}
	}
	write()
end

procedure gen_dump(fn, name, fields)
	writes("\t", image(name), " : s := ", image(name))
	if *fields > 0 then {
		writes(" || ", image("("))
		every f := 1 to *fields do {
			writes(" || ", fn, "(p.", fields[f], ")")
			if \fields[f+1] then writes(" || \",\"")
		}
		writes(" || ", image(")"))
	}
	write()
end

procedure gen_ir(name, fields)
	comment(name, fields)
	write("procedure ir_", name, "(p)")
	visit("ir", fields)
	write()
	write("\tinit4cg(p)")
	write()
	write("\tir_declare(p.x.value)")
	write()
	if f ? find("List") then {
		write("\tL := make_sentinel(p.", f, ")")
	}
	write("\tir_emit(p.x.start, [")
	write("\t\tirGoto(p.x.start)")
	write("\t\t])")
	write("\tir_emit(p.x.resume, [")
	write("\t\tirGoto(p.x.resume)")
	write("\t\t])")
	every i := 1 to *fields do {
		f := fields[i]
		if f ? find("List") then {
			write()
			write("\tir_emit(L[1].x.start, [")
			write("\t\tirGoto(L[2].x.start)")
			write("\t\t])")
			write("\tir_emit(L[1].x.resume, [")
			write("\t\tirGoto(p.x.failure)")
			write("\t\t])")
			write("\tevery i := 2 to *p.", f, "-1 do {")
			write("\t\tir_emit(L[i].x.success, [")
			write("\t\t\tirGoto(L[i+1].x.start)")
			write("\t\t\t])")
			write("\t\tir_emit(L[i].x.failure, [")
			write("\t\t\tirGoto(L[i-1].x.resume)")
			write("\t\t\t])")
			write("\t}")
			write("\tir_emit(L[0].x.start, [")
			write("\t\tirGoto(p.x.success)")
			write("\t\t])")
			write("\tir_emit(L[0].x.resume, [")
			write("\t\tirGoto(L[-1].x.resume)")
			write("\t\t])")
			write()
		} else {
			write("\tir_emit(p.", f, ".x.success, [")
			write("\t\tirGoto(p.x.start)")
			write("\t\t])")
			write("\tir_emit(p.", f, ".x.failure, [")
			write("\t\tirGoto(p.x.resume)")
			write("\t\t])")
		}
	}
	write("end")
	write()
end
