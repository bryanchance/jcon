global optimize_flag, nolink_flag, java_classname, noerror2failure
global nodebuginfo, nointrospection

global bc_indirect_targets
global bc_directory
global bc_keys_link

global bc_proc_classptr
global bc_proc_classname
global bc_switch_label

global bc_tmplabel_table
global bc_tmplabel_offset

global bc_create_exists
global bc_save_restore_flag
global bc_declare_set
global bc_undeclared_set
global bc_debug
global bc_labels
global bc_ir2bc_labels
global bc_emit_table
global bc_invoke_set
global bc_invoke_all
global bc_link_set
global bc_global_set
global bc_record_table
global bc_proc_table
global bc_op_table
global bc_tmp_table
global bc_tmp_offset
global bc_tmpclosure_table
global bc_tmpclosure_offset
global bc_var_set
global bc_var_field
global bc_var_table
global bc_var_offset
global bc_key_table
global bc_args_set

global bc_cset_table
global bc_real_table
global bc_string_table
global bc_integer_table

global bc_locals_set
global bc_params_set
global bc_statics_set

procedure transfer_to(s, p)
    case type(p) of {
    default: runerr(500, p)
    "irLabel" : {
        put(s, goto_w(\bc_ir2bc_labels[p]) ) | runerr(500, p)
    }
    "irTmpLabel": {
        gen_bc_rval(s, p)
        put(s, goto_w(bc_switch_label) )
    }
    }
    return s
end

procedure conditional_transfer_to(s, p, cond, notcond)
    local tmp

    case type(p) of {
    default: runerr(500, p)
    "irLabel" : {
        put(s, cond(\bc_ir2bc_labels[p]) ) | runerr(500, p)
    }
    "irTmpLabel": {
        tmp := label()
        put(s, notcond(tmp))
        gen_bc_rval(s, p)
        put(s, goto_w(bc_switch_label) )
        put(s, tmp)
    }
    }
    return s
end

# assign top-of-stack to p
procedure gen_bc_assign_to(s, p)
    local assign

    case type(p) of {
    default: { runerr(500, p) }
    "irTmp": {
        gen_bc_irTmp_assign(s, p)
    }
    "irTmpLabel": {
        gen_bc_irTmpLabel_assign(s, p)
    }
    "irTmpClosure": {
        gen_bc_irTmpClosure_assign(s, p)
    }
    "irVar" |
    "irKey": {
        gen_bc(s, p)
        assign := Assign_methodref(bc_proc_classptr)
        put(s, swap())
        put(s, invokevirtual(assign))
        put(s, Pop())
    }
    }
    return s
end


# record irFree( v )
procedure gen_bc_irFree(s, p)
    local free, c, lab

    free := Free_methodref(bc_proc_classptr)
    every c := !p.v.clo do {
        lab := label()
        gen_bc_irTmpClosure_rval(s, c)
        put(s, ifnull(lab))
        gen_bc_irTmpClosure_rval(s, c)
        put(s, invokevirtual(free))
        put(s, aconst_null() )
        gen_bc_irTmpClosure_assign(s, c)
        put(s, lab)
    }
    return s
end

# record irCoord( coord )
procedure gen_bc_irCoord(s, p)
    local f, line, column, field

    /nodebuginfo | return s

    if f := cp_String(bc_proc_classptr,
              cp_Utf8(bc_proc_classptr, \(\p.coord).file)) then {
        field := file_fieldref(bc_proc_classptr)
        put(s, aload_0())
        put(s, ldc_w(f))
        put(s, putfield(field))
    }
    if line := \(\p.coord).line then {
        field := line_fieldref(bc_proc_classptr)
        put(s, aload_0())
        put(s, ipush(line, bc_proc_classptr))
        put(s, putfield(field))
    }
    return s
end

# record irDeref( value )
procedure gen_bc_irDeref(s, p)
    local deref

    gen_bc(s, p.value)
    deref := deref_methodref(bc_proc_classptr)
    put(s, invokevirtual(deref))
    return s
end

# record irTmp( name )
procedure gen_bc_irTmp_rval(s, p)
    put(s, Aload(bc_tmp_table[p.name] + bc_tmp_offset))
    return s
end
procedure gen_bc_irTmp_assign(s, p)
    put(s, Astore(bc_tmp_table[p.name] + bc_tmp_offset))
    return s
end

# record irTmpLabel( name )
procedure gen_bc_irTmpLabel_rval(s, p)
    put(s, Iload(bc_tmplabel_table[p.name] + bc_tmplabel_offset))
    return s
end
procedure gen_bc_irTmpLabel_assign(s, p)
    put(s, Istore(bc_tmplabel_table[p.name] + bc_tmplabel_offset))
    return s
end

# record irTmpClosure( name )
procedure gen_bc_irTmpClosure_rval(s, p)
    put(s, Aload(bc_tmpclosure_table[p.name] + bc_tmpclosure_offset))
    return s
end
procedure gen_bc_irTmpClosure_assign(s, p)
    put(s, Astore(bc_tmpclosure_table[p.name] + bc_tmpclosure_offset))
    return s
end

# record irLabel( value )
procedure gen_bc_irLabel_rval(s, p)

    member(bc_indirect_targets, p) | runerr(500)

    \bc_labels[p] | runerr(500, p)
    put(s, ipush(bc_labels[p], bc_proc_classptr) )
    return s
end

# record irField(lhs, expr, field, failLabel)
procedure gen_bc_irField(s, p)
    local lab, method, fieldname, field, d

    field := field_fieldref(bc_proc_classptr)
    put(s, getstatic(field) )
    gen_bc_rval(s, p.expr)
    d := cp_String(bc_proc_classptr,
                   cp_Utf8(bc_proc_classptr, p.field)) | runerr(500)
    put(s, ldc_w(d) )
    put(s, aload_0())
    args := "Lrts/vDescriptor;Ljava/lang/String;Lrts/iClosure;"
    method := create_methodref(bc_proc_classptr, "call",
                               "(" || args || ")Lrts/vDescriptor;",
                               "rts/oField")
    put(s, invokevirtual(method))
    if \p.lhs then {
        put(s, dup() )
        lab := label()
        put(s, ifnonnull(lab) )
        put(s, Pop() )
        transfer_to(s, p.failLabel)
        put(s, lab )
        gen_bc_assign_to(s, p.lhs)
    } else {
        conditional_transfer_to(s, p.failLabel, ifnull, ifnonnull)
    }
    return s
end

# record irMove( lhs rhs )
procedure gen_bc_irMove(s, p)
    local deref

    \p.lhs | return s

    gen_bc_rval(s, p.rhs)
    if type(p.lhs) == ("irKey" | "irVar") then {
        deref := deref_methodref(bc_proc_classptr)
        put(s, invokevirtual(deref))
    }
    gen_bc_assign_to(s, p.lhs)
    return s
end

# record irScanSwap( subject pos )
procedure gen_bc_irScanSwap(s, p)
    local subject, pos, Ksubject, Kpos, deref, assign

    Ksubject := gen_bc([], irKey("subject"))
    Kpos := gen_bc([], irKey("pos"))
    subject := gen_bc([], p.subject)
    pos := gen_bc([], p.pos)

    deref := deref_methodref(bc_proc_classptr)
    assign := Assign_methodref(bc_proc_classptr)
    every put(s, !Kpos)
    put(s, invokevirtual(deref))
    every put(s, !Ksubject)
    put(s, invokevirtual(deref))

    every put(s, !Ksubject)
    every put(s, !subject)
    put(s, invokevirtual(deref))
    put(s, invokevirtual(assign))
    put(s, Pop())
    every put(s, !Kpos)
    every put(s, !pos)
    put(s, invokevirtual(deref))
    put(s, invokevirtual(assign))
    put(s, Pop())

    gen_bc_assign_to(s, p.subject)
    gen_bc_assign_to(s, p.pos)
    return s
end

# record irGoto( location )
procedure gen_bc_irGoto(s, p)
    transfer_to(s, p.location)
    return s
end

# record irVar( name )
procedure gen_bc_irVar_rval(s, p)
    put(s, Aload(bc_var_table[p.name] + bc_var_offset))
    return s

    /bc_var_field[p.name] := create_fieldref(bc_proc_classptr, "v$" || p.name,
                                             "Lrts/vVariable;",
                                             bc_proc_classname)
    if member(bc_statics_set, p.name) then {
        put(s, getstatic(bc_var_field[p.name]))
    } else {
        put(s, aload_0() )
        put(s, getfield(bc_var_field[p.name]))
    }
    return s
end

# record irKey( name )
procedure gen_bc_irKey_register(p)
    bc_keys_link[p.name] := 1
    /bc_key_table[p.name] := create_fieldref(bc_proc_classptr, "$" || p.name,
                                             "Lrts/vDescriptor;",
                                             java_classname)
end
procedure gen_bc_irKey_rval(s, p)
    gen_bc_irKey_register(p)
    put(s, getstatic(bc_key_table[p.name]))
    return s
end

# record irIntLit( val )
procedure gen_bc_irIntLit(s, p)
    local i, field

    i := integer(p.val)
    /bc_integer_table[i] := "li$" || map(i, "-", "m")
    field := create_fieldref(bc_proc_classptr, bc_integer_table[i],
                             "Lrts/vInteger;", java_classname)
    put(s, getstatic(field))
    return s
end

# record irRealLit( val )
procedure gen_bc_irRealLit(s, p)
    local r, x, field

    r := real(p.val)
    /bc_real_table[r] := "lr$" || map(r, ".-+", "dmp")
    field := create_fieldref(bc_proc_classptr, bc_real_table[r], "Lrts/vReal;",
                             java_classname)
    put(s, getstatic(field))
    return s
end

# record irStrLit( val )
procedure gen_bc_irStrLit(s, p)
    local x, field

    /bc_string_table[p.val] := "ls$" || *bc_string_table
    field := create_fieldref(bc_proc_classptr, bc_string_table[p.val],
                             "Lrts/vString;", java_classname)
    put(s, getstatic(field))
    return s
end

# record irCsetLit( val )
procedure gen_bc_irCsetLit(s, p)
    local v, field

    /bc_cset_table[p.val] := "lc$" || *bc_cset_table
    field := create_fieldref(bc_proc_classptr, bc_cset_table[p.val],
                             "Lrts/vCset;", java_classname)
    put(s, getstatic(field))
    return s
end

# record irRestore( )
procedure gen_bc_irRestore(s, p)
    return s
end

procedure bc_save_tmps(s)
    local a, k

    if *bc_tmp_table > 0 then {
        a := create_fieldref(bc_proc_classptr, "tmpArray",
                             "[Lrts/vDescriptor;", bc_proc_classname)
        put(s, aload_0())
        put(s, getfield(a))
        every k := key(bc_tmp_table) do {
            put(s, dup())
            put(s, ipush(bc_tmp_table[k]))
            put(s, Aload(bc_tmp_table[k] + bc_tmp_offset))
            put(s, aastore())
        }
        put(s, Pop())
    }
end

procedure bc_save_tmplabels(s)
    local a, k

    if *bc_tmplabel_table > 0 then {
        a := create_fieldref(bc_proc_classptr, "tmpLabelArray", "[I",
                             bc_proc_classname)
        put(s, aload_0())
        put(s, getfield(a))
        every k := key(bc_tmplabel_table) do {
            put(s, dup())
            put(s, ipush(bc_tmplabel_table[k]))
            put(s, Iload(bc_tmplabel_table[k] + bc_tmplabel_offset))
            put(s, iastore())
        }
        put(s, Pop())
    }
end

procedure bc_save_tmpclosures(s)
    local a, k
    if *bc_tmpclosure_table > 0 then {
        a := create_fieldref(bc_proc_classptr, "tmpClosureArray",
                             "[Lrts/iClosure;", bc_proc_classname)
        put(s, aload_0())
        put(s, getfield(a))
        every k := key(bc_tmpclosure_table) do {
            put(s, dup())
            put(s, ipush(bc_tmpclosure_table[k]))
            put(s, Aload(bc_tmpclosure_table[k] + bc_tmpclosure_offset))
            put(s, aastore())
        }
        put(s, Pop())
    }
end

# record irSucceed( expr continuation )
procedure gen_bc_irSucceed(s, p)
    local r, e, PC, k, a

    PC := PC_fieldref(bc_proc_classptr)
    if \p.continuation then {
        \bc_save_restore_flag | runerr(500)

        put(s, aload_0())
        gen_bc(s, p.continuation)
        put(s, putfield(PC))

        bc_save_tmps(s)
        bc_save_tmplabels(s)
        bc_save_tmpclosures(s)
    } else {
        put(s, aload_0())
        put(s, iconst_0())
        put(s, putfield(PC))
    }
    gen_bc(s, p.expr)
    put(s, areturn())
    return s
end

# record irFail( )
procedure gen_bc_irFail(s, p)
    put(s, aconst_null())
    put(s, areturn())
    return s
end

# record irRunTimeError( )
procedure gen_bc_irRunTimeError(s, p)
    local runtimeerror

    runtimeerror := error_methodref(bc_proc_classptr)
    put(s, ipush(902))
    put(s, invokestatic(runtimeerror))
    put(s, aconst_null())
    put(s, areturn())
    return s
end

# record irResume( closure failLabel retValue )
procedure gen_bc_irResume(s, p)
    local c, PC, target, resume, free

    PC := PC_fieldref(bc_proc_classptr)
    resume := resume_methodref(bc_proc_classptr)
    gen_bc(s, p.closure)
    put(s, dup())
    put(s, getfield(PC))
    target := label()
    put(s, ifne(target))
    put(s, Pop())
    transfer_to(s, p.failLabel)
    put(s, target)
    put(s, invokevirtual(resume))
    if \p.retValue then {
        put(s, dup())
        target := label()
        put(s, ifnonnull(target))
        put(s, Pop())
        transfer_to(s, p.failLabel)
        put(s, target)
        gen_bc_assign_to(s, p.retValue)
    } else {
        conditional_transfer_to(s, p.failLabel, ifnull, ifnonnull)
    }
    return s
end

# record irMakeList( lhs valueList )
procedure gen_bc_irMakeList(s, p)
    local r, v, i, method

    \p.lhs | return s

    put(s, ipush(*p.valueList))
    method := ArgArray_methodref(bc_proc_classptr);
    put(s, invokestatic(method))

    every i := 1 to *p.valueList do {
        put(s, dup())
        put(s, ipush(i-1))
        gen_bc(s, p.valueList[i])
        put(s, aastore())
    }
    method := New_vList_methodref(bc_proc_classptr)
    put(s, invokestatic(method))
    gen_bc_assign_to(s, p.lhs)
    return s
end

procedure initoptable()
    static optable
    initial {
        optable := [ table(), table(), table() ]
        optable[1]["#"] := "oLimit"
        optable[1]["."] := "oDeref"
        optable[1]["/"] := "oIsNull"
        optable[1]["\\"] := "oIsntNull"
        optable[1]["*"] := "oSize"
        optable[1]["?"] := "oSelect"
        optable[1]["+"] := "oNumerate"
        optable[1]["-"] := "oNegate"
        optable[1]["~"] := "oComplement"
        optable[1]["^"] := "oRefresh"
        optable[2][":="] := "oAssign"
        optable[2][":=:"] := "oSwap"
        optable[2]["&"] := "oConjunction"
        optable[2]["."] := "oField"
        optable[2]["[]"] := "oIndex"
        optable[2]["+"] := "oAdd"
        optable[2]["-"] := "oSub"
        optable[2]["*"] := "oMul"
        optable[2]["/"] := "oDiv"
        optable[2]["%"] := "oMod"
        optable[2]["^"] := "oPower"
        optable[2]["**"] := "oIntersect"
        optable[2]["++"] := "oUnion"
        optable[2]["--"] := "oDiff"
        optable[2]["<"] := "oNLess"
        optable[2]["<="] := "oNLessEq"
        optable[2]["="] := "oNEqual"
        optable[2]["~="] := "oNUnequal"
        optable[2][">="] := "oNGreaterEq"
        optable[2][">"] := "oNGreater"
        optable[2]["<<"] := "oLLess"
        optable[2]["<<="] := "oLLessEq"
        optable[2]["=="] := "oLEqual"
        optable[2]["~=="] := "oLUnequal"
        optable[2][">>="] := "oLGreaterEq"
        optable[2][">>"] := "oLGreater"
        optable[2]["==="] := "oVEqual"
        optable[2]["~==="] := "oVUnequal"
        optable[2]["|||"] := "oListConcat"
        optable[2]["||"] := "oConcat"
        optable[2]["@"] := "oActivate"
        optable[2][":?"] := "oSubjAssign"
        optable[3]["[:]"] := "oSection"
        optable[3]["[+:]"] := "oSectPlus"
        optable[3]["[-:]"] := "oSectMinus"
    }
    return optable
end

procedure gen_bc_call_op(s, p)
    local r, l, f, v, n, i, method

    type(p.fn) == "irOperator" | runerr(500, p.fn)

    gen_bc(s, p.fn)
    args := ""
    every i := 1 to *p.argList do {
        gen_bc(s, p.argList[i])
        args ||:= "Lrts/vDescriptor;"
    }
    put(s, aload_0())
    method := create_methodref(bc_proc_classptr, "instantiate",
                               "(" || args || "Lrts/iClosure;)Lrts/iClosure;",
                               "rts/vDescriptor")
    put(s, invokevirtual(method))
    gen_bc_assign_to(s, p.lhs)
    return s
end

# record irOpFunction( lhs fn argList failLabel )
procedure gen_bc_irOpFunction(s, p)
    local target, args, method, class, i, op, field
    static optable
    initial optable := initoptable()

    p.fn.arity = *p.argList | runerr(500, p)
    op := \optable[p.fn.arity][p.fn.name] | runerr(500, p.fn)

    class := case p.fn.arity of {
        1 : "rts/iUnaryClosure"
        2 : "rts/iBinaryClosure"
        3 : "rts/iTrinaryClosure"
        default : runerr(500)
        }
    field := create_fieldref(bc_proc_classptr, "instance", "L" || class || ";",
                             "rts/" || op)
    put(s, getstatic(field) )

    args := ""
    every i := 1 to *p.argList do {
        gen_bc(s, p.argList[i])
        args ||:= "Lrts/vDescriptor;"
    }
    put(s, aload_0())
    args ||:= "Lrts/iClosure;"
    method := create_methodref(bc_proc_classptr, "call",
                               "(" || args || ")Lrts/vDescriptor;", class)
    put(s, invokevirtual(method))

    if \p.failLabel then {
        if \p.lhs then {
            put(s, dup())
            target := label()
            put(s, ifnonnull(target))
            put(s, Pop())
            transfer_to(s, p.failLabel)
            put(s, target)
            gen_bc_assign_to(s, p.lhs)
        } else {
            conditional_transfer_to(s, p.failLabel, ifnull, ifnonnull)
        }
    } else {
        if \p.lhs then {
            gen_bc_assign_to(s, p.lhs)
        } else {
            put(s, Pop())
        }
    }
    return s
end

# record irMakeClosure( lhs fn argList )
procedure gen_bc_irMakeClosure(s, p)
    local r, l, f, v, n, i, method

    \p.lhs | return ""

    if type(p.fn) == "irOperator" then {
        return gen_bc_call_op(s, p)
    }

    gen_bc(s, p.fn)
    put(s, ipush(*p.argList))
    method := ArgArray_methodref(bc_proc_classptr)
    put(s, invokestatic(method))

    every i := 1 to *p.argList do {
        put(s, dup())
        put(s, ipush(i-1))
        gen_bc(s, p.argList[i])
        put(s, aastore())
    }
    put(s, aload_0())
    method := Instantiate_methodref(bc_proc_classptr)
    put(s, invokestatic(method))
    gen_bc_assign_to(s, p.lhs)
    return s
end

# record irOperator( name arity )
procedure gen_bc_irOperator(s, p)
    local n, x, field

    n := p.name || "," || p.arity
    /bc_op_table[n] := "proc_" || *bc_op_table
    field := create_fieldref(bc_proc_classptr, bc_op_table[n],
                             "Lrts/vDescriptor;", java_classname)
    put(s, getstatic(field))
    return s
end

# record irCreate( location )
procedure gen_bc_irCreate(s, p)
    local copymethod, createmethod

    bc_create_exists := 1

    \bc_save_restore_flag | runerr(500)

    copymethod := copy_methodref(bc_proc_classptr, bc_proc_classname)
    createmethod := Create_methodref(bc_proc_classptr)
    put(s, aload_0())
    gen_bc(s, p.location)
    put(s, invokevirtual(copymethod))
    put(s, invokestatic(createmethod))
    return s
end

# record irCoRet( value continuation )
procedure gen_bc_irCoRet(s, p)
    local r, coretmethod, current

    coretmethod := coret_methodref(bc_proc_classptr)
    current := cur_coexp_fieldref(bc_proc_classptr)
    put(s, getstatic(current))
    gen_bc(s, p.value)
    put(s, invokevirtual(coretmethod))
    transfer_to(s, p.continuation)
    return s
end

# record irCoFail( )
procedure gen_bc_irCoFail(s, p)
    local cofailmethod, current

    cofailmethod := cofail_methodref(bc_proc_classptr)
    current := cur_coexp_fieldref(bc_proc_classptr)
    put(s, getstatic(current))
    put(s, invokevirtual(cofailmethod))
    # the next two lines make the verifier happy.
    put(s, aconst_null())
    put(s, areturn())
    return s
end

# record irEnterInit( startlabel )
procedure gen_bc_irEnterInit(s, p)
    local target, initialized

    create_field(bc_proc_classptr, 8, "initialized", "Z")
    initialized := create_fieldref(bc_proc_classptr, "initialized", "Z",
                                   bc_proc_classname)
    put(s, getstatic(initialized))
    target := label()
    put(s, ifeq(target))
    transfer_to(s, p.startlabel )
    put(s, target)
    put(s, iconst_1())
    put(s, putstatic(initialized))
    return s
end

procedure gen_bc_rval(s, p)
    return gen_bc(s, p)
end

procedure gen_bc(s, p)
    case type(p) of {
    "irTmp" : return gen_bc_irTmp_rval(s, p)
    "irTmpLabel" : return gen_bc_irTmpLabel_rval(s, p)
    "irTmpClosure" : return gen_bc_irTmpClosure_rval(s, p)
    "irVar" : return gen_bc_irVar_rval(s, p)
    "irKey" : return gen_bc_irKey_rval(s, p)
    "irLabel" : return gen_bc_irLabel_rval(s, p)
    "irCoord" : return gen_bc_irCoord(s, p)
    "irDeref" : return gen_bc_irDeref(s, p)
    "irMove" : return gen_bc_irMove(s, p)
    "irScanSwap" : return gen_bc_irScanSwap(s, p)
    "irGoto" : return gen_bc_irGoto(s, p)
    "irIntLit" : return gen_bc_irIntLit(s, p)
    "irRealLit" : return gen_bc_irRealLit(s, p)
    "irStrLit" : return gen_bc_irStrLit(s, p)
    "irCsetLit" : return gen_bc_irCsetLit(s, p)
    "irRestore" : return gen_bc_irRestore(s, p)
    "irSucceed" : return gen_bc_irSucceed(s, p)
    "irFail" : return gen_bc_irFail(s, p)
    "irResume" : return gen_bc_irResume(s, p)
    "irMakeList" : return gen_bc_irMakeList(s, p)
    "irOpFunction" : return gen_bc_irOpFunction(s, p)
    "irMakeClosure" : return gen_bc_irMakeClosure(s, p)
    "irOperator" : return gen_bc_irOperator(s, p)
    "irCreate" : return gen_bc_irCreate(s, p)
    "irCoRet" : return gen_bc_irCoRet(s, p)
    "irCoFail" : return gen_bc_irCoFail(s, p)
    "irRunTimeError" : return gen_bc_irRunTimeError(s, p)
    "irEnterInit" : return gen_bc_irEnterInit(s, p)
    "irFree" : return gen_bc_irFree(s, p)
    "irField" : return gen_bc_irField(s, p)
    default : { runerr(500, p); }
    }
end

procedure bc_emit(label, code)
    return bc_emit_table[label] := code
end

procedure bc_invocables(all, L)
    every insert(bc_invoke_set, !L)
    bc_invoke_all := \all
end

procedure bc_links(L)
    every insert(bc_link_set, !L)
end

procedure bc_records(name, fields, coord)
    if member(bc_declare_set, name) then {
        semantic_error(image(name) || ": inconsistent redeclaration", coord)
    }
    insert(bc_declare_set, name)
    bc_record_table[name] := fields
end

procedure bc_globals(L)
    every insert(bc_global_set, !L)
end

procedure bc_target_bookkeeping()
    local a, t, k

    bc_indirect_targets := set([])
    every a := !!bc_emit_table do {
        case type(a) of {
        "irCoRet":  t := a.continuation
        "irCreate": t := a.location
        "irMove":   t := a.rhs
        "irSucceed":    t := a.continuation
        default: next
        }
        if type(t) == "irLabel" then {
            insert(bc_indirect_targets, t)
        }
    }
    every a := !!!bc_emit_table & type(a) == "irCreate" do {
        t := a.location
        if type(t) == "irLabel" then {
            insert(bc_indirect_targets, t)
        }
    }
    every k := !bc_indirect_targets do {
        /bc_labels[k] := *bc_labels + 1
        bc_ir2bc_labels[k] := label()
    }
    every k := key(bc_emit_table) do {
        /bc_labels[k] := *bc_labels + 1
        bc_ir2bc_labels[k] := label()
    }
end

procedure bc_find_save_restore()
    local a

    bc_save_restore_flag := &null
    if a := !!bc_emit_table & type(a)=="irSucceed" & \a.continuation then {
        bc_save_restore_flag := 1
    }
    if a := !!!bc_emit_table & type(a)=="irCreate" then {
        bc_save_restore_flag := 1
    }
end

procedure bc_alloc_tmps(s, c, class_index, class, classname)
    local a
    if *bc_tmp_table > 0 then {
        put(s, aload_0() )
        put(s, ipush(*bc_tmp_table) )
        class_index := cp_Class(c, cp_Utf8(c, "rts/vDescriptor"))
        put(s, anewarray(class_index) )
        a := create_fieldref(class, "tmpArray",
                             "[Lrts/vDescriptor;", classname)
        put(s, putfield(a) )
    }
end

procedure bc_alloc_tmplabels(s, c, class_index, class, classname)
    local a
    if *bc_tmplabel_table > 0 then {
        put(s, aload_0() )
        put(s, ipush(*bc_tmplabel_table) )
        put(s, newarray(10) )
        a := create_fieldref(class, "tmpLabelArray", "[I",
                             classname)
        put(s, putfield(a) )
    }
end

procedure bc_alloc_tmpclosures(s, c, class_index, class, classname)
    local a
    if *bc_tmpclosure_table > 0 then {
        put(s, aload_0() )
        put(s, ipush(*bc_tmpclosure_table) )
        class_index := cp_Class(c, cp_Utf8(c, "rts/iClosure"))
        put(s, anewarray(class_index) )
        a := create_fieldref(class, "tmpClosureArray",
                                 "[Lrts/iClosure;", classname)
        put(s, putfield(a) )
    }
end

procedure bc_function_variables(c, params, locals)
    local undeclared, k

    bc_locals_set := set(locals)
    bc_params_set := set(params)
    undeclared := bc_var_set -- bc_params_set -- bc_locals_set -- bc_statics_set
    every k := !params | !locals | !undeclared do {
        create_field(c, 0, "v$" || k, "Lrts/vVariable;")
    }
    return undeclared
end

procedure bc_function(name, params, accumulate, locals, statics, code,
                      codestart, coord)
    local undeclared, op, i, classname, k, insns, nextval, c
    local f, n, a, class_index, t

    bc_statics_set := set(statics)
    if member(bc_declare_set, name) then {
        semantic_error(image(name) || ": inconsistent redeclaration", coord)
    }
    insert(bc_declare_set, name)

    bc_proc_classname := "p_" || java_classname || "$" || name
    c := bc_proc_classptr := ClassFile(3, 45, [&null], table(), 1, &null, &null,
                                       [], [], [], [])
    c.super_class := cp_Class(c, cp_Utf8(c, "rts/iClosure"))
    c.this_class := cp_Class(c, cp_Utf8(c, bc_proc_classname))

    bc_proc_table[name] := if /accumulate then *params else -*params

    bc_args_set := set();
    bc_tmp_table := table()
    bc_tmplabel_table := table()
    bc_tmpclosure_table := table()
    bc_var_set := set([])
    bc_var_field := table()
    bc_var_table := table()
    bc_emit_table := table()
    bc_create_exists := &null
    bc_key_table := table()

    every i := !code do {
        bc_emit_table[i.label] := i.insnList
    }

    bc_labels := table()
    bc_ir2bc_labels := table()
    bc_labels[codestart] := 1
    bc_emit_table := optimize(bc_emit_table, codestart)

    bc_target_bookkeeping()
    bc_find_save_restore()
    bc_class_constructor(c, statics)
    bc_register(bc_emit_table)

    undeclared := bc_function_variables(c, params, locals)
    every insert(bc_undeclared_set, !undeclared)

    bc_create_nextval(c, codestart, params, locals, undeclared, accumulate)
    bc_create_constructor(c, class_index)
    bc_create_locals(c, undeclared, set(statics))
    bc_create_createvars(c, params, locals, undeclared)
    bc_create_copy(c, params, locals, undeclared)

    f := open(bc_directory || bc_proc_classname || ".class","wu") | runerr(500)
    writer_ClassFile(f, c)
    close(f)
end

procedure bc_class_constructor(c, statics)
    local clinit, clinitcode, k, f, n, newsimplevar

    clinit := create_method(c, 8, "<clinit>", "()V")
    clinitcode := create_code(c, 10, 10)
    put(clinit.attributes, clinitcode)

    newsimplevar := New_vSimpleVar_methodref(c)
    every k := !statics do {
        create_field(c, 8, "v$" || k, "Lrts/vVariable;")
        f := create_fieldref(c, "v$" || k, "Lrts/vVariable;", bc_proc_classname)
        n := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(clinitcode.code, ldc_w(n))
        put(clinitcode.code, invokestatic(newsimplevar))
        put(clinitcode.code, putstatic(f))
    }
    put(clinitcode.code, vreturn() )
end

procedure bc_create_constructor(c, class_index)
    local init, initcode, constructor, createvars, s

    init := create_method(c, 1, "<init>", "()V")
    initcode := create_code(c, 10, 10)
    put(init.attributes, initcode)
    s := initcode.code
    if \bc_save_restore_flag then {
        if *bc_tmp_table > 0 then {
            create_field(bc_proc_classptr, 0, "tmpArray", "[Lrts/vDescriptor;")
        }
        if *bc_tmpclosure_table > 0 then {
            create_field(bc_proc_classptr, 0, "tmpClosureArray",
             "[Lrts/iClosure;")
        }
        if *bc_tmplabel_table > 0 then {
            create_field(bc_proc_classptr, 0, "tmpLabelArray", "[I")
        }
    }
    constructor := init_methodref(c, "rts/iClosure")
    put(s, aload_0() )
    put(s, invokenonvirtual(constructor) )
    createvars := createVars_methodref(c, bc_proc_classname)
    put(s, aload_0() )
    put(s, invokevirtual(createvars) )

    if \bc_save_restore_flag then {
        bc_alloc_tmps(s, c, class_index, bc_proc_classptr,
                      bc_proc_classname)
        bc_alloc_tmplabels(s, c, class_index, bc_proc_classptr,
                           bc_proc_classname)
        bc_alloc_tmpclosures(s, c, class_index, bc_proc_classptr,
                             bc_proc_classname)
    }
    put(s, vreturn() )
end

procedure bc_register(t)
    local op

    every op := !!!t do {
        bc_register0(op)
    }
end

procedure bc_register0(op)
    case type(op) of {
    "list" : every bc_register0(!op)
    "irTmp" :        /bc_tmp_table[op.name] := *bc_tmp_table;
    "irTmpLabel" :   /bc_tmplabel_table[op.name] := *bc_tmplabel_table
    "irTmpClosure" : /bc_tmpclosure_table[op.name] := *bc_tmpclosure_table
    "irVar" : {
                     insert(bc_var_set, op.name)
                     /bc_var_table[op.name] := *bc_var_table
    }
    }
end

procedure bc_restore_tmps(s)
    local a, k

    if *bc_tmp_table > 0 then {
        a := create_fieldref(bc_proc_classptr, "tmpArray",
                             "[Lrts/vDescriptor;", bc_proc_classname)
        put(s, aload_0())
        put(s, getfield(a))
        every k := key(bc_tmp_table) do {
            put(s, dup())
            put(s, ipush(bc_tmp_table[k]))
            put(s, aaload())
            put(s, Astore(bc_tmp_table[k] + bc_tmp_offset))
        }
        put(s, Pop())
    }
end

procedure bc_restore_tmpclosures(s)
    local a, k

    if *bc_tmpclosure_table > 0 then {
        a := create_fieldref(bc_proc_classptr, "tmpClosureArray",
                             "[Lrts/iClosure;", bc_proc_classname)
        put(s, aload_0())
        put(s, getfield(a))
        every k := key(bc_tmpclosure_table) do {
            put(s, dup())
            put(s, ipush(bc_tmpclosure_table[k]))
            put(s, aaload())
            put(s, Astore(bc_tmpclosure_table[k] + bc_tmpclosure_offset))
        }
        put(s, Pop())
    }
end

procedure bc_restore_tmplabels(s)
    local a, k

    if *bc_tmplabel_table > 0 then {
        a := create_fieldref(bc_proc_classptr, "tmpLabelArray", "[I",
                             bc_proc_classname)
        put(s, aload_0())
        put(s, getfield(a))
        every k := key(bc_tmplabel_table) do {
            put(s, dup())
            put(s, ipush(bc_tmplabel_table[k]))
            put(s, iaload())
            put(s, Istore(bc_tmplabel_table[k] + bc_tmplabel_offset))
        }
        put(s, Pop())
    }
end

procedure bc_create_nextval(c, start, params, locals, undeclared, accumulate)
    local PC, nextval, nextvalcode, k, lab, switch, insns, deflab
    local runtimeerror, r
    local a, s, tmplab, prologue, var_load_label, t, tmpset

    nextval := create_method(c, 0, "nextval", "()Lrts/vDescriptor;")
    nextvalcode := create_code(c, 10, 10)
    put(nextval.attributes, nextvalcode)
    s := nextvalcode.code

    bc_tmp_offset := 10
    bc_tmplabel_offset := bc_tmp_offset + *bc_tmp_table
    bc_tmpclosure_offset := bc_tmplabel_offset + *bc_tmplabel_table
    bc_var_offset := bc_tmpclosure_offset + *bc_tmpclosure_table
    nextvalcode.max_locals := bc_var_offset + *bc_var_table

    bc_switch_label := label()
    var_load_label := label()
    tmplab := label()

    if \bc_save_restore_flag then {
        PC := PC_fieldref(c)
        put(s, aload_0() )
        put(s, getfield(PC))
        put(s, dup())
        put(s, iconst_1())
        put(s, if_icmpne(tmplab))
    }
    bc_emit_prologue(s, c, params, locals, undeclared, accumulate)
    bc_initialize_tmps(s)
    if \bc_save_restore_flag then {
        put(s, goto_w(var_load_label))
        put(s, tmplab)
        bc_restore_tmps(s)
        bc_restore_tmplabels(s)
        bc_restore_tmpclosures(s)
    }

    put(s, var_load_label)
    bc_load_variables(s)

    deflab := label()
    member(bc_indirect_targets, start) & runerr(500)
    switch := tableswitch(0, deflab, 1, *bc_indirect_targets+1,
                          list(*bc_indirect_targets+1))
    every k := (!bc_indirect_targets | start) do {
        switch.offsets[\bc_labels[k]] := \bc_ir2bc_labels[k] | runerr(500,k)
    }

    if \bc_save_restore_flag then {
        put(s, goto_w(bc_switch_label) )
    }
    bc_emit_code(s, switch, start)
    put(s, bc_switch_label)
    if *bc_indirect_targets > 0 then {
        put(s, switch)
        runtimeerror := error_methodref(c)
        put(s, deflab)
        put(s, ipush(902) )
        put(s, invokestatic(runtimeerror) )
        put(s, aconst_null())
        put(s, areturn())
    } else {
        /bc_save_restore_flag | runerr(500)
    }
end

procedure bc_load_variables(s)
    local k

    every k := key(bc_var_table) do {
        /bc_var_field[k] := create_fieldref(bc_proc_classptr, "v$" || k,
                                            "Lrts/vVariable;",
                                            bc_proc_classname)
        if member(bc_statics_set, k) then {
            put(s, getstatic(bc_var_field[k]))
        } else {
            put(s, aload_0() )
            put(s, getfield(bc_var_field[k]))
        }
        put(s, Astore(bc_var_table[k] + bc_var_offset))
    }
end

procedure bc_initialize_tmps(s)
    local k

    every k := key(bc_tmp_table) do {
        put(s, aconst_null())
        put(s, Astore(bc_tmp_table[k] + bc_tmp_offset))
    }
    every k := key(bc_tmpclosure_table) do {
        put(s, aconst_null())
        put(s, Astore(bc_tmpclosure_table[k] + bc_tmpclosure_offset))
    }
    every k := key(bc_tmplabel_table) do {
        put(s, iconst_0())
        put(s, Istore(bc_tmplabel_table[k] + bc_tmplabel_offset))
    }
end

global bc_emitted

procedure bc_emit_code0(s, switch, k)
    local lab, insns, i

    if member(bc_emitted, k) then return
    insert(bc_emitted, k)

    lab := bc_ir2bc_labels[k]
    put(s, lab)
    insns := bc_emit_table[k]
    every i := insns[1 to *insns-1] do {
        gen_bc(s, i)
    }
    if type(insns[-1]) == "irGoto" &
       type(insns[-1].location) == "irLabel" &
       not member(bc_emitted, insns[-1].location) then {
        bc_emit_code0(s, switch, insns[-1].location)
    } else {
        gen_bc(s, insns[-1])
    }
end

procedure bc_emit_code(s, switch, start)
    bc_emitted := set([])
    bc_emit_code0(s, switch, start)
    every bc_emit_code0(s, switch, key(bc_emit_table))
end

procedure bc_create_locals(c, undeclared, statics)
    local locals, localscode, names, variables, k, lab
    local shadow, index, class_index, m, s, sortedvars

    sortedvars := sort(bc_var_set ++ bc_params_set ++ bc_locals_set ++
		       bc_statics_set)

    locals := create_method(c, 0, "locals", "()V")
    localscode := create_code(c, 10, 10)
    put(locals.attributes, localscode)
    s := localscode.code

    if \nointrospection then {
        m := error_methodref(c)
        put(s, ipush(905))
        put(s, invokestatic(m))
        put(s, vreturn() )
        return
    }
    # local1 is int counter
    put(s, iconst_0() )
    put(s, istore_1() )
    names := names_fieldref(c)
    class_index := cp_Class(c, cp_Utf8(c, "java/lang/String"))
    put(s, aload_0() )
    put(s, ipush(*sortedvars+1) )
    put(s, anewarray(class_index) )
    put(s, putfield(names) )
    variables := variables_fieldref(c)
    class_index := cp_Class(c, cp_Utf8(c, "rts/vVariable"))
    put(s, aload_0() )
    put(s, ipush(*sortedvars+1) )
    put(s, anewarray(class_index) )
    put(s, putfield(variables) )

    every k := !sortedvars do {
        lab := label()
        if member(undeclared, k) then {
            shadow := create_fieldref(c, "v$" || k || "$", "Lrts/vVariable;",
                                      java_classname)
            put(s, getstatic(shadow) )
            put(s, ifnonnull(lab) )
        }
        index := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(s, aload_0() )
        put(s, getfield(names) )
        put(s, iload_1() )
        put(s, ldc_w(index) )
        put(s, aastore() )

        index := create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, aload_0() )
        put(s, getfield(variables) )
        put(s, iload_1() )
        if member(statics, k) then {
            put(s, getstatic(index) )
        } else {
            put(s, aload_0() )
            put(s, getfield(index) )
        }
        put(s, aastore() )

        put(s, iinc(1,1) )
        put(s, lab )
    }
    put(s, aload_0() )
    put(s, getfield(names) )
    put(s, iload_1() )
    put(s, aconst_null() )
    put(s, aastore() )

    put(s, aload_0() )
    put(s, getfield(variables) )
    put(s, iload_1() )
    put(s, aconst_null() )
    put(s, aastore() )
    put(s, vreturn() )
end

procedure bc_emit_prologue_params(s, c, params, accumulate)
    local marshal, i, k, field, elselab, endlab
    local null, arguments, deref, assign

    null := New_vNull_methodref(bc_proc_classptr)
    arguments := arguments_fieldref(c)
    deref := deref_methodref(c)
    assign := Assign_methodref(c)

    every i := 1 to *params do {
        k := params[i]
        field := create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, aload_0() )
        put(s, getfield(field) )

        if i = *params & \accumulate then {
            marshal := marshal_methodref(c)
            put(s, aload_0() )
            put(s, getfield(arguments))
            put(s, ipush(*params))
            put(s, invokestatic(marshal))
            put(s, invokevirtual(assign) )
            put(s, Pop())
        } else {
            elselab := label()
            endlab := label()
            put(s, aload_0() )
            put(s, getfield(arguments))
            put(s, dup())
            put(s, arraylength())
            put(s, ipush(i))
            put(s, if_icmpge(elselab))
                put(s, Pop())
                put(s, invokestatic(null))
                put(s, goto(endlab))
            put(s, elselab)
                put(s, ipush(i-1))
                put(s, aaload())
                put(s, invokevirtual(deref) )
            put(s, endlab)
            put(s, invokevirtual(assign) )
            put(s, Pop())
        }
    }
end

procedure bc_emit_prologue_locals(s, c, locals)
    local k, field
    local null, arguments, deref, assign

    null := New_vNull_methodref(bc_proc_classptr)
    arguments := arguments_fieldref(c)
    deref := deref_methodref(c)
    assign := Assign_methodref(c)

    every k := !locals do {
        field := create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, aload_0() )
        put(s, getfield(field) )
        put(s, invokestatic(null))
        put(s, invokevirtual(assign) )
        put(s, Pop())
    }
end

procedure bc_emit_prologue_undeclared(s, c, undeclared)
    local k, field, lab1, linkvalue
    local null, arguments, deref, assign

    null := New_vNull_methodref(bc_proc_classptr)
    arguments := arguments_fieldref(c)
    deref := deref_methodref(c)
    assign := Assign_methodref(c)

    every k := !undeclared do {
        linkvalue := create_fieldref(c, "v$" || k ||"$", "Lrts/vVariable;",
                                     java_classname)
        lab1 := label()
        field := create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, getstatic(linkvalue) )
        put(s, ifnonnull(lab1) )
        put(s, aload_0() )
        put(s, getfield(field) )
        put(s, invokestatic(null))
        put(s, invokevirtual(assign) )
        put(s, Pop())
        put(s, lab1 )
    }
end

procedure bc_emit_prologue(s, c, params, locals, undeclared, accumulate)
    bc_emit_prologue_params(s, c, params, accumulate)
    bc_emit_prologue_locals(s, c, locals)
    bc_emit_prologue_undeclared(s, c, undeclared)
end

procedure bc_createvars(s, c, params, locals, undeclared)
    local newsimplevar, k, field, v
    local linkvalue, lab1

    newsimplevar := New_vSimpleVar_methodref(c)
    every k := !params | !locals do {
        v := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        field := create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, aload_0() )
        put(s, ldc_w(v) )
        put(s, invokestatic(newsimplevar) )
        put(s, putfield(field) )
    }

    every k := !undeclared do {
        linkvalue := create_fieldref(c, "v$" || k ||"$", "Lrts/vVariable;",
                                     java_classname)
        lab1 := label()
        v := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        field := create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, aload_0() )
        put(s, getstatic(linkvalue) )
        put(s, dup() )
        put(s, ifnonnull(lab1) )
        put(s, Pop() )
        put(s, ldc_w(v) )
        put(s, invokestatic(newsimplevar) )
        put(s, lab1 )
        put(s, putfield(field) )
    }
end

procedure bc_create_createvars(c, params, locals, undeclared)
    local createvars, createvarscode

    createvars := create_method(c, 0, "createVars", "()V")
    createvarscode := create_code(c, 10, 10)
    put(createvars.attributes, createvarscode)

    bc_createvars(createvarscode.code, c, params, locals, undeclared)

    put(createvarscode.code, vreturn() )
end

procedure bc_copy_variable(s, c, k)
    local deref, assign, field

    deref := deref_methodref(c)
    assign := Assign_methodref(bc_proc_classptr)
    field := create_fieldref(c, "v$" || k, "Lrts/vVariable;", bc_proc_classname)
    put(s, aload_2() )
    put(s, getfield(field) )
    put(s, aload_0() )
    put(s, getfield(field) )
    put(s, invokevirtual(deref) )
    put(s, invokevirtual(assign) )
    put(s, Pop())
end

procedure bc_create_copy(c, params, locals, undeclared)
    local Copy, copycode, createvars, deref, assign
    local k, field, linkvalue, lab1, PC, init, class, s

    if \bc_create_exists then {
        Copy := create_method(c, 0, "copy", "(I)Lrts/iClosure;")
        copycode := create_code(c, 10, 10)
        put(Copy.attributes, copycode)
	s := copycode.code

        # local1 is PC
        # local2 is New
        class := cp_Class(c, cp_Utf8(c, bc_proc_classname))
        init := init_methodref(c, bc_proc_classname)
        put(s, new(class) )
        put(s, dup() )
        put(s, invokenonvirtual(init) )
        put(s, astore_2() )

        createvars := createVars_methodref(c, bc_proc_classname)
        put(s, aload_2() )
        put(s, invokevirtual(createvars) )
        deref := deref_methodref(c)
        assign := Assign_methodref(bc_proc_classptr)
        every k := !params | !locals do {
	    bc_copy_variable(s, c, k)
        }
        every k := !undeclared do {
            linkvalue := create_fieldref(c, "v$" || k ||"$", "Lrts/vVariable;",
                                         java_classname)
            lab1 := label()
            put(s, getstatic(linkvalue) )
            put(s, ifnonnull(lab1) )
	    bc_copy_variable(s, c, k)
            put(s, lab1 )
        }
        PC := PC_fieldref(c)
        put(s, aload_2() )
        put(s, iload_1() )
        put(s, putfield(PC) )
        put(s, aload_2() )
        put(s, areturn() )
    }
end

procedure bc_process_flags(flagList)
    local k

    if "-debug" == !flagList then {
        bc_debug := 1
    }
    if match("-O", !flagList) then {
        optimize_flag := 1
    }

    !flagList ? {
        ="-class:" & java_classname := tab(0)
        &fail
    }
    \java_classname | stop("ERROR: must specify -class:<name>")

    nodebuginfo := 1
    nointrospection := 1
    noerror2failure := 1
    every k := !flagList do {
        k ? {
            if ="-f" then {
                if find("e") | find("a") then {
                    noerror2failure := &null
                }
                if find("n") | find("a") then {
                    nodebuginfo := &null
                }
                if find("d") | find("a") then {
                    nointrospection := &null
                }
            }
        }
    }

    bc_directory := "./"
    bc_directory := (!flagList ? (="-dir:" & tab(0)))
end

procedure bc_File(irgen, flagList)
    local k, i, op, c, f, p

    bc_process_flags(flagList)

    bc_invoke_set := set([])
    bc_invoke_all := &null
    bc_link_set := set([])
    bc_global_set := set([])
    bc_proc_table := table()
    bc_record_table := table()
    bc_undeclared_set := set([])
    bc_op_table := table()
    bc_declare_set := set([])

    bc_cset_table := table()
    bc_string_table := table()
    bc_integer_table := table()
    bc_real_table := table()
    bc_keys_link := table()

    while p := @irgen do {
        case type(p) of {
        "irGlobal"    : bc_globals(p.nameList)
        "irRecord"    : bc_records(p.name, p.fieldList)
        "irInvocable" : bc_invocables(p.all, p.nameList)
        "irFunction"  : bc_function(p.name, p.paramList, p.accumulate,
                                    p.localList, p.staticList, p.codeList,
                                    p.codeStart)
        "irLink"      : bc_links(p.nameList)
        default       : runerr(500, p)
        }
    }

    c := bc_proc_classptr := ClassFile(3, 45, [&null], table(), 1, &null, &null,
                                       [], [], [], [])
    c.super_class := cp_Class(c, cp_Utf8(c, "rts/iFile"))
    c.this_class := cp_Class(c, cp_Utf8(c, java_classname))

    bc_create_declare(c)
    bc_create_unresolved(c)
    bc_create_linked(c)
    bc_create_resolve(c)
    bc_create_linkinit(c)
    bc_create_class_linkinit(c)

    f := open(bc_directory || java_classname || ".class","wu") | runerr(500)
    writer_ClassFile(f, c)
    close(f)
end

procedure bc_create_declare(c)
    local declare, declarecode, declareGlobal, k, s, declareProcedure
    local declareRecord, stringclass, i, f, declareNoErrorConversion

    declare := create_method(c, 0, "declare", "()V")
    declarecode := create_code(c, 10, 10)
    put(declare.attributes, declarecode)

    if \noerror2failure then {
        declareNoErrorConversion := declareNoErrorConversion_methodref(c)
        put(declarecode.code, invokestatic(declareNoErrorConversion) )
    }
    declareGlobal := declareGlobal_methodref(c)
    every k := !bc_global_set do {
        s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, ldc_w(s) )
        put(declarecode.code, invokestatic(declareGlobal) )
    }

    declareProcedure := declareProcedure_methodref(c)
    every k := key(bc_proc_table) do {
        s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, ldc_w(s) )
        s := cp_String(c, cp_Utf8(c, "p_" || java_classname || "$" || k)) |
            runerr(500)
        put(declarecode.code, ldc_w(s) )
        put(declarecode.code, ipush(bc_proc_table[k]) )
        put(declarecode.code, invokestatic(declareProcedure) )
    }

    declareRecord := declareRecord_methodref(c)
    stringclass := cp_Class(c, cp_Utf8(c, "java/lang/String"))
    every k := key(bc_record_table) do {
        s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, ldc_w(s) )

        put(declarecode.code, ipush(*bc_record_table[k]) )
        put(declarecode.code, anewarray(stringclass) )
        every i := 1 to *bc_record_table[k] do {
            put(declarecode.code, dup() )
            put(declarecode.code, ipush(i-1) )
            f := cp_String(c, cp_Utf8(c, bc_record_table[k][i])) | runerr(500)
            put(declarecode.code, ldc_w(f) )
            put(declarecode.code, aastore() )
        }
        put(declarecode.code, invokestatic(declareRecord) )
    }
    put(declarecode.code, vreturn() )
end

procedure bc_create_unresolved(c)
    local unresolved, unresolvedcode, invokeall, invokes, k, s
    local undeclaredmethod

    unresolved := create_method(c, 0, "unresolved", "()V")
    unresolvedcode := create_code(c, 10, 10)
    put(unresolved.attributes, unresolvedcode)

    if \bc_invoke_all then {
        invokeall := declareInvokeAll_methodref(c)
        put(unresolvedcode.code, invokestatic(invokeall) )
    } else {
        invokes := declareInvoke_methodref(c)
        every k := !bc_invoke_set do {
            s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
            put(unresolvedcode.code, ldc_w(s) )
            put(unresolvedcode.code, invokestatic(invokes) )
        }
    }

    undeclaredmethod := undeclared_methodref(c)
    every k := !bc_undeclared_set do {
        s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(unresolvedcode.code, ldc_w(s) )
        put(unresolvedcode.code, invokestatic(undeclaredmethod) )
    }
    put(unresolvedcode.code, vreturn() )
end

procedure bc_create_linked(c)
    local linked, linkedcode, linkref, lab, linkmethod, k, s, f

    if *bc_link_set > 0 then {
        create_field(c, 8, "linked", "Z")

        linked := create_method(c, 0, "link", "()V")
        linkedcode := create_code(c, 10, 10)
        put(linked.attributes, linkedcode)

        linkref := create_fieldref(c, "linked", "Z", java_classname)
        put(linkedcode.code, getstatic(linkref) )
        lab := label()
        put(linkedcode.code, ifne(lab) )
        put(linkedcode.code, iconst_1() )
        put(linkedcode.code, putstatic(linkref) )
        linkmethod := link_methodref(c)

        every k := !bc_link_set do {
            s := cp_String(c, cp_Utf8(c, "l$" || k)) | runerr(500)
            put(linkedcode.code, ldc_w(s) )
            put(linkedcode.code, invokestatic(linkmethod) )
        }

        put(linkedcode.code, lab )
        put(linkedcode.code, vreturn() )
    }
    f := open(bc_directory || "links", "w") | runerr(500)
    every k := !bc_link_set do {
        write(f, k)
    }
    close(f)
end

procedure bc_create_resolve(c)
    local resolve, resolvecode, resolvemethod, k, f, s, op

    resolve := create_method(c, 0, "resolve", "()V")
    resolvecode := create_code(c, 10, 10)
    put(resolve.attributes, resolvecode)

    resolvemethod := resolve_methodref(c)
    every k := !bc_undeclared_set do {
        f := create_fieldref(c, "v$" || k || "$", "Lrts/vVariable;",
                             java_classname)
        s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(resolvecode.code, ldc_w(s) )
        put(resolvecode.code, invokestatic(resolvemethod) )
        put(resolvecode.code, putstatic(f) )
    }

    resolvemethod := resolveKey_methodref(c)
    every k := key(bc_keys_link) do {
        f := create_fieldref(c, "$" || k, "Lrts/vDescriptor;",
                             java_classname)
        s := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(resolvecode.code, ldc_w(s) )
        put(resolvecode.code, invokestatic(resolvemethod) )
        put(resolvecode.code, putstatic(f) )
    }

    resolvemethod := resolveProc_methodref(c)
    every k := key(bc_op_table) do {
        k ? {
            op := tab(upto(','))
            move(1)
            args := integer(tab(0))
        }
        f := create_fieldref(c, bc_op_table[k], "Lrts/vDescriptor;",
                             java_classname)
        s := cp_String(c, cp_Utf8(c, op)) | runerr(500)
        put(resolvecode.code, ldc_w(s) )
        put(resolvecode.code, ipush(args) )
        put(resolvecode.code, invokestatic(resolvemethod) )
        put(resolvecode.code, putstatic(f) )
    }
    put(resolvecode.code, vreturn() )
end

procedure bc_create_linkinit(c)
    local init, initcode, constructor, s

    init := create_method(c, 1, "<init>", "()V")
    initcode := create_code(c, 10, 10)
    put(init.attributes, initcode)
    s := initcode.code

    every create_field(c, 8, "v$" || !bc_undeclared_set || "$",
                       "Lrts/vVariable;")
    every create_field(c, 8, "$" || key(bc_keys_link), "Lrts/vDescriptor;")
    every create_field(c, 8, !bc_op_table, "Lrts/vDescriptor;")

    constructor := init_methodref(c, "rts/iFile")
    put(s, aload_0() )
    put(s, invokenonvirtual(constructor) )
    put(s, vreturn() )
end

procedure bc_create_class_linkinit(c)
    local clinit, clinitcode, newmethod, k, f, d, s

    clinit := create_method(c, 8, "<clinit>", "()V")
    clinitcode := create_code(c, 10, 10)
    put(clinit.attributes, clinitcode)
    s := clinitcode.code

    newmethod := New_vReal_methodref(c)
    every k := key(bc_real_table) do {
        create_field(c, 8, bc_real_table[k], "Lrts/vReal;")
        f := create_fieldref(c, bc_real_table[k], "Lrts/vReal;",
                             java_classname)
        d := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(s, ldc_w(d) )
        put(s, invokestatic(newmethod) )
        put(s, putstatic(f) )
    }

    newmethod := New_vInteger_methodref(c)
    every k := key(bc_integer_table) do {
        create_field(c, 8, bc_integer_table[k], "Lrts/vInteger;")
        f := create_fieldref(c, bc_integer_table[k], "Lrts/vInteger;",
                             java_classname)
        d := cp_Long(c, k)
        put(s, ldc2_w(d) )
        put(s, invokestatic(newmethod) )
        put(s, putstatic(f) )
    }

    newmethod := New_vString_methodref(c)
    every k := key(bc_string_table) do {
        create_field(c, 8, bc_string_table[k], "Lrts/vString;")
        f := create_fieldref(c, bc_string_table[k], "Lrts/vString;",
                             java_classname)
        d := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(s, ldc_w(d) )
        put(s, invokestatic(newmethod) )
        put(s, putstatic(f) )
    }

    newmethod := New_vCset_methodref(c)
    every k := key(bc_cset_table) do {
        create_field(c, 8, bc_cset_table[k], "Lrts/vCset;")
        f := create_fieldref(c, bc_cset_table[k], "Lrts/vCset;",
                             java_classname)
        d := cp_String(c, cp_Utf8(c, k)) | runerr(500)
        put(s, ldc_w(d) )
        put(s, invokestatic(newmethod) )
        put(s, putstatic(f) )
    }

    put(s, vreturn() )
end
