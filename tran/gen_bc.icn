global optimize_flag, nolink_flag, java_classname, noerror2failure
global nodebuginfo, nointrospection

global bc_indirect_targets
global bc_directory
global bc_keys_link

global bc_proc_classptr
global bc_proc_classname
global bc_switch_label

global bc_tmplabel_table
global bc_tmplabel_offset

global bc_create_exists
global bc_save_restore_flag
global bc_declare_set
global bc_undeclared_set
global bc_debug
global bc_labels
global bc_ir2bc_labels
global bc_emit_table
global bc_invoke_set
global bc_invoke_all
global bc_link_set
global bc_global_set
global bc_record_table
global bc_proc_table
global bc_op_table
global bc_tmp_table
global bc_tmp_offset
global bc_tmpclosure_table
global bc_tmpclosure_offset
global bc_var_set
global bc_var_field
global bc_var_table
global bc_var_offset
global bc_key_table
global bc_args_set

global bc_cset_table
global bc_real_table
global bc_string_table
global bc_integer_table

global bc_locals_set
global bc_params_set
global bc_statics_set

procedure bc_transfer_to(s, p)
    case type(p) of {
    default: runerr(500, p)
    "ir_Label" : {
        put(s, j_goto_w(\bc_ir2bc_labels[p]) ) | runerr(500, p)
    }
    "ir_TmpLabel": {
        bc_gen_rval(s, p)
        put(s, j_goto_w(bc_switch_label) )
    }
    }
    return s
end

procedure bc_conditional_transfer_to(s, p, cond, notcond)
    local tmp

    case type(p) of {
    default: runerr(500, p)
    "ir_Label" : {
        put(s, cond(\bc_ir2bc_labels[p]) ) | runerr(500, p)
    }
    "ir_TmpLabel": {
        tmp := j_label()
        put(s, notcond(tmp))
        bc_gen_rval(s, p)
        put(s, j_goto_w(bc_switch_label) )
        put(s, tmp)
    }
    }
    return s
end

# assign top-of-stack to p
procedure bc_gen_assign_to(s, p)
    local assign

    case type(p) of {
    default: { runerr(500, p) }
    "ir_Tmp": {
        bc_gen_ir_Tmp_assign(s, p)
    }
    "ir_TmpLabel": {
        bc_gen_ir_TmpLabel_assign(s, p)
    }
    "ir_TmpClosure": {
        bc_gen_ir_TmpClosure_assign(s, p)
    }
    "ir_Var" |
    "ir_Key": {
        bc_gen(s, p)
        assign := Assign_methodref(bc_proc_classptr)
        put(s, j_swap())
        put(s, j_invokevirtual(assign))
        put(s, j_Pop())
    }
    }
    return s
end


# record ir_Free( v )
procedure bc_gen_ir_Free(s, p)
    local free, c, lab

    free := Free_methodref(bc_proc_classptr)
    every c := !p.v.clo do {
        lab := j_label()
        bc_gen_ir_TmpClosure_rval(s, c)
        put(s, j_ifnull(lab))
        bc_gen_ir_TmpClosure_rval(s, c)
        put(s, j_invokevirtual(free))
        put(s, j_aconst_null() )
        bc_gen_ir_TmpClosure_assign(s, c)
        put(s, lab)
    }
    return s
end

# record ir_Coord( coord )
procedure bc_gen_ir_Coord(s, p)
    local f, line, column, field

    /nodebuginfo | return s

    if f := j_cp_String(bc_proc_classptr,
              j_cp_Utf8(bc_proc_classptr, \(\p.coord).file)) then {
        field := file_fieldref(bc_proc_classptr)
        put(s, j_aload_0())
        put(s, j_ldc_w(f))
        put(s, j_putfield(field))
    }
    if line := \(\p.coord).line then {
        field := line_fieldref(bc_proc_classptr)
        put(s, j_aload_0())
        put(s, j_ipush(line, bc_proc_classptr))
        put(s, j_putfield(field))
    }
    return s
end

# record ir_Deref( value )
procedure bc_gen_ir_Deref(s, p)
    local deref

    bc_gen(s, p.value)
    deref := deref_methodref(bc_proc_classptr)
    put(s, j_invokevirtual(deref))
    return s
end

# record ir_Tmp( name )
procedure bc_gen_ir_Tmp_rval(s, p)
    put(s, j_Aload(bc_tmp_table[p.name] + bc_tmp_offset))
    return s
end
procedure bc_gen_ir_Tmp_assign(s, p)
    put(s, j_Astore(bc_tmp_table[p.name] + bc_tmp_offset))
    return s
end

# record ir_TmpLabel( name )
procedure bc_gen_ir_TmpLabel_rval(s, p)
    put(s, j_Iload(bc_tmplabel_table[p.name] + bc_tmplabel_offset))
    return s
end
procedure bc_gen_ir_TmpLabel_assign(s, p)
    put(s, j_Istore(bc_tmplabel_table[p.name] + bc_tmplabel_offset))
    return s
end

# record ir_TmpClosure( name )
procedure bc_gen_ir_TmpClosure_rval(s, p)
    put(s, j_Aload(bc_tmpclosure_table[p.name] + bc_tmpclosure_offset))
    return s
end
procedure bc_gen_ir_TmpClosure_assign(s, p)
    put(s, j_Astore(bc_tmpclosure_table[p.name] + bc_tmpclosure_offset))
    return s
end

# record ir_Label( value )
procedure bc_gen_ir_Label_rval(s, p)

    member(bc_indirect_targets, p) | runerr(500)

    \bc_labels[p] | runerr(500, p)
    put(s, j_ipush(bc_labels[p], bc_proc_classptr) )
    return s
end

# record ir_Field(lhs, expr, field, failLabel)
procedure bc_gen_ir_Field(s, p)
    local lab, method, fieldname, field, d

    field := field_fieldref(bc_proc_classptr)
    put(s, j_getstatic(field) )
    bc_gen_rval(s, p.expr)
    d := j_cp_String(bc_proc_classptr,
                   j_cp_Utf8(bc_proc_classptr, p.field)) | runerr(500)
    put(s, j_ldc_w(d) )
    put(s, j_aload_0())
    args := "Lrts/vDescriptor;Ljava/lang/String;Lrts/iClosure;"
    method := j_create_methodref(bc_proc_classptr, "call",
                               "(" || args || ")Lrts/vDescriptor;",
                               "rts/oField")
    put(s, j_invokevirtual(method))
    if \p.lhs then {
        put(s, j_dup() )
        lab := j_label()
        put(s, j_ifnonnull(lab) )
        put(s, j_Pop() )
        bc_transfer_to(s, p.failLabel)
        put(s, lab )
        bc_gen_assign_to(s, p.lhs)
    } else {
        bc_conditional_transfer_to(s, p.failLabel, j_ifnull, j_ifnonnull)
    }
    return s
end

# record ir_Move( lhs rhs )
procedure bc_gen_ir_Move(s, p)
    local deref

    \p.lhs | return s

    bc_gen_rval(s, p.rhs)
    if type(p.lhs) == ("ir_Key" | "ir_Var") then {
        deref := deref_methodref(bc_proc_classptr)
        put(s, j_invokevirtual(deref))
    }
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_ScanSwap( subject pos )
procedure bc_gen_ir_ScanSwap(s, p)
    local subject, pos, Ksubject, Kpos, deref, assign

    Ksubject := bc_gen([], ir_Key("subject"))
    Kpos := bc_gen([], ir_Key("pos"))
    subject := bc_gen([], p.subject)
    pos := bc_gen([], p.pos)

    deref := deref_methodref(bc_proc_classptr)
    assign := Assign_methodref(bc_proc_classptr)
    every put(s, !Kpos)
    put(s, j_invokevirtual(deref))
    every put(s, !Ksubject)
    put(s, j_invokevirtual(deref))

    every put(s, !Ksubject)
    every put(s, !subject)
    put(s, j_invokevirtual(deref))
    put(s, j_invokevirtual(assign))
    put(s, j_Pop())
    every put(s, !Kpos)
    every put(s, !pos)
    put(s, j_invokevirtual(deref))
    put(s, j_invokevirtual(assign))
    put(s, j_Pop())

    bc_gen_assign_to(s, p.subject)
    bc_gen_assign_to(s, p.pos)
    return s
end

# record ir_Goto( location )
procedure bc_gen_ir_Goto(s, p)
    bc_transfer_to(s, p.location)
    return s
end

# record ir_Var( name )
procedure bc_gen_ir_Var_rval(s, p)
    put(s, j_Aload(bc_var_table[p.name] + bc_var_offset))
    return s

    /bc_var_field[p.name] := j_create_fieldref(bc_proc_classptr, "v$" || p.name,
                                             "Lrts/vVariable;",
                                             bc_proc_classname)
    if member(bc_statics_set, p.name) then {
        put(s, j_getstatic(bc_var_field[p.name]))
    } else {
        put(s, j_aload_0() )
        put(s, j_getfield(bc_var_field[p.name]))
    }
    return s
end

# record ir_Key( name )
procedure bc_gen_ir_Key_register(p)
    bc_keys_link[p.name] := 1
    /bc_key_table[p.name] := j_create_fieldref(bc_proc_classptr, "$" || p.name,
                                             "Lrts/vDescriptor;",
                                             java_classname)
end
procedure bc_gen_ir_Key_rval(s, p)
    bc_gen_ir_Key_register(p)
    put(s, j_getstatic(bc_key_table[p.name]))
    return s
end

# record ir_IntLit( val )
procedure bc_gen_ir_IntLit(s, p)
    local i, field

    i := integer(p.val)
    /bc_integer_table[i] := "li$" || map(i, "-", "m")
    field := j_create_fieldref(bc_proc_classptr, bc_integer_table[i],
                             "Lrts/vInteger;", java_classname)
    put(s, j_getstatic(field))
    return s
end

# record ir_RealLit( val )
procedure bc_gen_ir_RealLit(s, p)
    local r, x, field

    r := real(p.val)
    /bc_real_table[r] := "lr$" || map(r, ".-+", "dmp")
    field := j_create_fieldref(bc_proc_classptr, bc_real_table[r], "Lrts/vReal;",
                             java_classname)
    put(s, j_getstatic(field))
    return s
end

# record ir_StrLit( val )
procedure bc_gen_ir_StrLit(s, p)
    local x, field

    /bc_string_table[p.val] := "ls$" || *bc_string_table
    field := j_create_fieldref(bc_proc_classptr, bc_string_table[p.val],
                             "Lrts/vString;", java_classname)
    put(s, j_getstatic(field))
    return s
end

# record ir_CsetLit( val )
procedure bc_gen_ir_CsetLit(s, p)
    local v, field

    /bc_cset_table[p.val] := "lc$" || *bc_cset_table
    field := j_create_fieldref(bc_proc_classptr, bc_cset_table[p.val],
                             "Lrts/vCset;", java_classname)
    put(s, j_getstatic(field))
    return s
end

# record ir_Restore( )
procedure bc_gen_ir_Restore(s, p)
    return s
end

procedure bc_save_tmps(s)
    local a, k

    if *bc_tmp_table > 0 then {
        a := j_create_fieldref(bc_proc_classptr, "tmpArray",
                             "[Lrts/vDescriptor;", bc_proc_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmp_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmp_table[k]))
            put(s, j_Aload(bc_tmp_table[k] + bc_tmp_offset))
            put(s, j_aastore())
        }
        put(s, j_Pop())
    }
end

procedure bc_save_tmplabels(s)
    local a, k

    if *bc_tmplabel_table > 0 then {
        a := j_create_fieldref(bc_proc_classptr, "tmpLabelArray", "[I",
                             bc_proc_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmplabel_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmplabel_table[k]))
            put(s, j_Iload(bc_tmplabel_table[k] + bc_tmplabel_offset))
            put(s, j_iastore())
        }
        put(s, j_Pop())
    }
end

procedure bc_save_tmpclosures(s)
    local a, k
    if *bc_tmpclosure_table > 0 then {
        a := j_create_fieldref(bc_proc_classptr, "tmpClosureArray",
                             "[Lrts/iClosure;", bc_proc_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmpclosure_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmpclosure_table[k]))
            put(s, j_Aload(bc_tmpclosure_table[k] + bc_tmpclosure_offset))
            put(s, j_aastore())
        }
        put(s, j_Pop())
    }
end

# record ir_Succeed( expr continuation )
procedure bc_gen_ir_Succeed(s, p)
    local r, e, PC, k, a

    PC := PC_fieldref(bc_proc_classptr)
    if \p.continuation then {
        \bc_save_restore_flag | runerr(500)

        put(s, j_aload_0())
        bc_gen(s, p.continuation)
        put(s, j_putfield(PC))

        bc_save_tmps(s)
        bc_save_tmplabels(s)
        bc_save_tmpclosures(s)
    } else {
        put(s, j_aload_0())
        put(s, j_iconst_0())
        put(s, j_putfield(PC))
    }
    bc_gen(s, p.expr)
    put(s, j_areturn())
    return s
end

# record ir_Fail( )
procedure bc_gen_ir_Fail(s, p)
    put(s, j_aconst_null())
    put(s, j_areturn())
    return s
end

# record ir_RunTimeError( )
procedure bc_gen_ir_RunTimeError(s, p)
    local runtimeerror

    runtimeerror := error_methodref(bc_proc_classptr)
    put(s, j_ipush(902))
    put(s, j_invokestatic(runtimeerror))
    put(s, j_aconst_null())
    put(s, j_areturn())
    return s
end

# record ir_Resume( closure failLabel retValue )
procedure bc_gen_ir_Resume(s, p)
    local c, PC, target, resume, free

    PC := PC_fieldref(bc_proc_classptr)
    resume := resume_methodref(bc_proc_classptr)
    bc_gen(s, p.closure)
    put(s, j_dup())
    put(s, j_getfield(PC))
    target := j_label()
    put(s, j_ifne(target))
    put(s, j_Pop())
    bc_transfer_to(s, p.failLabel)
    put(s, target)
    put(s, j_invokevirtual(resume))
    if \p.retValue then {
        put(s, j_dup())
        target := j_label()
        put(s, j_ifnonnull(target))
        put(s, j_Pop())
        bc_transfer_to(s, p.failLabel)
        put(s, target)
        bc_gen_assign_to(s, p.retValue)
    } else {
        bc_conditional_transfer_to(s, p.failLabel, j_ifnull, j_ifnonnull)
    }
    return s
end

# record ir_MakeList( lhs valueList )
procedure bc_gen_ir_MakeList(s, p)
    local r, v, i, method

    \p.lhs | return s

    put(s, j_ipush(*p.valueList))
    method := ArgArray_methodref(bc_proc_classptr);
    put(s, j_invokestatic(method))

    every i := 1 to *p.valueList do {
        put(s, j_dup())
        put(s, j_ipush(i-1))
        bc_gen(s, p.valueList[i])
        put(s, j_aastore())
    }
    method := New_vList_methodref(bc_proc_classptr)
    put(s, j_invokestatic(method))
    bc_gen_assign_to(s, p.lhs)
    return s
end

procedure initoptable()
    static optable
    initial {
        optable := [ table(), table(), table() ]
        optable[1]["#"] := "oLimit"
        optable[1]["."] := "oDeref"
        optable[1]["/"] := "oIsNull"
        optable[1]["\\"] := "oIsntNull"
        optable[1]["*"] := "oSize"
        optable[1]["?"] := "oSelect"
        optable[1]["+"] := "oNumerate"
        optable[1]["-"] := "oNegate"
        optable[1]["~"] := "oComplement"
        optable[1]["^"] := "oRefresh"
        optable[2][":="] := "oAssign"
        optable[2][":=:"] := "oSwap"
        optable[2]["&"] := "oConjunction"
        optable[2]["."] := "oField"
        optable[2]["[]"] := "oIndex"
        optable[2]["+"] := "oAdd"
        optable[2]["-"] := "oSub"
        optable[2]["*"] := "oMul"
        optable[2]["/"] := "oDiv"
        optable[2]["%"] := "oMod"
        optable[2]["^"] := "oPower"
        optable[2]["**"] := "oIntersect"
        optable[2]["++"] := "oUnion"
        optable[2]["--"] := "oDiff"
        optable[2]["<"] := "oNLess"
        optable[2]["<="] := "oNLessEq"
        optable[2]["="] := "oNEqual"
        optable[2]["~="] := "oNUnequal"
        optable[2][">="] := "oNGreaterEq"
        optable[2][">"] := "oNGreater"
        optable[2]["<<"] := "oLLess"
        optable[2]["<<="] := "oLLessEq"
        optable[2]["=="] := "oLEqual"
        optable[2]["~=="] := "oLUnequal"
        optable[2][">>="] := "oLGreaterEq"
        optable[2][">>"] := "oLGreater"
        optable[2]["==="] := "oVEqual"
        optable[2]["~==="] := "oVUnequal"
        optable[2]["|||"] := "oListConcat"
        optable[2]["||"] := "oConcat"
        optable[2]["@"] := "oActivate"
        optable[2][":?"] := "oSubjAssign"
        optable[3]["[:]"] := "oSection"
        optable[3]["[+:]"] := "oSectPlus"
        optable[3]["[-:]"] := "oSectMinus"
    }
    return optable
end

procedure bc_gen_call_op(s, p)
    local r, l, f, v, n, i, method

    type(p.fn) == "ir_Operator" | runerr(500, p.fn)

    bc_gen(s, p.fn)
    args := ""
    every i := 1 to *p.argList do {
        bc_gen(s, p.argList[i])
        args ||:= "Lrts/vDescriptor;"
    }
    put(s, j_aload_0())
    method := j_create_methodref(bc_proc_classptr, "instantiate",
                               "(" || args || "Lrts/iClosure;)Lrts/iClosure;",
                               "rts/vDescriptor")
    put(s, j_invokevirtual(method))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_OpFunction( lhs fn argList failLabel )
procedure bc_gen_ir_OpFunction(s, p)
    local target, args, method, class, i, op, field
    static optable
    initial optable := initoptable()

    p.fn.arity = *p.argList | runerr(500, p)
    op := \optable[p.fn.arity][p.fn.name] | runerr(500, p.fn)

    class := case p.fn.arity of {
        1 : "rts/iUnaryClosure"
        2 : "rts/iBinaryClosure"
        3 : "rts/iTrinaryClosure"
        default : runerr(500)
        }
    field := j_create_fieldref(bc_proc_classptr, "instance", "L" || class || ";",
                             "rts/" || op)
    put(s, j_getstatic(field) )

    args := ""
    every i := 1 to *p.argList do {
        bc_gen(s, p.argList[i])
        args ||:= "Lrts/vDescriptor;"
    }
    put(s, j_aload_0())
    args ||:= "Lrts/iClosure;"
    method := j_create_methodref(bc_proc_classptr, "call",
                               "(" || args || ")Lrts/vDescriptor;", class)
    put(s, j_invokevirtual(method))

    if \p.failLabel then {
        if \p.lhs then {
            put(s, j_dup())
            target := j_label()
            put(s, j_ifnonnull(target))
            put(s, j_Pop())
            bc_transfer_to(s, p.failLabel)
            put(s, target)
            bc_gen_assign_to(s, p.lhs)
        } else {
            bc_conditional_transfer_to(s, p.failLabel, j_ifnull, j_ifnonnull)
        }
    } else {
        if \p.lhs then {
            bc_gen_assign_to(s, p.lhs)
        } else {
            put(s, j_Pop())
        }
    }
    return s
end

# record ir_MakeClosure( lhs fn argList )
procedure bc_gen_ir_MakeClosure(s, p)
    local r, l, f, v, n, i, method

    \p.lhs | return ""

    if type(p.fn) == "ir_Operator" then {
        return bc_gen_call_op(s, p)
    }

    bc_gen(s, p.fn)
    put(s, j_ipush(*p.argList))
    method := ArgArray_methodref(bc_proc_classptr)
    put(s, j_invokestatic(method))

    every i := 1 to *p.argList do {
        put(s, j_dup())
        put(s, j_ipush(i-1))
        bc_gen(s, p.argList[i])
        put(s, j_aastore())
    }
    put(s, j_aload_0())
    method := Instantiate_methodref(bc_proc_classptr)
    put(s, j_invokestatic(method))
    bc_gen_assign_to(s, p.lhs)
    return s
end

# record ir_Operator( name arity )
procedure bc_gen_ir_Operator(s, p)
    local n, x, field

    n := p.name || "," || p.arity
    /bc_op_table[n] := "proc_" || *bc_op_table
    field := j_create_fieldref(bc_proc_classptr, bc_op_table[n],
                             "Lrts/vDescriptor;", java_classname)
    put(s, j_getstatic(field))
    return s
end

# record ir_Create( location )
procedure bc_gen_ir_Create(s, p)
    local copymethod, createmethod

    bc_create_exists := 1

    \bc_save_restore_flag | runerr(500)

    copymethod := copy_methodref(bc_proc_classptr, bc_proc_classname)
    createmethod := a_Create_methodref(bc_proc_classptr)
    put(s, j_aload_0())
    bc_gen(s, p.location)
    put(s, j_invokevirtual(copymethod))
    put(s, j_invokestatic(createmethod))
    return s
end

# record ir_CoRet( value continuation )
procedure bc_gen_ir_CoRet(s, p)
    local r, coretmethod, current

    coretmethod := coret_methodref(bc_proc_classptr)
    current := cur_coexp_fieldref(bc_proc_classptr)
    put(s, j_getstatic(current))
    bc_gen(s, p.value)
    put(s, j_invokevirtual(coretmethod))
    bc_transfer_to(s, p.continuation)
    return s
end

# record ir_CoFail( )
procedure bc_gen_ir_CoFail(s, p)
    local cofailmethod, current

    cofailmethod := cofail_methodref(bc_proc_classptr)
    current := cur_coexp_fieldref(bc_proc_classptr)
    put(s, j_getstatic(current))
    put(s, j_invokevirtual(cofailmethod))
    # the next two lines make the verifier happy.
    put(s, j_aconst_null())
    put(s, j_areturn())
    return s
end

# record ir_EnterInit( startlabel )
procedure bc_gen_ir_EnterInit(s, p)
    local target, initialized

    j_create_field(bc_proc_classptr, 8, "initialized", "Z")
    initialized := j_create_fieldref(bc_proc_classptr, "initialized", "Z",
                                   bc_proc_classname)
    put(s, j_getstatic(initialized))
    target := j_label()
    put(s, j_ifeq(target))
    bc_transfer_to(s, p.startlabel )
    put(s, target)
    put(s, j_iconst_1())
    put(s, j_putstatic(initialized))
    return s
end

procedure bc_gen_rval(s, p)
    return bc_gen(s, p)
end

procedure bc_gen(s, p)
    case type(p) of {
    "ir_Tmp" : return bc_gen_ir_Tmp_rval(s, p)
    "ir_TmpLabel" : return bc_gen_ir_TmpLabel_rval(s, p)
    "ir_TmpClosure" : return bc_gen_ir_TmpClosure_rval(s, p)
    "ir_Var" : return bc_gen_ir_Var_rval(s, p)
    "ir_Key" : return bc_gen_ir_Key_rval(s, p)
    "ir_Label" : return bc_gen_ir_Label_rval(s, p)
    "ir_Coord" : return bc_gen_ir_Coord(s, p)
    "ir_Deref" : return bc_gen_ir_Deref(s, p)
    "ir_Move" : return bc_gen_ir_Move(s, p)
    "ir_ScanSwap" : return bc_gen_ir_ScanSwap(s, p)
    "ir_Goto" : return bc_gen_ir_Goto(s, p)
    "ir_IntLit" : return bc_gen_ir_IntLit(s, p)
    "ir_RealLit" : return bc_gen_ir_RealLit(s, p)
    "ir_StrLit" : return bc_gen_ir_StrLit(s, p)
    "ir_CsetLit" : return bc_gen_ir_CsetLit(s, p)
    "ir_Restore" : return bc_gen_ir_Restore(s, p)
    "ir_Succeed" : return bc_gen_ir_Succeed(s, p)
    "ir_Fail" : return bc_gen_ir_Fail(s, p)
    "ir_Resume" : return bc_gen_ir_Resume(s, p)
    "ir_MakeList" : return bc_gen_ir_MakeList(s, p)
    "ir_OpFunction" : return bc_gen_ir_OpFunction(s, p)
    "ir_MakeClosure" : return bc_gen_ir_MakeClosure(s, p)
    "ir_Operator" : return bc_gen_ir_Operator(s, p)
    "ir_Create" : return bc_gen_ir_Create(s, p)
    "ir_CoRet" : return bc_gen_ir_CoRet(s, p)
    "ir_CoFail" : return bc_gen_ir_CoFail(s, p)
    "ir_RunTimeError" : return bc_gen_ir_RunTimeError(s, p)
    "ir_EnterInit" : return bc_gen_ir_EnterInit(s, p)
    "ir_Free" : return bc_gen_ir_Free(s, p)
    "ir_Field" : return bc_gen_ir_Field(s, p)
    default : { runerr(500, p); }
    }
end

procedure bc_emit(label, code)
    return bc_emit_table[label] := code
end

procedure bc_invocables(all, L)
    every insert(bc_invoke_set, !L)
    bc_invoke_all := \all
end

procedure bc_links(L)
    every insert(bc_link_set, !L)
end

procedure bc_records(name, fields, coord)
    if member(bc_declare_set, name) then {
        semantic_error(image(name) || ": inconsistent redeclaration", coord)
    }
    insert(bc_declare_set, name)
    bc_record_table[name] := fields
end

procedure bc_globals(L)
    every insert(bc_global_set, !L)
end

procedure bc_target_bookkeeping()
    local a, t, k

    bc_indirect_targets := set([])
    every a := !!bc_emit_table do {
        case type(a) of {
        "ir_CoRet":  t := a.continuation
        "ir_Create": t := a.location
        "ir_Move":   t := a.rhs
        "ir_Succeed":    t := a.continuation
        default: next
        }
        if type(t) == "ir_Label" then {
            insert(bc_indirect_targets, t)
        }
    }
    every a := !!!bc_emit_table & type(a) == "ir_Create" do {
        t := a.location
        if type(t) == "ir_Label" then {
            insert(bc_indirect_targets, t)
        }
    }
    every k := !bc_indirect_targets do {
        /bc_labels[k] := *bc_labels + 1
        bc_ir2bc_labels[k] := j_label()
    }
    every k := key(bc_emit_table) do {
        /bc_labels[k] := *bc_labels + 1
        bc_ir2bc_labels[k] := j_label()
    }
end

procedure bc_find_save_restore()
    local a

    bc_save_restore_flag := &null
    if a := !!bc_emit_table & type(a)=="ir_Succeed" & \a.continuation then {
        bc_save_restore_flag := 1
    }
    if a := !!!bc_emit_table & type(a)=="ir_Create" then {
        bc_save_restore_flag := 1
    }
end

procedure bc_alloc_tmps(s, c, class_index, class, classname)
    local a
    if *bc_tmp_table > 0 then {
        put(s, j_aload_0() )
        put(s, j_ipush(*bc_tmp_table) )
        class_index := j_cp_Class(c, j_cp_Utf8(c, "rts/vDescriptor"))
        put(s, j_anewarray(class_index) )
        a := j_create_fieldref(class, "tmpArray",
                             "[Lrts/vDescriptor;", classname)
        put(s, j_putfield(a) )
    }
end

procedure bc_alloc_tmplabels(s, c, class_index, class, classname)
    local a
    if *bc_tmplabel_table > 0 then {
        put(s, j_aload_0() )
        put(s, j_ipush(*bc_tmplabel_table) )
        put(s, j_newarray(10) )
        a := j_create_fieldref(class, "tmpLabelArray", "[I",
                             classname)
        put(s, j_putfield(a) )
    }
end

procedure bc_alloc_tmpclosures(s, c, class_index, class, classname)
    local a
    if *bc_tmpclosure_table > 0 then {
        put(s, j_aload_0() )
        put(s, j_ipush(*bc_tmpclosure_table) )
        class_index := j_cp_Class(c, j_cp_Utf8(c, "rts/iClosure"))
        put(s, j_anewarray(class_index) )
        a := j_create_fieldref(class, "tmpClosureArray",
                                 "[Lrts/iClosure;", classname)
        put(s, j_putfield(a) )
    }
end

procedure bc_function_variables(c, params, locals)
    local undeclared, k

    bc_locals_set := set(locals)
    bc_params_set := set(params)
    undeclared := bc_var_set -- bc_params_set -- bc_locals_set -- bc_statics_set
    every k := !params | !locals | !undeclared do {
        j_create_field(c, 0, "v$" || k, "Lrts/vVariable;")
    }
    return undeclared
end

procedure bc_function(name, params, accumulate, locals, statics, code,
                      codestart, coord)
    local undeclared, op, i, classname, k, insns, nextval, c
    local f, n, a, class_index, t

    bc_statics_set := set(statics)
    if member(bc_declare_set, name) then {
        semantic_error(image(name) || ": inconsistent redeclaration", coord)
    }
    insert(bc_declare_set, name)

    bc_proc_classname := "p_" || java_classname || "$" || name
    c := bc_proc_classptr := j_ClassFile(3, 45, [&null], table(), 1, &null, &null,
                                       [], [], [], [])
    c.super_class := j_cp_Class(c, j_cp_Utf8(c, "rts/iClosure"))
    c.this_class := j_cp_Class(c, j_cp_Utf8(c, bc_proc_classname))

    bc_proc_table[name] := if /accumulate then *params else -*params

    bc_args_set := set();
    bc_tmp_table := table()
    bc_tmplabel_table := table()
    bc_tmpclosure_table := table()
    bc_var_set := set([])
    bc_var_field := table()
    bc_var_table := table()
    bc_emit_table := table()
    bc_create_exists := &null
    bc_key_table := table()

    every i := !code do {
        bc_emit_table[i.label] := i.insnList
    }

    bc_labels := table()
    bc_ir2bc_labels := table()
    bc_labels[codestart] := 1
    bc_emit_table := optimize(bc_emit_table, codestart)

    bc_target_bookkeeping()
    bc_find_save_restore()
    bc_class_constructor(c, statics)
    bc_register(bc_emit_table)

    undeclared := bc_function_variables(c, params, locals)
    every insert(bc_undeclared_set, !undeclared)

    bc_create_nextval(c, codestart, params, locals, undeclared, accumulate)
    bc_create_constructor(c, class_index)
    bc_create_locals(c, undeclared, set(statics))
    bc_create_createvars(c, params, locals, undeclared)
    bc_create_copy(c, params, locals, undeclared)

    f := open(bc_directory || bc_proc_classname || ".class","wu") | runerr(500)
    j_writer_j_ClassFile(f, c)
    close(f)
end

procedure bc_class_constructor(c, statics)
    local clinit, clinitcode, k, f, n, j_newsimplevar

    clinit := j_create_method(c, 8, "<clinit>", "()V")
    clinitcode := j_create_code(c, 10, 10)
    put(clinit.attributes, clinitcode)

    j_newsimplevar := New_vSimpleVar_methodref(c)
    every k := !statics do {
        j_create_field(c, 8, "v$" || k, "Lrts/vVariable;")
        f := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;", bc_proc_classname)
        n := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(clinitcode.code, j_ldc_w(n))
        put(clinitcode.code, j_invokestatic(j_newsimplevar))
        put(clinitcode.code, j_putstatic(f))
    }
    put(clinitcode.code, j_vreturn() )
end

procedure bc_create_constructor(c, class_index)
    local init, initcode, constructor, createvars, s

    init := j_create_method(c, 1, "<init>", "()V")
    initcode := j_create_code(c, 10, 10)
    put(init.attributes, initcode)
    s := initcode.code
    if \bc_save_restore_flag then {
        if *bc_tmp_table > 0 then {
            j_create_field(bc_proc_classptr, 0, "tmpArray", "[Lrts/vDescriptor;")
        }
        if *bc_tmpclosure_table > 0 then {
            j_create_field(bc_proc_classptr, 0, "tmpClosureArray",
             "[Lrts/iClosure;")
        }
        if *bc_tmplabel_table > 0 then {
            j_create_field(bc_proc_classptr, 0, "tmpLabelArray", "[I")
        }
    }
    constructor := init_methodref(c, "rts/iClosure")
    put(s, j_aload_0() )
    put(s, j_invokenonvirtual(constructor) )
    createvars := createVars_methodref(c, bc_proc_classname)
    put(s, j_aload_0() )
    put(s, j_invokevirtual(createvars) )

    if \bc_save_restore_flag then {
        bc_alloc_tmps(s, c, class_index, bc_proc_classptr,
                      bc_proc_classname)
        bc_alloc_tmplabels(s, c, class_index, bc_proc_classptr,
                           bc_proc_classname)
        bc_alloc_tmpclosures(s, c, class_index, bc_proc_classptr,
                             bc_proc_classname)
    }
    put(s, j_vreturn() )
end

procedure bc_register(t)
    local op

    every op := !!!t do {
        bc_register0(op)
    }
end

procedure bc_register0(op)
    case type(op) of {
    "list" : every bc_register0(!op)
    "ir_Tmp" :        /bc_tmp_table[op.name] := *bc_tmp_table;
    "ir_TmpLabel" :   /bc_tmplabel_table[op.name] := *bc_tmplabel_table
    "ir_TmpClosure" : /bc_tmpclosure_table[op.name] := *bc_tmpclosure_table
    "ir_Var" : {
                     insert(bc_var_set, op.name)
                     /bc_var_table[op.name] := *bc_var_table
    }
    }
end

procedure bc_restore_tmps(s)
    local a, k

    if *bc_tmp_table > 0 then {
        a := j_create_fieldref(bc_proc_classptr, "tmpArray",
                             "[Lrts/vDescriptor;", bc_proc_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmp_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmp_table[k]))
            put(s, j_aaload())
            put(s, j_Astore(bc_tmp_table[k] + bc_tmp_offset))
        }
        put(s, j_Pop())
    }
end

procedure bc_restore_tmpclosures(s)
    local a, k

    if *bc_tmpclosure_table > 0 then {
        a := j_create_fieldref(bc_proc_classptr, "tmpClosureArray",
                             "[Lrts/iClosure;", bc_proc_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmpclosure_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmpclosure_table[k]))
            put(s, j_aaload())
            put(s, j_Astore(bc_tmpclosure_table[k] + bc_tmpclosure_offset))
        }
        put(s, j_Pop())
    }
end

procedure bc_restore_tmplabels(s)
    local a, k

    if *bc_tmplabel_table > 0 then {
        a := j_create_fieldref(bc_proc_classptr, "tmpLabelArray", "[I",
                             bc_proc_classname)
        put(s, j_aload_0())
        put(s, j_getfield(a))
        every k := key(bc_tmplabel_table) do {
            put(s, j_dup())
            put(s, j_ipush(bc_tmplabel_table[k]))
            put(s, j_iaload())
            put(s, j_Istore(bc_tmplabel_table[k] + bc_tmplabel_offset))
        }
        put(s, j_Pop())
    }
end

procedure bc_create_nextval(c, start, params, locals, undeclared, accumulate)
    local PC, nextval, nextvalcode, k, lab, switch, insns, deflab
    local runtimeerror, r
    local a, s, tmplab, prologue, var_load_label, t, tmpset

    nextval := j_create_method(c, 0, "nextval", "()Lrts/vDescriptor;")
    nextvalcode := j_create_code(c, 10, 10)
    put(nextval.attributes, nextvalcode)
    s := nextvalcode.code

    bc_tmp_offset := 10
    bc_tmplabel_offset := bc_tmp_offset + *bc_tmp_table
    bc_tmpclosure_offset := bc_tmplabel_offset + *bc_tmplabel_table
    bc_var_offset := bc_tmpclosure_offset + *bc_tmpclosure_table
    nextvalcode.max_locals := bc_var_offset + *bc_var_table

    bc_switch_label := j_label()
    var_load_label := j_label()
    tmplab := j_label()

    if \bc_save_restore_flag then {
        PC := PC_fieldref(c)
        put(s, j_aload_0() )
        put(s, j_getfield(PC))
        put(s, j_dup())
        put(s, j_iconst_1())
        put(s, j_if_icmpne(tmplab))
    }
    bc_emit_prologue(s, c, params, locals, undeclared, accumulate)
    bc_initialize_tmps(s)
    if \bc_save_restore_flag then {
        put(s, j_goto_w(var_load_label))
        put(s, tmplab)
        bc_restore_tmps(s)
        bc_restore_tmplabels(s)
        bc_restore_tmpclosures(s)
    }

    put(s, var_load_label)
    bc_load_variables(s)

    deflab := j_label()
    member(bc_indirect_targets, start) & runerr(500)
    switch := j_tableswitch(0, deflab, 1, *bc_indirect_targets+1,
                          list(*bc_indirect_targets+1))
    every k := (!bc_indirect_targets | start) do {
        switch.offsets[\bc_labels[k]] := \bc_ir2bc_labels[k] | runerr(500,k)
    }

    if \bc_save_restore_flag then {
        put(s, j_goto_w(bc_switch_label) )
    }
    bc_emit_code(s, switch, start)
    put(s, bc_switch_label)
    if *bc_indirect_targets > 0 then {
        put(s, switch)
        runtimeerror := error_methodref(c)
        put(s, deflab)
        put(s, j_ipush(902) )
        put(s, j_invokestatic(runtimeerror) )
        put(s, j_aconst_null())
        put(s, j_areturn())
    } else {
        /bc_save_restore_flag | runerr(500)
    }
end

procedure bc_load_variables(s)
    local k

    every k := key(bc_var_table) do {
        /bc_var_field[k] := j_create_fieldref(bc_proc_classptr, "v$" || k,
                                            "Lrts/vVariable;",
                                            bc_proc_classname)
        if member(bc_statics_set, k) then {
            put(s, j_getstatic(bc_var_field[k]))
        } else {
            put(s, j_aload_0() )
            put(s, j_getfield(bc_var_field[k]))
        }
        put(s, j_Astore(bc_var_table[k] + bc_var_offset))
    }
end

procedure bc_initialize_tmps(s)
    local k

    every k := key(bc_tmp_table) do {
        put(s, j_aconst_null())
        put(s, j_Astore(bc_tmp_table[k] + bc_tmp_offset))
    }
    every k := key(bc_tmpclosure_table) do {
        put(s, j_aconst_null())
        put(s, j_Astore(bc_tmpclosure_table[k] + bc_tmpclosure_offset))
    }
    every k := key(bc_tmplabel_table) do {
        put(s, j_iconst_0())
        put(s, j_Istore(bc_tmplabel_table[k] + bc_tmplabel_offset))
    }
end

global bc_emitted

procedure bc_emit_code0(s, switch, k)
    local lab, insns, i

    if member(bc_emitted, k) then return
    insert(bc_emitted, k)

    lab := bc_ir2bc_labels[k]
    put(s, lab)
    insns := bc_emit_table[k]
    every i := insns[1 to *insns-1] do {
        bc_gen(s, i)
    }
    if type(insns[-1]) == "ir_Goto" &
       type(insns[-1].location) == "ir_Label" &
       not member(bc_emitted, insns[-1].location) then {
        bc_emit_code0(s, switch, insns[-1].location)
    } else {
        bc_gen(s, insns[-1])
    }
end

procedure bc_emit_code(s, switch, start)
    bc_emitted := set([])
    bc_emit_code0(s, switch, start)
    every bc_emit_code0(s, switch, key(bc_emit_table))
end

procedure bc_create_locals(c, undeclared, statics)
    local locals, localscode, names, variables, k, lab
    local shadow, index, class_index, m, s, sortedvars

    sortedvars := sort(bc_var_set ++ bc_params_set ++ bc_locals_set ++
                       bc_statics_set)

    locals := j_create_method(c, 0, "locals", "()V")
    localscode := j_create_code(c, 10, 10)
    put(locals.attributes, localscode)
    s := localscode.code

    if \nointrospection then {
        m := error_methodref(c)
        put(s, j_ipush(905))
        put(s, j_invokestatic(m))
        put(s, j_vreturn() )
        return
    }
    # local1 is int counter
    put(s, j_iconst_0() )
    put(s, j_istore_1() )
    names := names_fieldref(c)
    class_index := j_cp_Class(c, j_cp_Utf8(c, "java/lang/String"))
    put(s, j_aload_0() )
    put(s, j_ipush(*sortedvars+1) )
    put(s, j_anewarray(class_index) )
    put(s, j_putfield(names) )
    variables := variables_fieldref(c)
    class_index := j_cp_Class(c, j_cp_Utf8(c, "rts/vVariable"))
    put(s, j_aload_0() )
    put(s, j_ipush(*sortedvars+1) )
    put(s, j_anewarray(class_index) )
    put(s, j_putfield(variables) )

    every k := !sortedvars do {
        lab := j_label()
        if member(undeclared, k) then {
            shadow := j_create_fieldref(c, "v$" || k || "$", "Lrts/vVariable;",
                                      java_classname)
            put(s, j_getstatic(shadow) )
            put(s, j_ifnonnull(lab) )
        }
        index := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_aload_0() )
        put(s, j_getfield(names) )
        put(s, j_iload_1() )
        put(s, j_ldc_w(index) )
        put(s, j_aastore() )

        index := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, j_aload_0() )
        put(s, j_getfield(variables) )
        put(s, j_iload_1() )
        if member(statics, k) then {
            put(s, j_getstatic(index) )
        } else {
            put(s, j_aload_0() )
            put(s, j_getfield(index) )
        }
        put(s, j_aastore() )

        put(s, j_iinc(1,1) )
        put(s, lab )
    }
    put(s, j_aload_0() )
    put(s, j_getfield(names) )
    put(s, j_iload_1() )
    put(s, j_aconst_null() )
    put(s, j_aastore() )

    put(s, j_aload_0() )
    put(s, j_getfield(variables) )
    put(s, j_iload_1() )
    put(s, j_aconst_null() )
    put(s, j_aastore() )
    put(s, j_vreturn() )
end

procedure bc_emit_prologue_params(s, c, params, accumulate)
    local marshal, i, k, field, elselab, endlab
    local null, arguments, deref, assign

    null := New_vNull_methodref(bc_proc_classptr)
    arguments := arguments_fieldref(c)
    deref := deref_methodref(c)
    assign := Assign_methodref(c)

    every i := 1 to *params do {
        k := params[i]
        field := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, j_aload_0() )
        put(s, j_getfield(field) )

        if i = *params & \accumulate then {
            marshal := marshal_methodref(c)
            put(s, j_aload_0() )
            put(s, j_getfield(arguments))
            put(s, j_ipush(*params))
            put(s, j_invokestatic(marshal))
            put(s, j_invokevirtual(assign) )
            put(s, j_Pop())
        } else {
            elselab := j_label()
            endlab := j_label()
            put(s, j_aload_0() )
            put(s, j_getfield(arguments))
            put(s, j_dup())
            put(s, j_arraylength())
            put(s, j_ipush(i))
            put(s, j_if_icmpge(elselab))
                put(s, j_Pop())
                put(s, j_invokestatic(null))
                put(s, j_goto(endlab))
            put(s, elselab)
                put(s, j_ipush(i-1))
                put(s, j_aaload())
                put(s, j_invokevirtual(deref) )
            put(s, endlab)
            put(s, j_invokevirtual(assign) )
            put(s, j_Pop())
        }
    }
end

procedure bc_emit_prologue_locals(s, c, locals)
    local k, field
    local null, arguments, deref, assign

    null := New_vNull_methodref(bc_proc_classptr)
    arguments := arguments_fieldref(c)
    deref := deref_methodref(c)
    assign := Assign_methodref(c)

    every k := !locals do {
        field := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, j_aload_0() )
        put(s, j_getfield(field) )
        put(s, j_invokestatic(null))
        put(s, j_invokevirtual(assign) )
        put(s, j_Pop())
    }
end

procedure bc_emit_prologue_undeclared(s, c, undeclared)
    local k, field, lab1, linkvalue
    local null, arguments, deref, assign

    null := New_vNull_methodref(bc_proc_classptr)
    arguments := arguments_fieldref(c)
    deref := deref_methodref(c)
    assign := Assign_methodref(c)

    every k := !undeclared do {
        linkvalue := j_create_fieldref(c, "v$" || k ||"$", "Lrts/vVariable;",
                                     java_classname)
        lab1 := j_label()
        field := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, j_getstatic(linkvalue) )
        put(s, j_ifnonnull(lab1) )
        put(s, j_aload_0() )
        put(s, j_getfield(field) )
        put(s, j_invokestatic(null))
        put(s, j_invokevirtual(assign) )
        put(s, j_Pop())
        put(s, lab1 )
    }
end

procedure bc_emit_prologue(s, c, params, locals, undeclared, accumulate)
    bc_emit_prologue_params(s, c, params, accumulate)
    bc_emit_prologue_locals(s, c, locals)
    bc_emit_prologue_undeclared(s, c, undeclared)
end

procedure bc_createvars(s, c, params, locals, undeclared)
    local j_newsimplevar, k, field, v
    local linkvalue, lab1

    j_newsimplevar := New_vSimpleVar_methodref(c)
    every k := !params | !locals do {
        v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        field := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, j_aload_0() )
        put(s, j_ldc_w(v) )
        put(s, j_invokestatic(j_newsimplevar) )
        put(s, j_putfield(field) )
    }

    every k := !undeclared do {
        linkvalue := j_create_fieldref(c, "v$" || k ||"$", "Lrts/vVariable;",
                                     java_classname)
        lab1 := j_label()
        v := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        field := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;",
                                 bc_proc_classname)
        put(s, j_aload_0() )
        put(s, j_getstatic(linkvalue) )
        put(s, j_dup() )
        put(s, j_ifnonnull(lab1) )
        put(s, j_Pop() )
        put(s, j_ldc_w(v) )
        put(s, j_invokestatic(j_newsimplevar) )
        put(s, lab1 )
        put(s, j_putfield(field) )
    }
end

procedure bc_create_createvars(c, params, locals, undeclared)
    local createvars, createvarscode

    createvars := j_create_method(c, 0, "createVars", "()V")
    createvarscode := j_create_code(c, 10, 10)
    put(createvars.attributes, createvarscode)

    bc_createvars(createvarscode.code, c, params, locals, undeclared)

    put(createvarscode.code, j_vreturn() )
end

procedure bc_copy_variable(s, c, k)
    local deref, assign, field

    deref := deref_methodref(c)
    assign := Assign_methodref(bc_proc_classptr)
    field := j_create_fieldref(c, "v$" || k, "Lrts/vVariable;", bc_proc_classname)
    put(s, j_aload_2() )
    put(s, j_getfield(field) )
    put(s, j_aload_0() )
    put(s, j_getfield(field) )
    put(s, j_invokevirtual(deref) )
    put(s, j_invokevirtual(assign) )
    put(s, j_Pop())
end

procedure bc_create_copy(c, params, locals, undeclared)
    local Copy, copycode, createvars, deref, assign
    local k, field, linkvalue, lab1, PC, init, class, s

    if \bc_create_exists then {
        Copy := j_create_method(c, 0, "copy", "(I)Lrts/iClosure;")
        copycode := j_create_code(c, 10, 10)
        put(Copy.attributes, copycode)
        s := copycode.code

        # local1 is PC
        # local2 is New
        class := j_cp_Class(c, j_cp_Utf8(c, bc_proc_classname))
        init := init_methodref(c, bc_proc_classname)
        put(s, j_new(class) )
        put(s, j_dup() )
        put(s, j_invokenonvirtual(init) )
        put(s, j_astore_2() )

        createvars := createVars_methodref(c, bc_proc_classname)
        put(s, j_aload_2() )
        put(s, j_invokevirtual(createvars) )
        deref := deref_methodref(c)
        assign := Assign_methodref(bc_proc_classptr)
        every k := !params | !locals do {
            bc_copy_variable(s, c, k)
        }
        every k := !undeclared do {
            linkvalue := j_create_fieldref(c, "v$" || k ||"$", "Lrts/vVariable;",
                                         java_classname)
            lab1 := j_label()
            put(s, j_getstatic(linkvalue) )
            put(s, j_ifnonnull(lab1) )
            bc_copy_variable(s, c, k)
            put(s, lab1 )
        }
        PC := PC_fieldref(c)
        put(s, j_aload_2() )
        put(s, j_iload_1() )
        put(s, j_putfield(PC) )
        put(s, j_aload_2() )
        put(s, j_areturn() )
    }
end

procedure bc_process_flags(flagList)
    local k

    if "-debug" == !flagList then {
        bc_debug := 1
    }
    if match("-O", !flagList) then {
        optimize_flag := 1
    }

    !flagList ? {
        ="-class:" & java_classname := tab(0)
        &fail
    }
    \java_classname | stop("ERROR: must specify -class:<name>")

    nodebuginfo := 1
    nointrospection := 1
    noerror2failure := 1
    every k := !flagList do {
        k ? {
            if ="-f" then {
                if find("e") | find("a") then {
                    noerror2failure := &null
                }
                if find("n") | find("a") then {
                    nodebuginfo := &null
                }
                if find("d") | find("a") then {
                    nointrospection := &null
                }
            }
        }
    }

    bc_directory := "./"
    bc_directory := (!flagList ? (="-dir:" & tab(0)))
end

procedure bc_File(irgen, flagList)
    local k, i, op, c, f, p

    bc_process_flags(flagList)

    bc_invoke_set := set([])
    bc_invoke_all := &null
    bc_link_set := set([])
    bc_global_set := set([])
    bc_proc_table := table()
    bc_record_table := table()
    bc_undeclared_set := set([])
    bc_op_table := table()
    bc_declare_set := set([])

    bc_cset_table := table()
    bc_string_table := table()
    bc_integer_table := table()
    bc_real_table := table()
    bc_keys_link := table()

    while p := @irgen do {
        case type(p) of {
        "ir_Global"    : bc_globals(p.nameList)
        "ir_Record"    : bc_records(p.name, p.fieldList)
        "ir_Invocable" : bc_invocables(p.all, p.nameList)
        "ir_Function"  : bc_function(p.name, p.paramList, p.accumulate,
                                    p.localList, p.staticList, p.codeList,
                                    p.codeStart)
        "ir_Link"      : bc_links(p.nameList)
        default       : runerr(500, p)
        }
    }

    c := bc_proc_classptr := j_ClassFile(3, 45, [&null], table(), 1, &null, &null,
                                       [], [], [], [])
    c.super_class := j_cp_Class(c, j_cp_Utf8(c, "rts/iFile"))
    c.this_class := j_cp_Class(c, j_cp_Utf8(c, java_classname))

    bc_create_declare(c)
    bc_create_unresolved(c)
    bc_create_linked(c)
    bc_create_resolve(c)
    bc_create_linkinit(c)
    bc_create_class_linkinit(c)

    f := open(bc_directory || java_classname || ".class","wu") | runerr(500)
    j_writer_j_ClassFile(f, c)
    close(f)
end

procedure bc_create_declare(c)
    local declare, declarecode, declareGlobal, k, s, declareProcedure
    local declareRecord, stringclass, i, f, declareNoErrorConversion

    declare := j_create_method(c, 0, "declare", "()V")
    declarecode := j_create_code(c, 10, 10)
    put(declare.attributes, declarecode)

    if \noerror2failure then {
        declareNoErrorConversion := declareNoErrorConversion_methodref(c)
        put(declarecode.code, j_invokestatic(declareNoErrorConversion) )
    }
    declareGlobal := declareGlobal_methodref(c)
    every k := !bc_global_set do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, j_ldc_w(s) )
        put(declarecode.code, j_invokestatic(declareGlobal) )
    }

    declareProcedure := declareProcedure_methodref(c)
    every k := key(bc_proc_table) do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, j_ldc_w(s) )
        s := j_cp_String(c, j_cp_Utf8(c, "p_" || java_classname || "$" || k)) |
            runerr(500)
        put(declarecode.code, j_ldc_w(s) )
        put(declarecode.code, j_ipush(bc_proc_table[k]) )
        put(declarecode.code, j_invokestatic(declareProcedure) )
    }

    declareRecord := declareRecord_methodref(c)
    stringclass := j_cp_Class(c, j_cp_Utf8(c, "java/lang/String"))
    every k := key(bc_record_table) do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(declarecode.code, j_ldc_w(s) )

        put(declarecode.code, j_ipush(*bc_record_table[k]) )
        put(declarecode.code, j_anewarray(stringclass) )
        every i := 1 to *bc_record_table[k] do {
            put(declarecode.code, j_dup() )
            put(declarecode.code, j_ipush(i-1) )
            f := j_cp_String(c, j_cp_Utf8(c, bc_record_table[k][i])) | runerr(500)
            put(declarecode.code, j_ldc_w(f) )
            put(declarecode.code, j_aastore() )
        }
        put(declarecode.code, j_invokestatic(declareRecord) )
    }
    put(declarecode.code, j_vreturn() )
end

procedure bc_create_unresolved(c)
    local unresolved, unresolvedcode, invokeall, invokes, k, s
    local undeclaredmethod

    unresolved := j_create_method(c, 0, "unresolved", "()V")
    unresolvedcode := j_create_code(c, 10, 10)
    put(unresolved.attributes, unresolvedcode)

    if \bc_invoke_all then {
        invokeall := declareInvokeAll_methodref(c)
        put(unresolvedcode.code, j_invokestatic(invokeall) )
    } else {
        invokes := declareInvoke_methodref(c)
        every k := !bc_invoke_set do {
            s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
            put(unresolvedcode.code, j_ldc_w(s) )
            put(unresolvedcode.code, j_invokestatic(invokes) )
        }
    }

    undeclaredmethod := undeclared_methodref(c)
    every k := !bc_undeclared_set do {
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(unresolvedcode.code, j_ldc_w(s) )
        put(unresolvedcode.code, j_invokestatic(undeclaredmethod) )
    }
    put(unresolvedcode.code, j_vreturn() )
end

procedure bc_create_linked(c)
    local linked, linkedcode, linkref, lab, linkmethod, k, s, f

    if *bc_link_set > 0 then {
        j_create_field(c, 8, "linked", "Z")

        linked := j_create_method(c, 0, "link", "()V")
        linkedcode := j_create_code(c, 10, 10)
        put(linked.attributes, linkedcode)

        linkref := j_create_fieldref(c, "linked", "Z", java_classname)
        put(linkedcode.code, j_getstatic(linkref) )
        lab := j_label()
        put(linkedcode.code, j_ifne(lab) )
        put(linkedcode.code, j_iconst_1() )
        put(linkedcode.code, j_putstatic(linkref) )
        linkmethod := link_methodref(c)

        every k := !bc_link_set do {
            s := j_cp_String(c, j_cp_Utf8(c, "l$" || k)) | runerr(500)
            put(linkedcode.code, j_ldc_w(s) )
            put(linkedcode.code, j_invokestatic(linkmethod) )
        }

        put(linkedcode.code, lab )
        put(linkedcode.code, j_vreturn() )
    }
    f := open(bc_directory || "links", "w") | runerr(500)
    every k := !bc_link_set do {
        write(f, k)
    }
    close(f)
end

procedure bc_create_resolve(c)
    local resolve, resolvecode, resolvemethod, k, f, s, op

    resolve := j_create_method(c, 0, "resolve", "()V")
    resolvecode := j_create_code(c, 10, 10)
    put(resolve.attributes, resolvecode)

    resolvemethod := resolve_methodref(c)
    every k := !bc_undeclared_set do {
        f := j_create_fieldref(c, "v$" || k || "$", "Lrts/vVariable;",
                             java_classname)
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(resolvecode.code, j_ldc_w(s) )
        put(resolvecode.code, j_invokestatic(resolvemethod) )
        put(resolvecode.code, j_putstatic(f) )
    }

    resolvemethod := resolveKey_methodref(c)
    every k := key(bc_keys_link) do {
        f := j_create_fieldref(c, "$" || k, "Lrts/vDescriptor;",
                             java_classname)
        s := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(resolvecode.code, j_ldc_w(s) )
        put(resolvecode.code, j_invokestatic(resolvemethod) )
        put(resolvecode.code, j_putstatic(f) )
    }

    resolvemethod := resolveProc_methodref(c)
    every k := key(bc_op_table) do {
        k ? {
            op := tab(upto(','))
            move(1)
            args := integer(tab(0))
        }
        f := j_create_fieldref(c, bc_op_table[k], "Lrts/vDescriptor;",
                             java_classname)
        s := j_cp_String(c, j_cp_Utf8(c, op)) | runerr(500)
        put(resolvecode.code, j_ldc_w(s) )
        put(resolvecode.code, j_ipush(args) )
        put(resolvecode.code, j_invokestatic(resolvemethod) )
        put(resolvecode.code, j_putstatic(f) )
    }
    put(resolvecode.code, j_vreturn() )
end

procedure bc_create_linkinit(c)
    local init, initcode, constructor, s

    init := j_create_method(c, 1, "<init>", "()V")
    initcode := j_create_code(c, 10, 10)
    put(init.attributes, initcode)
    s := initcode.code

    every j_create_field(c, 8, "v$" || !bc_undeclared_set || "$",
                       "Lrts/vVariable;")
    every j_create_field(c, 8, "$" || key(bc_keys_link), "Lrts/vDescriptor;")
    every j_create_field(c, 8, !bc_op_table, "Lrts/vDescriptor;")

    constructor := init_methodref(c, "rts/iFile")
    put(s, j_aload_0() )
    put(s, j_invokenonvirtual(constructor) )
    put(s, j_vreturn() )
end

procedure bc_create_class_linkinit(c)
    local clinit, clinitcode, j_newmethod, k, f, d, s

    clinit := j_create_method(c, 8, "<clinit>", "()V")
    clinitcode := j_create_code(c, 10, 10)
    put(clinit.attributes, clinitcode)
    s := clinitcode.code

    j_newmethod := New_vReal_methodref(c)
    every k := key(bc_real_table) do {
        j_create_field(c, 8, bc_real_table[k], "Lrts/vReal;")
        f := j_create_fieldref(c, bc_real_table[k], "Lrts/vReal;",
                             java_classname)
        d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(d) )
        put(s, j_invokestatic(j_newmethod) )
        put(s, j_putstatic(f) )
    }

    j_newmethod := New_vInteger_methodref(c)
    every k := key(bc_integer_table) do {
        j_create_field(c, 8, bc_integer_table[k], "Lrts/vInteger;")
        f := j_create_fieldref(c, bc_integer_table[k], "Lrts/vInteger;",
                             java_classname)
        d := j_cp_Long(c, k)
        put(s, j_ldc2_w(d) )
        put(s, j_invokestatic(j_newmethod) )
        put(s, j_putstatic(f) )
    }

    j_newmethod := New_vString_methodref(c)
    every k := key(bc_string_table) do {
        j_create_field(c, 8, bc_string_table[k], "Lrts/vString;")
        f := j_create_fieldref(c, bc_string_table[k], "Lrts/vString;",
                             java_classname)
        d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(d) )
        put(s, j_invokestatic(j_newmethod) )
        put(s, j_putstatic(f) )
    }

    j_newmethod := New_vCset_methodref(c)
    every k := key(bc_cset_table) do {
        j_create_field(c, 8, bc_cset_table[k], "Lrts/vCset;")
        f := j_create_fieldref(c, bc_cset_table[k], "Lrts/vCset;",
                             java_classname)
        d := j_cp_String(c, j_cp_Utf8(c, k)) | runerr(500)
        put(s, j_ldc_w(d) )
        put(s, j_invokestatic(j_newmethod) )
        put(s, j_putstatic(f) )
    }

    put(s, j_vreturn() )
end
