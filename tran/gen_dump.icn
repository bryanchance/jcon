global dump_emit_table

procedure dump_emit(label, code)
    dump_emit_table[label] := code
end

procedure dump_invocables(all, L)
    writes("invocable")
    writes(\all & " all")
    every writes(" ", image(!L))
    write()
end

procedure dump_links(L)
    writes("link ")
    every writes(" ", !L)
    write()
end

procedure dump_records(name, fields, coord)
    writes("record ", name, "(")
    every writes(" ", !fields)
    write(")")
end

procedure dump_globals(L)
    writes("global ")
    every writes(" ", !L)
    write()
end

procedure dump_function(name, params, accumulate, locals, statics, code,
                        codestart, coord)
    local i

    writes("procedure ", name, "(")
    every writes(" ", !params)
    writes(\accumulate & "[]")
    writes(" )")
    write()
    writes("local")
    every writes(" ", !locals)
    write()
    writes("static")
    every writes(" ", !statics)
    write()
    dump_emit_table := table()
    every i := !code do {
        dump_emit_table[i.label] := i.insnList
    }
    dump_emit_table := optim_optimize(dump_emit_table, codestart)
    dump_table(&output, dump_emit_table)
    write("end ", name)
end

procedure dump_table(p, t)
    local lab, c

    every lab := key(t) & c := t[lab] do {
        write(p, ir_dump(lab))
        every write(p, "\t", ir_dump(!c))
    }
end

procedure dump_File(irgen, flagList)
    local p

    if match("-O", !flagList) then {
        optim_optimize_flag := 1
    }
    while p := @irgen do {
        case type(p) of {
        "ir_Global" : {
            dump_globals(p.nameList)
        }
        "ir_Record" : {
            dump_records(p.name, p.fieldList)
        }
        "ir_Invocable" : {
            dump_invocables(p.all, p.nameList)
        }
        "ir_Function" : {
            dump_function(p.name, p.paramList, p.accumulate, p.localList,
                        p.staticList, p.codeList, p.codeStart)
        }
        "ir_Link" : {
            dump_links(p.nameList)
        }
        default: runerr(500, p)
        }
    }
end
