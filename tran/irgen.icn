#  irgen.icn -- translate abstract syntax trees to intermediate representation.

global ir_noerror2failure
global ir_createflag

record ir_info(start, resume, failure, success, x)
record ir_loopinfo(scanlevel, nextlabel, continue, in_st, out_st, value,
                   bounded, inuse)
record ir_scaninfo(oldsubject, oldpos)
record ir_stacks(tmp, lab, clo)

global ir_loop_stack, ir_scan_stack

global ir_tmptable, ir_loctable, ir_clotable
global ir_start

# record a_NoOp( )
procedure ir_a_NoOp(p, st, inuse, target, bounded)
    ir_init(p)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.ir.success) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
end

# record a_Field( expr field )
procedure ir_a_Field(p, st, inuse, target, bounded)
    local t
    ir_init(p)
    t := ir_value(p, st, inuse, target)
    suspend ir(p.expr, st, inuse, t, &null)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.expr.ir.resume) ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Coord(p.coord),
        ir_Field(target, t, p.field.id, p.expr.ir.resume),
        ir_Goto(p.ir.success)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])
end

# record a_Scan( op expr body )       op == "?" or "?:="
procedure ir_a_Scan(p, st, inuse, target, bounded)
    local lv, rv

    ir_init(p)
    lv := ir_tmp(st, inuse)
    if p.op == "?" then {
        rv := target
    } else {
        rv := (\target | ir_tmp(st, inuse))
    }

    p.ir.x := ir_scaninfo()
    p.ir.x.oldpos := ir_tmp(st, inuse)
    p.ir.x.oldsubject := ir_tmp(st, inuse)

    suspend ir(p.expr, st, inuse, lv, &null)
    put(ir_scan_stack, p)
    suspend ir(p.body, st, inuse, rv, if p.op == "?" then bounded else &null)
    pull(ir_scan_stack)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [
        ir_ScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
        ir_Goto(p.body.ir.resume)
        ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Coord(p.coord),
        ir_Move(p.ir.x.oldsubject, ir_Deref(ir_Key("subject"))),
        ir_Move(p.ir.x.oldpos, ir_Deref(ir_Key("pos"))),
        ir_opfn(target, ir_Operator(":?", 2), [ ir_Key("subject"), lv ],
                p.expr.ir.resume),
        ir_Goto(p.body.ir.start)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.body.ir.failure, [
        ir_Move(ir_Key("subject"), p.ir.x.oldsubject),
        ir_Move(ir_Key("pos"), p.ir.x.oldpos),
        ir_Goto(p.expr.ir.resume)
        ])

    if p.op == "?" then {
        suspend ir_Chunk(p.body.ir.success, [
            ir_ScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
            ir_Goto(p.ir.success)
            ])
    } else {
        # p.op == "?:="
        suspend ir_Chunk(p.body.ir.success, [
            ir_opfn(target, ir_Operator(":=", 2), [ lv, rv ], p.body.ir.resume),
            ir_ScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
            ir_Goto(p.ir.success)
            ])
    }
end

# record a_Limitation( expr limit )
procedure ir_a_Limitation(p, st, inuse, target, bounded)
    local c, t

    ir_init(p)
    c := ir_tmp(st, inuse)
    t := ir_tmp(st, inuse)

    suspend ir(p.limit, st, inuse, t, &null)
    suspend ir(p.expr, st, inuse, target, bounded)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.limit.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [
        ir_opfn(c, ir_Operator(">", 2), [ t, c ], p.limit.ir.resume),
        ir_opfn(c, ir_Operator("+", 2), [ c, ir_IntLit(1) ], p.expr.ir.resume),
        ir_Goto(p.expr.ir.resume)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.limit.ir.resume) ])
    suspend ir_Chunk(p.limit.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.expr.ir.success, [ ir_Goto(p.ir.success) ])
    suspend ir_Chunk(p.limit.ir.success, [
        ir_Coord(p.coord),
        ir_opfn(t, ir_Operator("#", 1), [ t ], p.limit.ir.resume),
        ir_Move(c, ir_IntLit(1)),
        ir_Goto(p.expr.ir.start)
        ])
end

# record a_Not( expr )
procedure ir_a_Not(p, st, inuse, target, bounded)
    local tiu

    ir_init(p)

    tiu := ir_new_inuse()
    suspend ir(p.expr, copy(st), tiu, &null, "always bounded")

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Free(tiu),
        ir_Goto(p.ir.failure)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [
        ir_Move(target, ir_Key("null")),
        ir_Goto(p.ir.success)
        ])
end

# record a_CoexpList( exprList )
procedure ir_a_CoexpList(p, st, inuse, target, bounded)
    stop("FATAL ERROR: don't know how to do coexplist")
end

# record a_Alt( eList )
procedure ir_a_Alt(p, st, inuse, target, bounded)
    local t, tmpst, i, tiu, oiu
    
    ir_init(p)
    /bounded & (t := ir_tmploc(st, inuse))

    tiu := []
    every i := 1 to *p.eList do {
        tmpst := copy(st)
        put(tiu, ir_copy_inuse(inuse))
        suspend ir(p.eList[i], tmpst, tiu[i], target, bounded)
        ir_max_st(st, tmpst)
    }
    ir_inter_inuse(inuse, tiu)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.eList[1].ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(t) ])

    every i := 1 to *p.eList do {
	if /bounded then {
            suspend ir_Chunk(p.eList[i].ir.success, [
                ir_Move(t, p.eList[i].ir.resume),
                ir_Goto(p.ir.success)
                ])
	} else {
            suspend ir_Chunk(p.eList[i].ir.success, [
                ir_Goto(p.ir.success)
                ])
	}
        suspend ir_Chunk(p.eList[i].ir.failure,[ir_Goto(p.eList[i+1].ir.start)])
    }
    suspend ir_Chunk(p.eList[-1].ir.failure, [ ir_Goto(p.ir.failure)])
end

# record a_RepAlt( expr )
procedure ir_a_RepAlt(p, st, inuse, target, bounded)
    local t

    ir_init(p)
    /bounded & (t := ir_tmploc(st, inuse))
    suspend ir(p.expr, st, inuse, target, bounded)

    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.expr.ir.resume) ])
    if /bounded then {
        suspend ir_Chunk(p.ir.start, [
            ir_Move(t, p.ir.failure),
            ir_Goto(p.expr.ir.start)
            ])
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Move(t, p.ir.start),
            ir_Goto(p.ir.success)
            ])
        suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(t) ])
    } else {
        suspend ir_Chunk(p.ir.start, [
            ir_Goto(p.expr.ir.start)
            ])
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Goto(p.ir.success)
            ])
        suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])
    }
end

# record a_Case( expr clauseList dflt )
procedure ir_a_Case(p, st, inuse, target, bounded)
    local t, L, i, tmp1, tmp2, e, v, x, eiu, ciu, tiu
    local oiu

    /p.dflt := a_Key("fail")

    ir_init(p)
    /bounded & (t := ir_tmploc(st, inuse))
    e := ir_tmp(st, inuse)
    v := (\target | ir_tmp(st, inuse))

    eiu := ir_new_inuse()
    suspend ir(p.expr, st, eiu, e, "always bounded")

    tmp2 := copy(st)
    ciu := []
    tiu := []
    every i := 1 to *p.clauseList do {
        put(ciu, ir_new_inuse())
        suspend ir(p.clauseList[i].expr, copy(st), ciu[i], v, &null)
        tmp1 := copy(st)
        put(tiu, ir_copy_inuse(inuse))
        suspend ir(p.clauseList[i].body, tmp1, tiu[i], target, bounded)
        ir_max_st(tmp2, tmp1)
    }
    put(tiu, ir_copy_inuse(inuse))
    suspend ir(p.dflt, st, tiu[-1], target, bounded)
    ir_max_st(st, tmp2)
    ir_union_inuse(inuse, tiu)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(t) ])

    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])

    L := p.clauseList
    if *L = 0 then {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Free(eiu),
            ir_Goto(p.dflt.ir.start)
            ])
    } else {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Free(eiu),
            ir_Goto(L[1].expr.ir.start)
            ])
        every i := 1 to *L do {
            suspend ir_Chunk(L[i].expr.ir.success, [
                ir_Coord(p.coord),
                ir_opfn(&null, ir_Operator("===", 2), [ e, v ],
                        L[i].expr.ir.resume),
                ir_Free(ciu[i]),
                ir_Goto(L[i].body.ir.start)
                ])
            suspend ir_Chunk(L[i].expr.ir.failure,
        		     [ ir_Goto(L[i+1].expr.ir.start) ])
	    if /bounded then {
                suspend ir_Chunk(L[i].body.ir.success, [
                    ir_Move(t, L[i].body.ir.resume),
                    ir_Goto(p.ir.success)
                    ])
	    } else {
                suspend ir_Chunk(L[i].body.ir.success, [
                    ir_Goto(p.ir.success)
                    ])
	    }
            suspend ir_Chunk(L[i].body.ir.failure, [ ir_Goto(p.ir.failure) ])
        }
        suspend ir_Chunk(L[-1].expr.ir.failure, [ ir_Goto(p.dflt.ir.start) ])
    }

    if /bounded then {
        suspend ir_Chunk(p.dflt.ir.success, [
            ir_Move(t, p.dflt.ir.resume),
            ir_Goto(p.ir.success)
            ])
    } else {
        suspend ir_Chunk(p.dflt.ir.success, [
            ir_Goto(p.ir.success)
            ])
    }
    suspend ir_Chunk(p.dflt.ir.failure, [ ir_Goto(p.ir.failure) ])
end

# record a_Every( expr body )
procedure ir_a_Every(p, st, inuse, target, bounded)
    local tmp, tiu

    /p.body := a_Key("fail")

    ir_init_loop(p, st, inuse, target, bounded)
    put(ir_loop_stack, p)
    tmp := copy(st)
    suspend ir(p.expr, tmp, ir_new_inuse(), &null, &null)
    tiu := ir_new_inuse()
    suspend ir(p.body, tmp, tiu, &null, "always bounded")
    pull(ir_loop_stack)

    suspend ir_Chunk(p.ir.x.nextlabel, [ ir_Goto(p.expr.ir.resume) ])
    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.x.continue) ])
    suspend ir_Chunk(p.expr.ir.success, [ ir_Goto(p.body.ir.start) ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.body.ir.success, [
        ir_Free(tiu),
        ir_Goto(p.expr.ir.resume)
        ])
    suspend ir_Chunk(p.body.ir.failure, [ ir_Goto(p.expr.ir.resume) ])
end

# record a_Sectionop( op val left right )
procedure ir_a_Sectionop(p, st, inuse, target, bounded)
    local vv, lv, rv

    ir_init(p)
    vv := ir_value(p.val, st, inuse, &null)
    lv := ir_value(p.left, st, inuse, &null)
    rv := ir_value(p.right, st, inuse, target)

    suspend ir(p.val, st, inuse, vv, &null)
    suspend ir(p.left, st, inuse, lv, &null)
    suspend ir(p.right, st, inuse, rv, &null)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.val.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.right.ir.resume) ])
    suspend ir_Chunk(p.val.ir.success, [ ir_Goto(p.left.ir.start) ])
    suspend ir_Chunk(p.val.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.left.ir.success, [ ir_Goto(p.right.ir.start) ])
    suspend ir_Chunk(p.left.ir.failure, [ ir_Goto(p.val.ir.resume) ])
    suspend ir_Chunk(p.right.ir.success, [
        ir_Coord(p.coord),
        ir_opfn(target, ir_Operator(p.op, 3), [ vv, lv, rv], p.right.ir.resume),
        ir_Goto(p.ir.success)
        ])
    suspend ir_Chunk(p.right.ir.failure, [ ir_Goto(p.left.ir.resume) ])
end

# record a_Call( fn args )
procedure ir_a_Call(p, st, inuse, target, bounded)
    local closure, L, i, fn, args

    every /(!p.args.exprList) := a_Key("null")
    if type(p.args) == "a_CoexpList" then {
        L := []
        every put(L, a_Create(!p.args.exprList))
        p.args := a_Arglist([a_ListConstructor(L)])
    }

    ir_init(p)
    closure := ir_tmp_closure(st, inuse)
    fn := ir_tmp(st, inuse)
    args := []
    every i := !p.args.exprList do put(args, ir_value(i, st, inuse, &null))

    suspend ir(p.fn, st, inuse, fn, &null)
    every i := 1 to *p.args.exprList do {
        suspend ir(p.args.exprList[i], st, inuse, args[i], &null)
    }

    L := [p.fn] ||| p.args.exprList

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.fn.ir.start) ])
    suspend ir_Chunk(p.ir.resume, [
        ir_Coord(p.coord),
        ir_Resume(closure, L[-1].ir.resume, target),
        ir_Goto(p.ir.success)
        ])
    every i := 1 to *L do {
        suspend ir_Chunk(L[i].ir.success, [ ir_Goto(L[i+1].ir.start) ])
        suspend ir_Chunk(L[i].ir.failure, [ ir_Goto(L[i-1].ir.resume) ])
    }
    suspend ir_Chunk(L[ 1].ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(L[-1].ir.success, [
        ir_Coord(p.coord),
        ir_MakeClosure(closure, fn, args),
        ir_Goto(p.ir.resume)
        ])
end

procedure ir_conjunction(p, st, inuse, target, bounded)
    ir_init(p)
    suspend ir(p.left, st, inuse, &null, &null)
    suspend ir(p.right, st, inuse, target, bounded)
    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.left.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.right.ir.resume) ])
    suspend ir_Chunk(p.left.ir.success, [ ir_Goto(p.right.ir.start) ])
    suspend ir_Chunk(p.left.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.right.ir.success, [ ir_Goto(p.ir.success) ])
    suspend ir_Chunk(p.right.ir.failure, [ ir_Goto(p.left.ir.resume) ])
end

procedure ir_augmented_assignment(p, target, bounded, lv, rv, tmp)
    local op

    op := (p.op ? tab(find(":=")))
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.right.ir.resume) ])
    suspend ir_Chunk(p.right.ir.success, [
        ir_Coord(p.coord),
        ir_opfn(tmp, ir_Operator(op, 2), [ lv, rv ], p.right.ir.resume),
        ir_opfn(target, ir_Operator(":=", 2), [ lv, tmp ],
                p.right.ir.resume),
        ir_Goto(p.ir.success)
        ])
end

procedure ir_binary(p, target, bounded, lv, rv, closure, funcs)
    if member(funcs, p.op) then {
        /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.right.ir.resume) ])
        suspend ir_Chunk(p.right.ir.success, [
            ir_Coord(p.coord),
            ir_opfn(target, ir_Operator(p.op, 2), [ lv, rv ],
                    p.right.ir.resume),
            ir_Goto(p.ir.success)
            ])
    } else {
        suspend ir_Chunk(p.ir.resume, [
            ir_Coord(p.coord),
            ir_Resume(closure, p.right.ir.resume, target),
            ir_Goto(p.ir.success)
            ])
        suspend ir_Chunk(p.right.ir.success, [
            ir_Coord(p.coord),
            ir_MakeClosure(closure, ir_Operator(p.op, 2), [ lv, rv ]),
            ir_Goto(p.ir.resume)
            ])
    }
end

# record a_Binop( op left right )
procedure ir_a_Binop(p, st, inuse, target, bounded)
    local closure, tmp, op, lv, rv
    static funcs    # functions for which resumption fails immediately.
    initial {
        funcs := set([ ":=", ":=:", "&", ".", "[]", "+", "-", "/",
            "*", "%", "^", "**", "++", "--", "<", "<=", "=", "~=",
            ">=", ">", "<<", "<<=", "==", "~==", ">>=", ">=", ">>",
            "===", "~===", "|||", "||", "@" ])
    }

    /p.right := a_Key("null")

    if p.op == "&" then {
        suspend ir_conjunction(p, st, inuse, target, bounded)
        fail
    }

    ir_init(p)
    if not member(funcs, p.op) &
       not member(funcs, p.op[1:find(":=", p.op)]) then {
        closure := ir_tmp_closure(st, inuse)
    }
    lv := ir_value(p.left, st, inuse, &null)
    rv := ir_value(p.right, st, inuse, target)
    tmp := (\target | ir_tmp(st, inuse))

    suspend ir(p.left, st, inuse, lv, &null)
    suspend ir(p.right, st, inuse, rv, &null)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.left.ir.start) ])
    suspend ir_Chunk(p.left.ir.success, [ ir_Goto(p.right.ir.start) ])
    suspend ir_Chunk(p.left.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.right.ir.failure, [ ir_Goto(p.left.ir.resume) ])

    if find(":=", p.op) > 1 then {
        suspend ir_augmented_assignment(p, target, bounded, lv, rv, tmp)
    } else {
        suspend ir_binary(p, target, bounded, lv, rv, closure, funcs)
    }
end

procedure ir_unary_coexp(p, st, inuse, target, bounded)
    local t

    t := a_Binop("@", a_Key("null"), p.operand, p.coord)
    suspend ir(t, st, inuse, target, bounded)
    p.ir := t.ir
end

procedure ir_unary(p, target, bounded, v, closure, funcs)
    if member(funcs, p.op) then {
        /bounded & suspend ir_Chunk(p.ir.resume, [ir_Goto(p.operand.ir.resume)])
        suspend ir_Chunk(p.operand.ir.success, [
            ir_Coord(p.coord),
            ir_opfn(target, ir_Operator(p.op, 1), [ v ], p.operand.ir.resume),
            ir_Goto(p.ir.success)
            ])
    } else {
        suspend ir_Chunk(p.ir.resume, [
            ir_Coord(p.coord),
            ir_Resume(closure, p.operand.ir.resume, target),
            ir_Goto(p.ir.success)
            ])
        suspend ir_Chunk(p.operand.ir.success, [
            ir_Coord(p.coord),
            ir_MakeClosure(closure, ir_Operator(p.op,1), [ v ]),
            ir_Goto(p.ir.resume)
            ])
    }
end

# record a_Unop( op operand )
procedure ir_a_Unop(p, st, inuse, target, bounded)
    local closure, v, t
    static funcs    # functions for which resumption fails immediately.
    initial {
        funcs := set([ ".", "/", "\\", "*", "?", "+", "-", "~", "^" ])
    }

    if p.op == "@" then {
        suspend ir_unary_coexp(p, st, inuse, target, bounded)
        fail
    }

    ir_init(p)
    if not member(funcs, p.op) then {
        closure := ir_tmp_closure(st, inuse)
    }
    v := ir_value(p.operand, st, inuse, target)

    suspend ir(p.operand, st, inuse, v, &null)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.operand.ir.start) ])
    suspend ir_unary(p, target, bounded, v, closure, funcs)
    suspend ir_Chunk(p.operand.ir.failure, [ ir_Goto(p.ir.failure) ])
end

# record a_Global( idList )
procedure ir_a_Global(p, st, inuse, target, bounded)
    local globals

    globals := []
    every put(globals, (!p.idList).id)
    return ir_Global(globals)
end

# record a_If( expr thenexpr elseexpr )
procedure ir_a_If(p, st, inuse, target, bounded)
    local t, tmp, tiu, xiu, yiu

    /p.elseexpr := a_Key("fail")

    ir_init(p)
    /bounded & (t := ir_tmploc(st, inuse))

    tiu := ir_new_inuse()
    suspend ir(p.expr, copy(st), tiu, &null, "always bounded")
    tmp := copy(st)
    xiu := ir_copy_inuse(inuse)
    yiu := ir_copy_inuse(inuse)
    suspend ir(p.thenexpr, tmp, xiu, target, bounded)
    suspend ir(p.elseexpr, st, yiu, target, bounded)
    ir_max_st(st, tmp)
    ir_union_inuse(inuse, [xiu,yiu])

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(t) ])
    if /bounded then {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Free(tiu),
            ir_Move(t, p.thenexpr.ir.resume),
            ir_Goto(p.thenexpr.ir.start)
            ])
        suspend ir_Chunk(p.expr.ir.failure, [
            ir_Move(t, p.elseexpr.ir.resume),
            ir_Goto(p.elseexpr.ir.start)
            ])
    } else {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Free(tiu),
            ir_Goto(p.thenexpr.ir.start)
            ])
        suspend ir_Chunk(p.expr.ir.failure, [
            ir_Goto(p.elseexpr.ir.start)
            ])
    }
    suspend ir_Chunk(p.thenexpr.ir.success, [ ir_Goto(p.ir.success) ])
    suspend ir_Chunk(p.thenexpr.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.elseexpr.ir.success, [ ir_Goto(p.ir.success) ])
    suspend ir_Chunk(p.elseexpr.ir.failure, [ ir_Goto(p.ir.failure) ])
end

# record a_Initial( expr )
procedure ir_a_Initial(p, st, inuse, target, bounded)
    local tiu

    /p.expr := a_NoOp()

    ir_loop_stack := []
    ir_scan_stack := []

    ir_init(p)
    tiu := ir_new_inuse()
    suspend ir(p.expr, st, tiu, target, "always bounded")

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_RunTimeError() ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Free(tiu),
        ir_Goto(p.ir.success)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.success) ])
end

# record a_Invocable( invocList )
procedure ir_a_Invocable(p, st, inuse, target, bounded)
    local all, inv, i

    inv := []
    every i := !p.invocList do {
        case type(i) of {
        "a_Ident" : {
            if i.id == "all" then {
                all := 1
            }
            }
        "a_Stringlit" : {
            put(inv, i.str)
            }
        }
    }
    return ir_Invocable(inv, all)
end

# record a_Link( linkfileList )
procedure ir_a_Link(p, st, inuse, target, bounded)
    return ir_Link(p.linkfileList)
end

procedure ir_value0(p)
    local x
    static functions
    initial {
        functions := key_functions()
    }


    case type(p) of {
    "a_Intlit" : return ir_IntLit(p.int)
    "a_Reallit" : return ir_RealLit(p.real)
    "a_Stringlit": return ir_StrLit(p.str)
    "a_Csetlit" : return ir_CsetLit(p.str)
    "a_Key" : {
        if not member(functions, p.id) then {
            return ir_key0(p)
        }
    }
    "a_KeyX" : return ir_key0(p)
    "a_Ident" : return ir_ident(p.id)
    }
end

procedure ir_value(p, st, inuse, target)
    return (ir_value0(p) | \target | ir_tmp(st, inuse))
end

# record a_Intlit( int )
procedure ir_a_Intlit(p, st, inuse, target, bounded)

    if type(target) == "ir_IntLit" then target := &null

    ir_init(p)

    if not (p.int := integer(p.int)) then {
        semantic_error(p.int || ": illegal integer literal", p.coord)
    }
    suspend ir_Chunk(p.ir.start, [
        ir_Move(target, ir_IntLit(p.int)),
        ir_Goto(p.ir.success)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
end

# record a_Reallit( real )
procedure ir_a_Reallit(p, st, inuse, target, bounded)

    if type(target) == "ir_RealLit" then target := &null

    ir_init(p)

    if not (p.real := real(p.real)) then {
        semantic_error(p.real || ": illegal real literal", p.coord)
    }
    suspend ir_Chunk(p.ir.start, [
        ir_Move(target, ir_RealLit(p.real)),
        ir_Goto(p.ir.success)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
end

# record a_Stringlit( str )
procedure ir_a_Stringlit(p, st, inuse, target, bounded)

    if type(target) == "ir_StrLit" then target := &null

    ir_init(p)

    suspend ir_Chunk(p.ir.start, [
        ir_Move(target, ir_StrLit(p.str)),
        ir_Goto(p.ir.success)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
end

# record a_Csetlit( str )
procedure ir_a_Csetlit(p, st, inuse, target, bounded)

    if type(target) == "ir_CsetLit" then target := &null

    ir_init(p)

    suspend ir_Chunk(p.ir.start, [
        ir_Move(target, ir_CsetLit(p.str)),
        ir_Goto(p.ir.success)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
end

# record a_ProcDecl( ident paramList accumulate localsList code )
procedure ir_a_ProcDecl(p, st, inuse, target, bounded)
    local locals, statics, params, i, v, code

    v := set([])
    every i := !p.paramList | !(!p.localsList).idList do {
        if member(v, i.id) then {
            semantic_error(image(i.id) || ": redeclared identifier", i.coord)
        }
        insert(v, i.id)
    }

    locals := []
    statics := []
    every i := !p.localsList do {
        case type(i) of {
        "a_Statics" : every put(statics, (!i.idList).id)
        "a_Locals" : every put(locals, (!i.idList).id)
        }
    }
    params := []
    every put(params, (!p.paramList).id)

    ir_tmptable := table()
    ir_loctable := table()
    ir_clotable := table()

    code := []
    every put(code, ir(p.code))

    return ir_Function(p.ident.id, params, p.accumulate, locals, statics, code,
                      ir_start, p.ident.coord)
end

# record a_ProcBody( nexprList )
procedure ir_a_ProcBody(p, st, inuse, target, bounded)
    local L, i, tiu

    every /(!p.nexprList) := a_Key("null")

    ir_loop_stack := []
    ir_scan_stack := []

    ir_init(p)

    L := ir_make_sentinel(p.nexprList)
    tiu := []
    every i := 1 to *p.nexprList do {
        put(tiu, ir_new_inuse())
        suspend ir(p.nexprList[i], ir_stacks(0,0,0), tiu[i], &null,
                 "always bounded")
    }

    suspend ir_Chunk(p.ir.start, [ ir_Goto(L[1].ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_RunTimeError() ])
    every i := 1 to *L-1 do {
        suspend ir_Chunk(L[i].ir.success, [
            ir_Free(tiu[i]),
            ir_Goto(L[i+1].ir.start)
            ])
        suspend ir_Chunk(L[i].ir.failure, [ ir_Goto(L[i+1].ir.start) ])
    }
    suspend ir_Chunk(L[-1].ir.success, [
        ir_Free(tiu[-1]),
        ir_Goto(p.ir.success)
        ])
    suspend ir_Chunk(L[-1].ir.failure, [ ir_Goto(p.ir.failure) ])
end

# record a_ProcCode( init body )
procedure ir_a_ProcCode(p, st, inuse, target, bounded)
    ir_init(p)

    suspend ir(p.init, ir_stacks(0,0,0), inuse, &null, "always bounded")
    suspend ir(p.body, ir_stacks(0,0,0), inuse, &null, "always bounded")

    ir_start := p.ir.start
    suspend ir_Chunk(p.ir.start, [
        ir_EnterInit(p.body.ir.start),
        ir_Goto(p.init.ir.start)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_RunTimeError() ])
    suspend ir_Chunk(p.init.ir.success, [ ir_Goto(p.body.ir.start) ])
    suspend ir_Chunk(p.init.ir.failure, [ ir_Goto(p.body.ir.start) ])
    suspend ir_Chunk(p.body.ir.success, [ ir_Fail() ])
    suspend ir_Chunk(p.body.ir.failure, [ ir_Fail() ])
end

# record a_Record( ident idlist )
procedure ir_a_Record(p, st, inuse, target, bounded)
    local fields, v, i

    v := set([])
    every i := !p.idlist do {
        if member(v, i.id) then {
            semantic_error(image(i.id) || ": redeclared identifier", i.coord)
        }
        insert(v, i.id)
    }
    fields := []
    every put(fields, (!p.idlist).id)
    return ir_Record(p.ident.id, fields, p.ident.coord)
end

# record a_Repeat( expr )
procedure ir_a_Repeat(p, st, inuse, target, bounded)
    local tiu

    ir_init_loop(p, st, inuse, target, bounded)
    put(ir_loop_stack, p)
    tiu := ir_new_inuse()
    suspend ir(p.expr, copy(st), tiu, &null, "always bounded")
    pull(ir_loop_stack)


    suspend ir_Chunk(p.ir.x.nextlabel, [ ir_Goto(p.expr.ir.start) ])
    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.x.continue) ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Free(tiu),
        ir_Goto(p.ir.start)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.start) ])
end

# record a_Return( expr )
procedure ir_a_Return(p, st, inuse, target, bounded)
    local t, tiu

    /ir_createflag |semantic_error("invalid context for return or fail",p.coord)

    /p.expr := a_Key("null")

    ir_init(p)
    t := ir_tmp(st, inuse)

    tiu := ir_new_inuse()
    suspend ir(p.expr, copy(st), tiu, t, "always bounded")

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Fail() ])
    if ir_scan_stack[1] then {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Move(ir_Key("subject"), ir_scan_stack[1].ir.x.oldsubject),
            ir_Move(ir_Key("pos"), ir_scan_stack[1].ir.x.oldpos),
            ir_Free(tiu),
            ir_Succeed(t, &null)
            ])
        suspend ir_Chunk(p.expr.ir.failure, [
            ir_Move(ir_Key("subject"), ir_scan_stack[1].ir.x.oldsubject),
            ir_Move(ir_Key("pos"), ir_scan_stack[1].ir.x.oldpos),
            ir_Fail()
            ])
    } else {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_Free(tiu),
            ir_Succeed(t, &null)
            ])
        suspend ir_Chunk(p.expr.ir.failure, [ ir_Fail() ])
    }
end

# record a_Fail( )
procedure ir_a_Fail(p, st, inuse, target, bounded)

    /ir_createflag |semantic_error("invalid context for return or fail",p.coord)

    ir_init(p)

    if ir_scan_stack[1] then {
        suspend ir_Chunk(p.ir.start, [
            ir_Move(ir_Key("subject"), ir_scan_stack[1].ir.x.oldsubject),
            ir_Move(ir_Key("pos"), ir_scan_stack[1].ir.x.oldpos),
            ir_Fail()
            ])
        /bounded & suspend ir_Chunk(p.ir.resume, [
            ir_Move(ir_Key("subject"), ir_scan_stack[1].ir.x.oldsubject),
            ir_Move(ir_Key("pos"), ir_scan_stack[1].ir.x.oldpos),
            ir_Fail()
            ])
    } else {
        suspend ir_Chunk(p.ir.start, [ ir_Fail() ])
        /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Fail() ])
    }
end

# record a_Suspend( expr body )
procedure ir_a_Suspend(p, st, inuse, target, bounded)
    local t, tmp, susp, tiu

    /ir_createflag | semantic_error("invalid context for suspend", p.coord)

    /p.body := a_Key("fail") & /p.expr := a_Key("null")

    ir_init_loop(p, st, inuse, target, bounded)
    t := ir_label(p, "suspend")
    susp := ir_tmp(st, inuse)

    put(ir_loop_stack, p)
    tmp := copy(st)
    suspend ir(p.expr, tmp, ir_new_inuse(), susp, &null)
    tiu := ir_new_inuse()
    suspend ir(p.body, tmp, tiu, &null, "always bounded")
    pull(ir_loop_stack)

    suspend ir_Chunk(p.ir.x.nextlabel, [ ir_Goto(p.expr.ir.resume) ])
    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.x.continue) ])
    if ir_scan_stack[1] then {
        suspend ir_Chunk(p.expr.ir.success, [
            ir_ScanSwap( ir_scan_stack[1].ir.x.oldsubject,
        		 ir_scan_stack[1].ir.x.oldpos ),
            ir_Succeed(susp, t)
            ])
        suspend ir_Chunk(t, [
            ir_Restore(),
            ir_ScanSwap( ir_scan_stack[1].ir.x.oldsubject,
        		 ir_scan_stack[1].ir.x.oldpos ),
            ir_Goto(p.body.ir.start)
            ])
    } else {
        suspend ir_Chunk(p.expr.ir.success, [ ir_Succeed(susp, t) ])
        suspend ir_Chunk(t, [
            ir_Restore(),
            ir_Goto(p.body.ir.start)
            ])
    }
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.body.ir.success, [
        ir_Free(tiu),
        ir_Goto(p.expr.ir.resume)
        ])
    suspend ir_Chunk(p.body.ir.failure, [ ir_Goto(p.expr.ir.resume) ])
end

# record a_Until( expr body )
procedure ir_a_Until(p, st, inuse, target, bounded)
    local eiu, biu

    /p.body := a_Key("fail")

    ir_init_loop(p, st, inuse, target, bounded)
    put(ir_loop_stack, p)
    eiu := ir_new_inuse()
    suspend ir(p.expr, copy(st), eiu, &null, "always bounded")
    biu := ir_new_inuse()
    suspend ir(p.body, copy(st), biu, &null, "always bounded")
    pull(ir_loop_stack)

    suspend ir_Chunk(p.ir.x.nextlabel, [ ir_Goto(p.expr.ir.start) ])
    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.x.continue) ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Free(eiu),
        ir_Goto(p.ir.failure)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.body.ir.start) ])
    suspend ir_Chunk(p.body.ir.success, [
        ir_Free(biu),
        ir_Goto(p.expr.ir.start)
        ])
    suspend ir_Chunk(p.body.ir.failure, [ ir_Goto(p.expr.ir.start) ])
end

# record a_While( expr body )
procedure ir_a_While(p, st, inuse, target, bounded)
    local eiu, biu

    /p.body := a_Key("fail")

    ir_init_loop(p, st, inuse, target, bounded)
    put(ir_loop_stack, p)
    eiu := ir_new_inuse()
    suspend ir(p.expr, copy(st), eiu, &null, "always bounded")
    biu := ir_new_inuse()
    suspend ir(p.body, copy(st), biu, &null, "always bounded")
    pull(ir_loop_stack)

    suspend ir_Chunk(p.ir.x.nextlabel, [ ir_Goto(p.expr.ir.start) ])
    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.expr.ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.x.continue) ])
    suspend ir_Chunk(p.expr.ir.success, [
        ir_Free(eiu),
        ir_Goto(p.body.ir.start)
        ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.body.ir.success, [
        ir_Free(biu),
        ir_Goto(p.expr.ir.start)
        ])
    suspend ir_Chunk(p.body.ir.failure, [ ir_Goto(p.expr.ir.start) ])
end

# record a_Create( expr )
procedure ir_a_Create(p, st, inuse, target, bounded)
    local t

    ir_init(p)
    t := (\target | ir_tmp(st, inuse))

    ir_createflag := 1
    suspend ir(p.expr, st, ir_new_inuse(), t, &null)
    ir_createflag := &null

    suspend ir_Chunk(p.ir.start, [
        ir_Coord(p.coord),
        ir_Move(target, ir_Create(p.expr.ir.start)),
        ir_Goto(p.ir.success)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.expr.ir.success, [ ir_CoRet(t, p.expr.ir.resume) ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_CoFail() ])
end

# record a_Ident( id )
procedure ir_a_Ident(p, st, inuse, target, bounded)
    local v

    if type(\target) ~== "ir_Tmp" then {
        # #%#%# prevents nasty interaction with targeting.
        # %#%#% probably a symptom of bad design....
        target := &null
    }

    ir_init(p)

    v := ir_ident(p.id)

    suspend ir_Chunk(p.ir.start, [
        ir_Move(target, v),
        ir_Goto(p.ir.success)
        ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
end

# record a_Next( )
procedure ir_a_Next(p, st, inuse, target, bounded)
    local curloop, sl

    ir_loop_stack[1] | semantic_error("invalid context for next", p.coord)

    ir_init(p)

    curloop := ir_loop_stack[-1]
    sl := curloop.ir.x.scanlevel
    if ir_scan_stack[sl+1] then {
        suspend ir_Chunk(p.ir.start, [
            ir_Move(ir_Key("subject"), ir_scan_stack[sl+1].ir.x.oldsubject),
            ir_Move(ir_Key("pos"), ir_scan_stack[sl+1].ir.x.oldpos),
            ir_Goto(curloop.ir.x.nextlabel)
            ])
    } else {
        suspend ir_Chunk(p.ir.start, [ ir_Goto(curloop.ir.x.nextlabel) ])
    }
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_RunTimeError() ])
end

# record a_Break( expr )
procedure ir_a_Break(p, st, inuse, target, bounded)
    local curloop, oldloops, oldscans, tmp, clx

    ir_loop_stack[1] | semantic_error("invalid context for break", p.coord)

    /p.expr := a_Key("null")

    ir_init(p)

    curloop := ir_loop_stack[-1] 
    oldloops := ir_loop_stack
    oldscans := ir_scan_stack
    ir_loop_stack := ir_loop_stack[1:-1] 
    ir_scan_stack := ir_scan_stack[1:curloop.ir.x.scanlevel] 
    tmp := copy(curloop.ir.x.in_st)
    clx := curloop.ir.x
    suspend ir(p.expr, tmp, clx.inuse, clx.value, clx.bounded)
    ir_max_st(clx.out_st, tmp)
    ir_loop_stack := oldloops
    ir_scan_stack := oldscans

    if ir_scan_stack[clx.scanlevel+1] then {
	if /clx.bounded then {
            suspend ir_Chunk(p.ir.start, [
                ir_Move(ir_Key("subject"),
        	        ir_scan_stack[clx.scanlevel+1].ir.x.oldsubject),
                ir_Move(ir_Key("pos"), ir_scan_stack[clx.scanlevel+1].ir.x.oldpos),
                ir_Move(clx.continue, p.ir.resume),
                ir_Goto(p.expr.ir.start)
                ])
	} else {
            suspend ir_Chunk(p.ir.start, [
                ir_Move(ir_Key("subject"),
        	        ir_scan_stack[clx.scanlevel+1].ir.x.oldsubject),
                ir_Move(ir_Key("pos"), ir_scan_stack[clx.scanlevel+1].ir.x.oldpos),
                ir_Goto(p.expr.ir.start)
                ])
	}
    } else {
	if /clx.bounded then {
            suspend ir_Chunk(p.ir.start, [
                ir_Move(clx.continue, p.ir.resume),
                ir_Goto(p.expr.ir.start)
                ])
	} else {
            suspend ir_Chunk(p.ir.start, [
                ir_Goto(p.expr.ir.start)
                ])
	}
    }
    /clx.bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.expr.ir.resume) ])
    suspend ir_Chunk(p.expr.ir.success, [ ir_Goto(curloop.ir.success) ])
    suspend ir_Chunk(p.expr.ir.failure, [ ir_Goto(curloop.ir.failure) ])
end

# record a_ToBy( fromexpr toexpr byexpr )
procedure ir_a_ToBy(p, st, inuse, target, bounded)
    local closure, fv, tv, bv

    /p.byexpr := a_Intlit(1)

    ir_init(p)
    closure := ir_tmp_closure(st, inuse)
    fv := ir_value(p.fromexpr, st, inuse, &null)
    tv := ir_value(p.toexpr, st, inuse, &null)
    bv := ir_value(p.byexpr, st, inuse, target)

    suspend ir(p.fromexpr, st, inuse, fv, &null)
    suspend ir(p.toexpr, st, inuse, tv, &null)
    suspend ir(p.byexpr, st, inuse, bv, &null)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(p.fromexpr.ir.start) ])
    suspend ir_Chunk(p.ir.resume, [
        ir_Coord(p.coord),
        ir_Resume(closure, p.byexpr.ir.resume, target),
        ir_Goto(p.ir.success)
        ])
    suspend ir_Chunk(p.fromexpr.ir.success, [ ir_Goto(p.toexpr.ir.start) ])
    suspend ir_Chunk(p.fromexpr.ir.failure, [ ir_Goto(p.ir.failure) ])
    suspend ir_Chunk(p.toexpr.ir.success, [ ir_Goto(p.byexpr.ir.start) ])
    suspend ir_Chunk(p.toexpr.ir.failure, [ ir_Goto(p.fromexpr.ir.resume) ])
    suspend ir_Chunk(p.byexpr.ir.success, [
        ir_Coord(p.coord),
        ir_MakeClosure(closure, ir_Operator("...", 3), [ fv, tv, bv ]),
        ir_Goto(p.ir.resume)
        ])
    suspend ir_Chunk(p.byexpr.ir.failure, [ ir_Goto(p.toexpr.ir.resume) ])

end

# record a_Mutual( exprList )
procedure ir_a_Mutual(p, st, inuse, target, bounded)
    local L, i

    if *p.exprList = 0 then {
        p.exprList := [ a_Key("null") ]
    } else {
        every /(!p.exprList) := a_Key("null")
    }

    ir_init(p)

    every i := 1 to *p.exprList-1 do {
        suspend ir(p.exprList[i], st, inuse, &null, &null)
    }
    suspend ir(p.exprList[-1], st, inuse, target, bounded)
    L := p.exprList

    suspend ir_Chunk(p.ir.start, [ ir_Goto(L[1].ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(L[-1].ir.resume) ])

    every i := 1 to *L do {
        suspend ir_Chunk(L[i].ir.success, [ ir_Goto(L[i+1].ir.start) ])
        suspend ir_Chunk(L[i].ir.failure, [ ir_Goto(L[i-1].ir.resume) ])
    }
    suspend ir_Chunk(L[-1].ir.success, [ ir_Goto(p.ir.success) ])
    suspend ir_Chunk(L[ 1].ir.failure, [ ir_Goto(p.ir.failure) ])
end

# record a_Compound( exprList )
procedure ir_a_Compound(p, st, inuse, target, bounded)
    local L, i, tiu

    every /(!p.exprList) := a_Key("null")

    ir_init(p)

    tiu := []
    every i := 1 to *p.exprList-1 do {
        put(tiu, ir_new_inuse())
        suspend ir(p.exprList[i], copy(st), tiu[i], &null, "always bounded")
    }
    suspend ir(p.exprList[-1], st, inuse, target, bounded)

    L := p.exprList
    *L > 0 | stop("fatal error in ir_a_Compound")
    suspend ir_Chunk(p.ir.start, [ ir_Goto(L[1].ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(L[-1].ir.resume) ])

    every i := 1 to *p.exprList-1 do {
        suspend ir_Chunk(L[i].ir.success, [
            ir_Free(tiu[i]),
            ir_Goto(L[i+1].ir.start)
            ])
        suspend ir_Chunk(L[i].ir.failure, [ ir_Goto(L[i+1].ir.start) ])
    }
    suspend ir_Chunk(L[-1].ir.success, [ ir_Goto(p.ir.success) ])
    suspend ir_Chunk(L[-1].ir.failure, [ ir_Goto(p.ir.failure) ])

end


procedure ir_key0(p)
    case (p.id) of {
    "fail" : fail
    "line" : { return ir_IntLit(p.coord.line) }
    "file" : { return ir_StrLit(p.coord.file) }
    default: { return ir_key(p.id) }
    }
end

record a_KeyX(id, coord, ir)
procedure ir_a_KeyX(p, st, inuse, target, bounded)
    local k
    
    if type(\target) ~== "ir_Tmp" then {
        # #%#%# prevents nasty interaction with targeting.
        # %#%#% probably a symptom of bad design....
        target := &null
    }

    ir_init(p)

    case (p.id) of {
    "fail" : {
        suspend ir_Chunk(p.ir.start, [ ir_Goto(p.ir.failure) ])
        /bounded & suspend ir_Chunk(p.ir.resume, [ ir_RunTimeError() ])
        }
    default: {
        k := ir_key0(p)
        suspend ir_Chunk(p.ir.start, [
            ir_Move(target, k),
            ir_Goto(p.ir.success)
            ])
        /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(p.ir.failure) ])
        }
    }
end

# record a_Key( id )
procedure ir_a_Key(p, st, inuse, target, bounded)
    local t
    static functions
    initial {
        functions := key_functions()
    }
    if member(functions, p.id) then {
        t := a_Call(a_KeyX(p.id), a_Arglist([]))
        suspend ir(t, st, inuse, target, bounded)
        p.ir := t.ir
        fail
    }
    suspend ir_a_KeyX(p, st, inuse, target, bounded)
end

# record a_Arglist( exprList )
procedure ir_a_Arglist(p, st, inuse, target, bounded)
    stop("FATAL ERROR: a_Arglist should be handled in ir_a_Call(), file ",
         image(&file), ", line ", image(&line))
end

# record a_ListConstructor( exprList )
procedure ir_a_ListConstructor(p, st, inuse, target, bounded)
    local L, i, args

    every /(!p.exprList) := a_Key("null")

    ir_init(p)

    args := []
    if \target then {
        every i := !p.exprList do put(args, ir_value(i, st, inuse, &null))
    } else {
        every !p.exprList do put(args, &null)
    }

    every i := 1 to *p.exprList do {
        suspend ir(p.exprList[i], st, inuse, args[i], &null)
    }

    L := ir_make_sentinel(p.exprList)

    suspend ir_Chunk(p.ir.start, [ ir_Goto(L[1].ir.start) ])
    /bounded & suspend ir_Chunk(p.ir.resume, [ ir_Goto(L[-1].ir.resume) ])

    suspend ir_Chunk(L[1].ir.start, [ ir_Goto(L[2].ir.start) ])
    suspend ir_Chunk(L[1].ir.resume, [ ir_Goto(p.ir.failure) ])
    every i := 2 to *p.exprList-1 do {
        suspend ir_Chunk(L[i].ir.success, [ ir_Goto(L[i+1].ir.start) ])
        suspend ir_Chunk(L[i].ir.failure, [ ir_Goto(L[i-1].ir.resume) ])
    }
    if \target then {
        suspend ir_Chunk(L[-1].ir.start, [
            ir_Coord(p.coord),
            ir_MakeList(target, args),
            ir_Goto(p.ir.success)
            ])
    } else {
        suspend ir_Chunk(L[-1].ir.start, [ ir_Goto(p.ir.success) ])
    }
    suspend ir_Chunk(L[-1].ir.resume, [ ir_Goto(L[-2].ir.resume) ])

end

procedure ir(p, st, inuse, target, bounded)
    case type(p) of {
    "a_KeyX" : suspend ir_a_KeyX(p, st, inuse, target, bounded)
    "a_NoOp" : suspend ir_a_NoOp(p, st, inuse, target, bounded)
    "a_Field" : suspend ir_a_Field(p, st, inuse, target, bounded)
    "a_Call" : suspend ir_a_Call(p, st, inuse, target, bounded)
    "a_Scan" : suspend ir_a_Scan(p, st, inuse, target, bounded)
    "a_Limitation" : suspend ir_a_Limitation(p, st, inuse, target, bounded)
    "a_Not" : suspend ir_a_Not(p, st, inuse, target, bounded)
    "a_CoexpList" : suspend ir_a_CoexpList(p, st, inuse, target, bounded)
    "a_Alt" : suspend ir_a_Alt(p, st, inuse, target, bounded)
    "a_RepAlt" : suspend ir_a_RepAlt(p, st, inuse, target, bounded)
    "a_Case" : suspend ir_a_Case(p, st, inuse, target, bounded)
    "a_Every" : suspend ir_a_Every(p, st, inuse, target, bounded)
    "a_Sectionop" : suspend ir_a_Sectionop(p, st, inuse, target, bounded)
    "a_Binop" : suspend ir_a_Binop(p, st, inuse, target, bounded)
    "a_Unop" : suspend ir_a_Unop(p, st, inuse, target, bounded)
    "a_Global" : suspend ir_a_Global(p, st, inuse, target, bounded)
    "a_If" : suspend ir_a_If(p, st, inuse, target, bounded)
    "a_Initial" : suspend ir_a_Initial(p, st, inuse, target, bounded)
    "a_Invocable" : suspend ir_a_Invocable(p, st, inuse, target, bounded)
    "a_Link" : suspend ir_a_Link(p, st, inuse, target, bounded)
    "a_Intlit" : suspend ir_a_Intlit(p, st, inuse, target, bounded)
    "a_Reallit" : suspend ir_a_Reallit(p, st, inuse, target, bounded)
    "a_Stringlit" : suspend ir_a_Stringlit(p, st, inuse, target, bounded)
    "a_Csetlit" : suspend ir_a_Csetlit(p, st, inuse, target, bounded)
    "a_ProcDecl" : suspend ir_a_ProcDecl(p, st, inuse, target, bounded)
    "a_ProcBody" : suspend ir_a_ProcBody(p, st, inuse, target, bounded)
    "a_ProcCode" : suspend ir_a_ProcCode(p, st, inuse, target, bounded)
    "a_Record" : suspend ir_a_Record(p, st, inuse, target, bounded)
    "a_Repeat" : suspend ir_a_Repeat(p, st, inuse, target, bounded)
    "a_Return" : suspend ir_a_Return(p, st, inuse, target, bounded)
    "a_Fail" : suspend ir_a_Fail(p, st, inuse, target, bounded)
    "a_Suspend" : suspend ir_a_Suspend(p, st, inuse, target, bounded)
    "a_Until" : suspend ir_a_Until(p, st, inuse, target, bounded)
    "a_While" : suspend ir_a_While(p, st, inuse, target, bounded)
    "a_Create" : suspend ir_a_Create(p, st, inuse, target, bounded)
    "a_Ident" : suspend ir_a_Ident(p, st, inuse, target, bounded)
    "a_Next" : suspend ir_a_Next(p, st, inuse, target, bounded)
    "a_Break" : suspend ir_a_Break(p, st, inuse, target, bounded)
    "a_ToBy" : suspend ir_a_ToBy(p, st, inuse, target, bounded)
    "a_Mutual" : suspend ir_a_Mutual(p, st, inuse, target, bounded)
    "a_Compound" : suspend ir_a_Compound(p, st, inuse, target, bounded)
    "a_ListConstructor" : suspend ir_a_ListConstructor(p, st, inuse, target,
                                                   bounded)
    "a_Key" : suspend ir_a_Key(p, st, inuse, target, bounded)
    "a_Arglist" : suspend ir_a_Arglist(p, st, inuse, target, bounded)
    default : runerr(500, p)
    }
end

procedure ir_opfn(lhs, op, args, failLabel)
    static neverfail
    initial {
        neverfail := list(3)
        neverfail[1] := set([ "#", "+", "-", "~", "^", "*", "." ])
        neverfail[2] := set([
            "+", "-", "*", "/", "%", "^", 
            "++", "--", "**", 
            "||", "|||",
            ".", "&"
            # ":=", ":=:" omited because &pos:=*&subject+2 fails
        ])
        neverfail[3] := set([ ])
    }
    if \ir_noerror2failure & member(neverfail[op.arity],op.name) then {
        failLabel := &null
    }
    return ir_OpFunction(lhs, op, args, failLabel)
end

procedure ir_init(p)
    p.ir := ir_info()
    p.ir.start := ir_label(p, "start")
    p.ir.resume := ir_label(p, "resume")
    p.ir.success := ir_label(p, "success")
    p.ir.failure := ir_label(p, "failure")
    return p
end

procedure ir_init_loop(p, st, inuse, target, bounded)
    ir_init(p)
    p.ir.x := ir_loopinfo()
    /bounded & (p.ir.x.continue := ir_tmploc(st, inuse))
    p.ir.x.nextlabel := ir_label(p, "next")
    p.ir.x.scanlevel := *ir_scan_stack
    p.ir.x.in_st := copy(st)
    p.ir.x.out_st := st
    p.ir.x.value := target
    p.ir.x.bounded := bounded
    p.ir.x.inuse := inuse
    return p
end

procedure ir_label(p, suffix)
    return ir_Label(ir_naming(p, suffix))
end

procedure ir_naming(p, suffix)
    local s

    image(p) ? {
        tab(upto(' '))
        move(1)
        s := tab(upto('('))
    }
    return s || "_" || suffix
end

procedure ir_dump(insn)
    return dump_simple(insn, set(["x"]))
end

procedure ir_ident(str)
    return ir_Var(str)
end

procedure ir_key(str)
    local k

    static keytable
    initial {
        keytable := table()
    }
    k := /keytable[str] := ir_Key(str)
    return \k | keytable[str]
end

procedure ir_tmp(st, inuse)
    st.tmp +:= 1
    /ir_tmptable[st.tmp] := ir_Tmp("tmp" || st.tmp)
    return ir_tmptable[st.tmp]
end

procedure ir_tmploc(st, inuse)
    st.lab +:= 1
    /ir_loctable[st.lab] := ir_TmpLabel("loc" || st.lab)
    return ir_loctable[st.lab]
end

procedure ir_tmp_closure(st, inuse)
    st.clo +:= 1
    /ir_clotable[st.clo] := ir_TmpClosure("clo" || st.clo)
    insert(inuse.clo, ir_clotable[st.clo])
    return ir_clotable[st.clo]
end

procedure ir_make_sentinel(L)
    put(L, ir_init(a_NoOp()))
    push(L, ir_init(a_NoOp()))
    return L
end

procedure semantic_error(msg, coord)
    stop("File ", coord.file, "; Line ", coord.line, " # ", msg)
end

procedure ir_max_st(st, t)
    st.tmp <:= t.tmp
    st.lab <:= t.lab
    st.clo <:= t.clo
end

procedure ir_new_inuse()
    return ir_stacks(set(), set(), set())
end

procedure ir_union_inuse(x, L)
    local t
    t := pop(L)
    x.tmp := t.tmp
    x.lab := t.lab
    x.clo := t.clo
    while t := pop(L) do {
        x.tmp ++:= t.tmp
        x.lab ++:= t.lab
        x.clo ++:= t.clo
    }
end
procedure ir_inter_inuse(x, L)
    local t
    t := pop(L)
    x.tmp := t.tmp
    x.lab := t.lab
    x.clo := t.clo
    while t := pop(L) do {
        x.tmp **:= t.tmp
        x.lab **:= t.lab
        x.clo **:= t.clo
    }
end

procedure ir_copy_inuse(x)
    return ir_stacks(copy(x.tmp), copy(x.lab), copy(x.clo))
end

procedure ast2ir(parse, flags)
    local p
    while p := @parse do {
        suspend ir(p)
    }
end
