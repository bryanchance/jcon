record ir_info(start, resume, failure, success, x)
record ir_loopinfo(scanlevel, nextlabel, continue, in_st, out_st, value)
record ir_scaninfo(oldsubject, oldpos)
record ir_stacks(tmp, lab, clo)

global loops, scans

global ir_tmptable, ir_loctable, ir_clotable

# record NoOp( )
procedure ir_NoOp(p, st, target)
	init4ir(p)

	CG.emit(p.ir.start, [ irGoto(p.ir.success) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Field( expr field )
procedure ir_Field(p, st, target)
	local t
	init4ir(p)
	t := (\target | ir_tmp(st))
	ir(p.expr, st, t)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.expr.ir.success, [
		irCoord(p.coord),
		ir_opfn(target, irOperator(".", 2), [ t, irStrLit(p.field.id) ], p.expr.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Scan( op expr body )		op == "?" or "?:="
procedure ir_Scan(p, st, target)
	local lv, rv

	init4ir(p)
	lv := ir_tmp(st)
	rv := (\target | ir_tmp(st))

	p.ir.x := ir_scaninfo()
	p.ir.x.oldpos := ir_tmp(st)
	p.ir.x.oldsubject := ir_tmp(st)

	ir(p.expr, st, lv)
	put(scans, p)
	ir(p.body, st, rv)
	pull(scans)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [
		irScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
		irGoto(p.body.ir.resume)
		])
	CG.emit(p.expr.ir.success, [
		irCoord(p.coord),
		irMove(p.ir.x.oldsubject, irDeref(irKey("subject"))),
		irMove(p.ir.x.oldpos, irDeref(irKey("pos"))),

		ir_opfn(target, irOperator(":?", 2), [ irKey("subject"), lv ], p.expr.ir.resume),

		irGoto(p.body.ir.start)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.failure, [
		irMove(irKey("subject"), p.ir.x.oldsubject),
		irMove(irKey("pos"), p.ir.x.oldpos),
		irGoto(p.expr.ir.resume)
		])

	if p.op == "?" then {
		CG.emit(p.body.ir.success, [
			irScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
			irMove(target, rv),
			irGoto(p.ir.success)
			])
	} else {
		# p.op == "?:="
		CG.emit(p.body.ir.success, [

			ir_opfn(target, irOperator(":=", 2), [ lv, rv ], p.body.ir.resume),

			irScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
			irGoto(p.ir.success)
			])
	}
end

# record Limitation( expr limit )
procedure ir_Limitation(p, st, target)
	local c, t

	init4ir(p)
	c := ir_tmp(st)
	t := ir_tmp(st)

	ir(p.limit, st, t)
	ir(p.expr, st, target)

	CG.emit(p.ir.start, [ irGoto(p.limit.ir.start) ])
	CG.emit(p.ir.resume, [
		ir_opfn(c, irOperator(">", 2), [ t, c ], p.limit.ir.resume),
		ir_opfn(c, irOperator("+", 2), [ c, irIntLit(1) ], p.expr.ir.resume),
		irGoto(p.expr.ir.resume)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.limit.ir.resume) ])
	CG.emit(p.limit.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.success) ])
	CG.emit(p.limit.ir.success, [
		irCoord(p.coord),
		ir_opfn(t, irOperator("#", 1), [ t ], p.limit.ir.resume),
		irMove(c, irIntLit(1)),
		irGoto(p.expr.ir.start)
		])
end

# record Not( expr )
procedure ir_Not(p, st, target)
	init4ir(p)

	ir(p.expr, st, &null)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.failure, [
		irMove(target, irKey("null")),
		irGoto(p.ir.success)
		])
end

# record CoexpList( exprList )
procedure ir_CoexpList(p, st, target)
	stop("FATAL ERROR: don't know how to do coexplist")
end

# record ExclAlt( e1 e2 )
procedure ir_ExclAlt(p, st, target)
	local X, Y, tmp

	init4ir(p)
	X := ir_tmploc(p, "gate")
	Y := ir_tmploc(p, "gate")

	tmp := copy(st)
	ir(p.e1, tmp, target)
	ir(p.e2, st, target)
	max_st(st, tmp)

	CG.emit(p.ir.start, [
		irMove(Y, p.e2.ir.start),
		irGoto(p.e1.ir.start)
		])
	CG.emit(p.ir.resume, [ irGoto(X) ])
	CG.emit(p.e1.ir.success, [
		irMove(X, p.e1.ir.resume),
		irMove(Y, p.ir.failure),
		irGoto(p.ir.success)
		])
	CG.emit(p.e1.ir.failure, [ irGoto(Y) ])
	CG.emit(p.e2.ir.success, [
		irMove(X, p.e2.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.e2.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Alt( e1 e2 )
procedure ir_Alt(p, st, target)
	local t, tmpst
	
	init4ir(p)
	t := ir_tmploc(st)

	tmpst := copy(st)

	ir(p.e1, st, target)
	ir(p.e2, tmpst, target)
	max_st(st, tmpst)

	CG.emit(p.ir.start, [ irGoto(p.e1.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(t) ])
	CG.emit(p.e1.ir.success, [
		irMove(t, p.e1.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.e1.ir.failure, [ irGoto(p.e2.ir.start) ])
	CG.emit(p.e2.ir.success, [
		irMove(t, p.e2.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.e2.ir.failure, [ irGoto(p.ir.failure) ])
end

# record RepAlt( expr )
procedure ir_RepAlt(p, st, target)
	local t

	init4ir(p)
	t := ir_tmploc(st)
	ir(p.expr, st, target)

	CG.emit(p.ir.start, [
		irMove(t, p.ir.failure),
		irGoto(p.expr.ir.start)
		])
	CG.emit(p.ir.resume, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.expr.ir.success, [
		irMove(t, p.ir.start),
		irGoto(p.ir.success)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(t) ])
end

# record Case( expr clauseList dflt )
procedure ir_Case(p, st, target)
	local t, L, i, tmp1, tmp2, e, v

	init4ir(p)
	t := ir_tmploc(st)
	e := ir_tmp(st)
	v := (\target | ir_tmp(st))

	ir(p.expr, st, e)
	tmp2 := copy(st)
	every i := 1 to *p.clauseList do {
		ir(p.clauseList[i].expr, copy(st), v)
		tmp1 := copy(st)
		ir(p.clauseList[i].body, tmp1, target)
		max_st(tmp2, tmp1)
	}
	ir(p.dflt, st, target)
	max_st(st, tmp2)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(t) ])

	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	L := p.clauseList
	if *L = 0 then {
		CG.emit(p.expr.ir.success, [ irGoto(p.dflt.ir.start) ])
	} else {
		CG.emit(p.expr.ir.success, [ irGoto(L[1].expr.ir.start) ])
		every i := 1 to *L do {
			CG.emit(L[i].expr.ir.success, [
				irCoord(p.coord),
				ir_opfn(&null, irOperator("===", 2), [ e, v ], L[i].expr.ir.resume),
				irGoto(L[i].body.ir.start)
				])
			CG.emit(L[i].expr.ir.failure, [ irGoto(L[i+1].expr.ir.start) ])
			CG.emit(L[i].body.ir.success, [
				irMove(t, L[i].body.ir.resume),
				irGoto(p.ir.success)
				])
			CG.emit(L[i].body.ir.failure, [ irGoto(p.ir.failure) ])
		}
		CG.emit(L[-1].expr.ir.failure, [ irGoto(p.dflt.ir.start) ])
	}

	CG.emit(p.dflt.ir.success, [
		irMove(t, p.dflt.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.dflt.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Every( expr body )
procedure ir_Every(p, st, target)
	local tmp

	init4ir_loop(p, st)
	put(loops, p)
	tmp := copy(st)
	ir(p.expr, tmp, &null)
	ir(p.body, tmp, &null)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.body.ir.start) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.resume) ])
end

# record Sectionop( op val left right )
procedure ir_Sectionop(p, st, target)
	local vv, lv, rv

	init4ir(p)
	vv := ir_tmp(st)
	lv := ir_tmp(st)
	rv := (\target | ir_tmp(st))

	ir(p.val, st, vv)
	ir(p.left, st, lv)
	ir(p.right, st, rv)

	CG.emit(p.ir.start, [ irGoto(p.val.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.right.ir.resume) ])
	CG.emit(p.val.ir.success, [ irGoto(p.left.ir.start) ])
	CG.emit(p.val.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.left.ir.success, [ irGoto(p.right.ir.start) ])
	CG.emit(p.left.ir.failure, [ irGoto(p.val.ir.resume) ])
	CG.emit(p.right.ir.success, [
		irCoord(p.coord),
		ir_opfn(target, irOperator(p.op, 3), [ vv, lv, rv ], p.right.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.right.ir.failure, [ irGoto(p.left.ir.resume) ])
end

# record Call( fn args )
procedure ir_Call(p, st, target)
	local closure, L, i, fn, args

	init4ir(p)
	closure := ir_tmp_closure(st)
	fn := ir_tmp(st)
	args := []
	every !p.args.exprList do put(args, ir_tmp(st))

	ir(p.fn, st, fn)
	every i := 1 to *p.args.exprList do {
		ir(p.args.exprList[i], st, args[i])
	}

	L := make_sentinel(p.args.exprList)

	CG.emit(p.ir.start, [ irGoto(p.fn.ir.start) ])
	CG.emit(p.ir.resume, [
		irCoord(p.coord),
		irResume(closure, L[-1].ir.resume, target),
		irGoto(p.ir.success)
		])
	CG.emit(p.fn.ir.success, [ irGoto(L[1].ir.start) ])
	CG.emit(p.fn.ir.failure, [ irGoto(p.ir.failure) ])

	CG.emit(L[1].ir.start, [ irGoto(L[2].ir.start) ])
	CG.emit(L[1].ir.resume, [ irGoto(p.fn.ir.resume) ])
	every i := 2 to *L-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i-1].ir.resume) ])
	}
	CG.emit(L[-1].ir.start, [
		irCoord(p.coord),
		irMakeClosure(closure, fn, args),
		irGoto(p.ir.resume)
		])
	CG.emit(L[-1].ir.resume, [ irGoto(L[-2].ir.resume) ])

end

# record Binop( op left right )
procedure ir_Binop(p, st, target)
	local closure, tmp, op, lv, rv
	static funcs	# functions for which resumption fails immediately.
	initial {
		funcs := set([
			":=",
			":=:",
			"&",
			".",
			"[]",
			"+",
			"-",
			"/",
			"*",
			"%",
			"^",
			"**",
			"++",
			"--",
			"<",
			"<=",
			"=",
			"~=",
			">=",
			">",
			"<<",
			"<<=",
			"==",
			"~==",
			">>=",
			">=",
			">>",
			"===",
			"~===",
			"|||",
			"||",
			"@"
		])
	}

	init4ir(p)
	closure := ir_tmp_closure(st)
	lv := ir_tmp(st)
	tmp := (\target | ir_tmp(st))
	rv := tmp

	ir(p.left, st, lv)
	ir(p.right, st, rv)

	CG.emit(p.ir.start, [ irGoto(p.left.ir.start) ])
	CG.emit(p.left.ir.success, [ irGoto(p.right.ir.start) ])
	CG.emit(p.left.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.right.ir.failure, [ irGoto(p.left.ir.resume) ])

	if find(":=", p.op) > 1 then {
		# augmented assignment
		op := (p.op ? tab(find(":=")))

		CG.emit(p.ir.resume, [ irGoto(p.right.ir.resume) ]) # augmented ops not resumed
		CG.emit(p.right.ir.success, [
			irCoord(p.coord),
			ir_opfn(tmp, irOperator(op, 2), [ lv, rv ], p.right.ir.resume),
			ir_opfn(target, irOperator(":=", 2), [ lv, tmp ], p.right.ir.resume),
			irGoto(p.ir.success)
			])
	} else {
		if member(funcs, p.op) then {
			CG.emit(p.ir.resume, [
				irGoto(p.right.ir.resume)
				])
			CG.emit(p.right.ir.success, [
				irCoord(p.coord),
				ir_opfn(target, irOperator(p.op, 2), [ lv, rv ], p.right.ir.resume),
				irGoto(p.ir.success)
				])
		} else {
			CG.emit(p.ir.resume, [
				irCoord(p.coord),
				irResume(closure, p.right.ir.resume, target),
				irGoto(p.ir.success)
				])
			CG.emit(p.right.ir.success, [
				irCoord(p.coord),
				irMakeClosure(closure, irOperator(p.op, 2), [ lv, rv ]),
				irGoto(p.ir.resume)
				])
		}
	}
end

# record Unop( op operand )
procedure ir_Unop(p, st, target)
	local closure, v
	static funcs	# functions for which resumption fails immediately.
	initial {
		funcs := set([
			".",
			"/",
			"\\",
			"*",
			"?",
			"+",
			"-",
			"~",
			"^"
		])
	}

	init4ir(p)
	closure := ir_tmp_closure(st)
	v := (\target | ir_tmp(st))

	ir(p.operand, st, v)

	CG.emit(p.ir.start, [ irGoto(p.operand.ir.start) ])
	if member(funcs, p.op) then {
		CG.emit(p.ir.resume, [
			irGoto(p.operand.ir.resume)
			])
		CG.emit(p.operand.ir.success, [
			irCoord(p.coord),
			ir_opfn(target, irOperator(p.op, 1), [ v ], p.operand.ir.resume),
			irGoto(p.ir.success)
			])
	} else {
		CG.emit(p.ir.resume, [
			irCoord(p.coord),
			irResume(closure, p.operand.ir.resume, target),
			irGoto(p.ir.success)
			])
		CG.emit(p.operand.ir.success, [
			irCoord(p.coord),
			irMakeClosure(closure, irOperator(p.op,1), [ v ]),
			irGoto(p.ir.resume)
			])
	}
	CG.emit(p.operand.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Global( idList )
procedure ir_Global(p, st, target)
	local globals

	globals := []
	every put(globals, (!p.idList).id)
	CG.globals(globals)
end

# record If( expr thenexpr elseexpr )
procedure ir_If(p, st, target)
	local t, tmp

	init4ir(p)
	t := ir_tmploc(st)

	ir(p.expr, copy(st), &null)
	tmp := copy(st)
	ir(p.thenexpr, tmp, target)
	ir(p.elseexpr, st, target)
	max_st(st, tmp)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(t) ])
	CG.emit(p.expr.ir.success, [
		irMove(t, p.thenexpr.ir.resume),
		irGoto(p.thenexpr.ir.start)
		])
	CG.emit(p.expr.ir.failure, [
		irMove(t, p.elseexpr.ir.resume),
		irGoto(p.elseexpr.ir.start)
		])
	CG.emit(p.thenexpr.ir.success, [ irGoto(p.ir.success) ])
	CG.emit(p.thenexpr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.elseexpr.ir.success, [ irGoto(p.ir.success) ])
	CG.emit(p.elseexpr.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Initial( expr )
procedure ir_Initial(p, st, target)
	loops := []
	scans := []

	init4ir(p)
	ir(p.expr, st, target)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.success) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.success) ])
end

# record Invocable( ivocopList )
procedure ir_Invocable(p, st, target)
	local all, inv, i

	inv := []
	every i := !p.ivocopList do {
		case type(i) of {
		"Ident" : {
			if i.id == "all" then {
				all := 1
			}
			}
		"Stringlit" : {
			put(inv, i.str)
			}
		}
	}
	CG.invocables(all, inv)
end

# record Link( linkfileList )
procedure ir_Link(p, st, target)
	CG.links(p.linkfileList)
end

# record Intlit( int )
procedure ir_Intlit(p, st, target)

	init4ir(p)

	p.int := integer(p.int) | semantic_error(p.int || ": illegal integer literal", p.coord)
	CG.emit(p.ir.start, [
		irMove(target, irIntLit(p.int)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Reallit( real )
procedure ir_Reallit(p, st, target)

	init4ir(p)

	p.real := real(p.real) | semantic_error(p.real || ": illegal real literal", p.coord)
	CG.emit(p.ir.start, [
		irMove(target, irRealLit(p.real)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Stringlit( str )
procedure ir_Stringlit(p, st, target)

	init4ir(p)

	CG.emit(p.ir.start, [
		irMove(target, irStrLit(p.str)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Csetlit( str )
procedure ir_Csetlit(p, st, target)

	init4ir(p)

	CG.emit(p.ir.start, [
		irMove(target, irCsetLit(p.str)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record ProcDecl( ident paramList accumulate localsList code )
procedure ir_ProcDecl(p, st, target)
	local locals, statics, params, i, v

	v := set([])
	every i := !p.paramList | !(!p.localsList).idList do {
		if member(v, i.id) then {
			semantic_error(image(i.id) || ": redeclared identifier", i.coord)
		}
		insert(v, i.id)
	}

	locals := []
	statics := []
	every i := !p.localsList do {
		case type(i) of {
		"Statics" : every put(statics, (!i.idList).id)
		"Locals" : every put(locals, (!i.idList).id)
		}
	}
	params := []
	every put(params, (!p.paramList).id)

	ir_tmptable := table()
	ir_loctable := table()
	ir_clotable := table()

	CG.function(p.ident.id, params, p.accumulate, locals, statics, p.code, p.ident.coord)

end

# record ProcBody( nexprList )
procedure ir_ProcBody(p, st, target)
	local L, i

	loops := []
	scans := []

	init4ir(p)

	L := make_sentinel(p.nexprList)
	every ir(!p.nexprList, ir_stacks(0,0,0), &null)

	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
	every i := 1 to *L-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i+1].ir.start) ])
	}
	CG.emit(L[-1].ir.success, [ irGoto(p.ir.success) ])
	CG.emit(L[-1].ir.failure, [ irGoto(p.ir.failure) ])
end

# record ProcCode( init body )
procedure ir_ProcCode(p, st, target)
	init4ir(p)

	ir(p.init, ir_stacks(0,0,0), &null)
	ir(p.body, ir_stacks(0,0,0), &null)

	CG.emit(p.ir.start, [
		irEnterInit(p.body.ir.start),
		irGoto(p.init.ir.start)
		])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
	CG.emit(p.init.ir.success, [ irGoto(p.body.ir.start) ])
	CG.emit(p.init.ir.failure, [ irGoto(p.body.ir.start) ])
	CG.emit(p.body.ir.success, [ irFail() ])
	CG.emit(p.body.ir.failure, [ irFail() ])
end

# record Record( ident idlist )
procedure ir_Record(p, st, target)
	local fields, v, i

	v := set([])
	every i := !p.idlist do {
		if member(v, i.id) then {
			semantic_error(image(i.id) || ": redeclared identifier", i.coord)
		}
		insert(v, i.id)
	}
	fields := []
	every put(fields, (!p.idlist).id)
	CG.records(p.ident.id, fields, p.ident.coord)
end

# record Repeat( expr )
procedure ir_Repeat(p, st, target)
	init4ir_loop(p, st, target)
	put(loops, p)
	ir(p.expr, copy(st), &null)
	pull(loops)


	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.start) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.start) ])
end

# record Return( expr )
procedure ir_Return(p, st, target)
	local t

	init4ir(p)
	t := ir_tmp(st)

	ir(p.expr, copy(st), t)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irFail() ])
	CG.emit(p.expr.ir.success,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irSucceed(t, &null)
		])
	CG.emit(p.expr.ir.failure,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irFail()
		])
end

# record Fail( )
procedure ir_Fail(p, st, target)

	init4ir(p)

	CG.emit(p.ir.start,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irFail()
		])
	CG.emit(p.ir.resume,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irFail()
		])
end

# record Suspend( expr body )
procedure ir_Suspend(p, st, target)
	local t, tmp, susp

	init4ir_loop(p, st, target)
	t := ir_label(p, "suspend")
	susp := ir_tmp(st)

	put(loops, p)
	tmp := copy(st)
	ir(p.expr, tmp, susp)
	ir(p.body, tmp, &null)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success,
		([ irScanSwap( scans[1].ir.x.oldsubject, scans[1].ir.x.oldpos ) ] | []) |||
		[
		irSucceed(susp, t)
		])
	CG.emit(t,
		[ irRestore() ] |||
		([ irScanSwap( scans[1].ir.x.oldsubject, scans[1].ir.x.oldpos ) ] | []) |||
		[
		irGoto(p.body.ir.start)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.resume) ])
end

# record Until( expr body )
procedure ir_Until(p, st, target)
	init4ir_loop(p, st, target)
	put(loops, p)
	ir(p.expr, copy(st), &null)
	ir(p.body, copy(st), &null)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.body.ir.start) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.start) ])
end

# record While( expr body )
procedure ir_While(p, st, target)
	init4ir_loop(p, st, target)
	put(loops, p)
	ir(p.expr, copy(st), &null)
	ir(p.body, copy(st), &null)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.body.ir.start) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.start) ])
end

# record Create( expr )
procedure ir_Create(p, st, target)
	local t

	init4ir(p)
	t := (\target | ir_tmp(st))

	ir(p.expr, st, t)

	CG.emit(p.ir.start, [
		irCoord(p.coord),
		irMove(target, irCreate(p.expr.ir.start)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.success, [ irCoRet(t, p.expr.ir.resume) ])
	CG.emit(p.expr.ir.failure, [ irCoFail() ])
end

# record Ident( id )
procedure ir_Ident(p, st, target)
	local v

	init4ir(p)

	v := ir_ident(p.id)

	CG.emit(p.ir.start, [
		irMove(target, v),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Next( )
procedure ir_Next(p, st, target)
	local curloop

	init4ir(p)

	curloop := loops[-1]
	CG.emit(p.ir.start,
		([ irMove(irKey("subject"), scans[curloop.ir.x.scanlevel+1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[curloop.ir.x.scanlevel+1].ir.x.oldpos) ] | []) |||
		[
		irGoto(curloop.ir.x.nextlabel)
		])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
end

# record Break( expr )
procedure ir_Break(p, st, target)
	local curloop, oldloops, oldscans, tmp

	init4ir(p)

	curloop := loops[-1] 
	oldloops := loops
	oldscans := scans
	loops := loops[1:-1] 
	scans := scans[1:curloop.ir.x.scanlevel] 
	tmp := copy(curloop.ir.x.in_st)
	ir(p.expr, tmp, curloop.ir.x.value)
	max_st(curloop.ir.x.out_st, tmp)
	loops := oldloops
	scans := oldscans

	CG.emit(p.ir.start,
		([ irMove(irKey("subject"), scans[curloop.ir.x.scanlevel+1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[curloop.ir.x.scanlevel+1].ir.x.oldpos) ] | []) |||
		[
		irMove(curloop.ir.x.continue, p.ir.resume),
		irGoto(p.expr.ir.start)
		])
	CG.emit(p.ir.resume, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.expr.ir.success, [ irGoto(curloop.ir.success) ])
	CG.emit(p.expr.ir.failure, [ irGoto(curloop.ir.failure) ])
end

# record ToBy( fromexpr toexpr byexpr )
procedure ir_ToBy(p, st, target)
	local closure, fv, tv, bv

	init4ir(p)
	closure := ir_tmp_closure(st)
	fv := ir_tmp(st)
	tv := ir_tmp(st)
	bv := (\target | ir_tmp(st))

	ir(p.fromexpr, st, fv)
	ir(p.toexpr, st, tv)
	ir(p.byexpr, st, bv)

	CG.emit(p.ir.start, [ irGoto(p.fromexpr.ir.start) ])
	CG.emit(p.ir.resume, [
		irCoord(p.coord),
		irResume(closure, p.byexpr.ir.resume, target),
		irGoto(p.ir.success)
		])
	CG.emit(p.fromexpr.ir.success, [ irGoto(p.toexpr.ir.start) ])
	CG.emit(p.fromexpr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.toexpr.ir.success, [ irGoto(p.byexpr.ir.start) ])
	CG.emit(p.toexpr.ir.failure, [ irGoto(p.fromexpr.ir.resume) ])
	CG.emit(p.byexpr.ir.success, [
		irCoord(p.coord),
		irMakeClosure(closure, irOperator("...", 3), [ fv, tv, bv ]),
		irGoto(p.ir.resume)
		])
	CG.emit(p.byexpr.ir.failure, [ irGoto(p.toexpr.ir.resume) ])

end

# record Mutual( exprList )
procedure ir_Mutual(p, st, target)
	local L, i

	init4ir(p)

	every i := 1 to *p.exprList-1 do ir(p.exprList[i], st, &null)
	ir(p.exprList[-1], st, target)

	L := make_sentinel(p.exprList)
	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(L[-1].ir.resume) ])

	CG.emit(L[1].ir.start, [ irGoto(L[2].ir.start) ])
	CG.emit(L[1].ir.resume, [ irGoto(p.ir.failure) ])
	every i := 2 to *p.exprList-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i-1].ir.resume) ])
	}
	CG.emit(L[-1].ir.start, [ irGoto(p.ir.success) ])
	CG.emit(L[-1].ir.resume, [ irGoto(L[-2].ir.resume) ])

end

# record Compound( exprList )
procedure ir_Compound(p, st, target)
	local L, i

	init4ir(p)

	every i := 1 to *p.exprList-1 do {
		ir(p.exprList[i], copy(st), &null)
	}
	ir(p.exprList[-1], st, target)

	L := p.exprList
	*L > 0 | stop("fatal error in ir_Compound")
	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(L[-1].ir.resume) ])

	every i := 1 to *p.exprList-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i+1].ir.start) ])
	}
	CG.emit(L[-1].ir.success, [ irGoto(p.ir.success) ])
	CG.emit(L[-1].ir.failure, [ irGoto(p.ir.failure) ])

end

# record Key( id )
procedure ir_Key(p, st, target)
	local k

	init4ir(p)

	case (p.id) of {
	"fail" : {
		CG.emit(p.ir.start, [ irGoto(p.ir.failure) ])
		CG.emit(p.ir.resume, [ irRunTimeError() ])
		}
	"line" : {
		CG.emit(p.ir.start, [
			irMove(target, irIntLit(p.coord.line)),
			irGoto(p.ir.success)
			])
		CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
		}
	"file" : {
		CG.emit(p.ir.start, [
			irMove(target, irStrLit(p.coord.file)),
			irGoto(p.ir.success)
			])
		CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
		}
	default: {
		k := ir_key(p.id)
		CG.emit(p.ir.start, [
			irMove(target, k),
			irGoto(p.ir.success)
			])
		CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
		}
	}
end

# record Arglist( exprList )
procedure ir_Arglist(p, st, target)
	stop("FATAL ERROR: Arglist should be handled in ir_Call(), file ", image(&file), ", line ", image(&line))
end

# record ListConstructor( exprList )
procedure ir_ListConstructor(p, st, target)
	local L, i, args

	init4ir(p)

	args := []
	if \target then {
		every !p.exprList do put(args, ir_tmp(st))
	} else {
		every !p.exprList do put(args, &null)
	}

	every i := 1 to *p.exprList do {
		ir(p.exprList[i], st, args[i])
	}

	L := make_sentinel(p.exprList)

	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(L[-1].ir.resume) ])

	CG.emit(L[1].ir.start, [ irGoto(L[2].ir.start) ])
	CG.emit(L[1].ir.resume, [ irGoto(p.ir.failure) ])
	every i := 2 to *p.exprList-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i-1].ir.resume) ])
	}
	if \target then {
		CG.emit(L[-1].ir.start, [
			irCoord(p.coord),
			irMakeList(target, args),
			irGoto(p.ir.success)
			])
	} else {
		CG.emit(L[-1].ir.start, [ irGoto(p.ir.success) ])
	}
	CG.emit(L[-1].ir.resume, [ irGoto(L[-2].ir.resume) ])

end

procedure ir(p, st, target)
	local q
	case type(p) of {
	"NoOp" : q := ir_NoOp(p, st, target)
	"Field" : q := ir_Field(p, st, target)
	"Call" : q := ir_Call(p, st, target)
	"Scan" : q := ir_Scan(p, st, target)
	"Limitation" : q := ir_Limitation(p, st, target)
	"Not" : q := ir_Not(p, st, target)
	"CoexpList" : q := ir_CoexpList(p, st, target)
	"Alt" : q := ir_Alt(p, st, target)
	"ExclAlt" : q := ir_ExclAlt(p, st, target)
	"RepAlt" : q := ir_RepAlt(p, st, target)
	"Case" : q := ir_Case(p, st, target)
	"Every" : q := ir_Every(p, st, target)
	"Sectionop" : q := ir_Sectionop(p, st, target)
	"Binop" : q := ir_Binop(p, st, target)
	"Unop" : q := ir_Unop(p, st, target)
	"Global" : q := ir_Global(p, st, target)
	"If" : q := ir_If(p, st, target)
	"Initial" : q := ir_Initial(p, st, target)
	"Invocable" : q := ir_Invocable(p, st, target)
	"Link" : q := ir_Link(p, st, target)
	"Intlit" : q := ir_Intlit(p, st, target)
	"Reallit" : q := ir_Reallit(p, st, target)
	"Stringlit" : q := ir_Stringlit(p, st, target)
	"Csetlit" : q := ir_Csetlit(p, st, target)
	"ProcDecl" : q := ir_ProcDecl(p, st, target)
	"ProcBody" : q := ir_ProcBody(p, st, target)
	"ProcCode" : q := ir_ProcCode(p, st, target)
	"Record" : q := ir_Record(p, st, target)
	"Repeat" : q := ir_Repeat(p, st, target)
	"Return" : q := ir_Return(p, st, target)
	"Fail" : q := ir_Fail(p, st, target)
	"Suspend" : q := ir_Suspend(p, st, target)
	"Until" : q := ir_Until(p, st, target)
	"While" : q := ir_While(p, st, target)
	"Create" : q := ir_Create(p, st, target)
	"Ident" : q := ir_Ident(p, st, target)
	"Next" : q := ir_Next(p, st, target)
	"Break" : q := ir_Break(p, st, target)
	"ToBy" : q := ir_ToBy(p, st, target)
	"Mutual" : q := ir_Mutual(p, st, target)
	"Compound" : q := ir_Compound(p, st, target)
	"ListConstructor" : q := ir_ListConstructor(p, st, target)
	"Key" : q := ir_Key(p, st, target)
	"Arglist" : q := ir_Arglist(p, st, target)
	default : runerr(1000, p)
	}
	return q
end

procedure ir_opfn(lhs, op, args, failLabel)
	static neverfail
	initial {
		neverfail := list(3)
		neverfail[1] := set([
			"#", "+", "-", "~", "^", "*", "."
		])
		neverfail[2] := set([
			"+", "-", "*", "/", "%", "^", 
			"++", "--", "**", 
			"||", "|||",
			".", "&"
			# ":=", ":=:" omited because &pos:=*&subject+2 fails
		])
		neverfail[3] := set([ ])
	}
	if \noerror2failure & member(neverfail[op.arity],op.name) then {
		failLabel := &null
	}
	return irOpFunction(lhs, op, args, failLabel)
end

procedure init4ir(p)
	p.ir := ir_info()
	p.ir.start := ir_label(p, "start")
	p.ir.resume := ir_label(p, "resume")
	p.ir.success := ir_label(p, "success")
	p.ir.failure := ir_label(p, "failure")
	return p
end

procedure init4ir_loop(p, st, target)
	init4ir(p)
	p.ir.x := ir_loopinfo()
	p.ir.x.continue := ir_tmploc(st)
	p.ir.x.nextlabel := ir_label(p, "next")
	p.ir.x.scanlevel := *scans
	p.ir.x.in_st := copy(st)
	p.ir.x.out_st := st
	p.ir.x.value := target
	return p
end

procedure ir_label(p, suffix)
	return irLabel(ir_naming(p, suffix))
end

procedure ir_naming(p, suffix)
	local s

	image(p) ? {
		tab(upto(' '))
		move(1)
		s := tab(upto('('))
	}
	return s || "_" || suffix
end

procedure ir_dump(insn)
	return dump(insn, set(["x"]))
end

procedure ir_ident(str)
	return irVar(str)
end

procedure ir_key(str)
	local k

	static keytable
	initial {
		keytable := table()
	}
	k := /keytable[str] := irKey(str)
	return \k | keytable[str]
end

procedure ir_tmp(st)
	st.tmp +:= 1
	/ir_tmptable[st.tmp] := irTmp("tmp" || st.tmp)
	return ir_tmptable[st.tmp]
end

procedure ir_tmploc(st)
	st.lab +:= 1
	/ir_loctable[st.lab] := irTmpLabel("loc" || st.lab)
	return ir_loctable[st.lab]
end

procedure ir_tmp_closure(st)
	st.clo +:= 1
	/ir_clotable[st.clo] := irTmpClosure("clo" || st.clo)
	return ir_clotable[st.clo]
end

procedure make_sentinel(L)
	put(L, init4ir(NoOp()))
	push(L, init4ir(NoOp()))
	return L
end

procedure semantic_error(msg, coord)
	stop("File ", coord.file, "; Line ", coord.line, " # ", msg)
end

procedure max_st(st, t)
	st.tmp <:= t.tmp
	st.lab <:= t.lab
	st.clo <:= t.clo
end
