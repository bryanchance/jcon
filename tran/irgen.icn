record ir_info(value, start, resume, failure, success, x)
record ir_loopinfo(scanlevel, nextlabel, continue, in_st, out_st)
record ir_scaninfo(oldsubject, oldpos)
record ir_stacks(tmp, lab, clo)

global loops, scans

global ir_tmptable, ir_loctable, ir_clotable

# record NoOp( )
procedure ir_NoOp(p, st)
	init4ir(p)

	CG.emit(p.ir.start, [ irGoto(p.ir.success) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Field( expr field )
procedure ir_Field(p, st)
	init4ir(p, st)
	ir(p.expr, st)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.expr.ir.success, [
		irCoord(p.coord),
		ir_opfn(p.ir.value, irOperator(".", 2), [ p.expr.ir.value, irStrLit(p.field.id) ], p.expr.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Scan( op expr body )		op == "?" or "?:="
procedure ir_Scan(p, st)
	init4ir(p, st)

	p.ir.x := ir_scaninfo()
	p.ir.x.oldpos := ir_tmp(st)
	p.ir.x.oldsubject := ir_tmp(st)

	ir(p.expr, st)
	put(scans, p)
	ir(p.body, st)
	pull(scans)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [
		irScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
		irGoto(p.body.ir.resume)
		])
	CG.emit(p.expr.ir.success, [
		irCoord(p.coord),
		irMove(p.ir.x.oldsubject, irDeref(irKey("subject"))),
		irMove(p.ir.x.oldpos, irDeref(irKey("pos"))),

		ir_opfn(p.ir.value, irOperator(":?", 2), [ irKey("subject"), p.expr.ir.value ], p.expr.ir.resume),

		irGoto(p.body.ir.start)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.failure, [
		irMove(irKey("subject"), p.ir.x.oldsubject),
		irMove(irKey("pos"), p.ir.x.oldpos),
		irGoto(p.expr.ir.resume)
		])

	if p.op == "?" then {
		CG.emit(p.body.ir.success, [
			irScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
			irMove(p.ir.value, p.body.ir.value),
			irGoto(p.ir.success)
			])
	} else {
		# p.op == "?:="
		CG.emit(p.body.ir.success, [

			ir_opfn(p.ir.value, irOperator(":=", 2), [ p.expr.ir.value, p.body.ir.value ], p.body.ir.resume),

			irScanSwap( p.ir.x.oldsubject, p.ir.x.oldpos ),
			irGoto(p.ir.success)
			])
	}
end

# record Limitation( expr limit )
procedure ir_Limitation(p, st)
	local c

	init4ir(p, st)
	c := ir_tmp(st)

	ir(p.limit, st)
	ir(p.expr, st)

	CG.emit(p.ir.start, [ irGoto(p.limit.ir.start) ])
	CG.emit(p.ir.resume, [
		ir_opfn(c, irOperator(">", 2), [ p.limit.ir.value, c ], p.limit.ir.resume),
		ir_opfn(c, irOperator("+", 2), [ c, irIntLit(1) ], p.expr.ir.resume),
		irGoto(p.expr.ir.resume)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.limit.ir.resume) ])
	CG.emit(p.limit.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.success, [
		irMove(p.ir.value, p.expr.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.limit.ir.success, [
		irCoord(p.coord),
		ir_opfn(p.limit.ir.value, irOperator("#", 1), [ p.limit.ir.value ], p.limit.ir.resume),
		irMove(c, irIntLit(1)),
		irGoto(p.expr.ir.start)
		])
end

# record Not( expr )
procedure ir_Not(p, st)
	init4ir(p, st)

	ir(p.expr, st)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.failure, [
		irMove(p.ir.value, irKey("null")),
		irGoto(p.ir.success)
		])
end

# record CoexpList( exprList )
procedure ir_CoexpList(p, st)
	stop("FATAL ERROR: don't know how to do coexplist")
end

# record ExclAlt( e1 e2 )
procedure ir_ExclAlt(p, st)
	local X, Y

	runerr(1000)	# unimplemented

	ir(p.e1)
	ir(p.e2)

	init4ir(p, st)

	X := ir_tmploc(p, "gate")
	Y := ir_tmploc(p, "gate")

	CG.emit(p.ir.start, [
		irMove(Y, p.e2.ir.start),
		irGoto(p.e1.ir.start)
		])
	CG.emit(p.ir.resume, [ irGoto(X) ])
	CG.emit(p.e1.ir.success, [
		irMove(X, p.e1.ir.resume),
		irMove(Y, p.ir.failure),
		irMove(p.ir.value, p.e1.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.e1.ir.failure, [ irGoto(Y) ])
	CG.emit(p.e2.ir.success, [
		irMove(X, p.e2.ir.resume),
		irMove(p.ir.value, p.e2.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.e2.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Alt( e1 e2 )
procedure ir_Alt(p, st)
	local t, tmpst
	
	init4ir(p, st)
	t := ir_tmploc(st)

	tmpst := copy(st)

	ir(p.e1, st)
	ir(p.e2, tmpst)
	max_st(st, tmpst)

	CG.emit(p.ir.start, [ irGoto(p.e1.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(t) ])
	CG.emit(p.e1.ir.success, [
		irMove(t, p.e1.ir.resume),
		irMove(p.ir.value, p.e1.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.e1.ir.failure, [ irGoto(p.e2.ir.start) ])
	CG.emit(p.e2.ir.success, [
		irMove(t, p.e2.ir.resume),
		irMove(p.ir.value, p.e2.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.e2.ir.failure, [ irGoto(p.ir.failure) ])
end

# record RepAlt( expr )
procedure ir_RepAlt(p, st)
	local t

	init4ir(p, st)
	t := ir_tmploc(st)
	ir(p.expr, st)

	CG.emit(p.ir.start, [
		irMove(t, p.ir.failure),
		irGoto(p.expr.ir.start)
		])
	CG.emit(p.ir.resume, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.expr.ir.success, [
		irMove(t, p.ir.start),
		irMove(p.ir.value, p.expr.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(t) ])
end

# record Case( expr clauseList dflt )
procedure ir_Case(p, st)
	local t, L, i, tmp1, tmp2

	init4ir(p, st)
	t := ir_tmploc(st)

	ir(p.expr, st)
	tmp2 := copy(st)
	every i := 1 to *p.clauseList do {
		tmp1 := copy(st)
		ir(p.clauseList[i].expr, tmp1)
		ir(p.clauseList[i].body, tmp1)
		max_st(tmp2, tmp1)
	}
	ir(p.dflt, st)
	max_st(st, tmp2)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(t) ])

	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	L := p.clauseList
	if *L = 0 then {
		CG.emit(p.expr.ir.success, [ irGoto(p.dflt.ir.start) ])
	} else {
		CG.emit(p.expr.ir.success, [ irGoto(L[1].expr.ir.start) ])
		every i := 1 to *L do {
			CG.emit(L[i].expr.ir.success, [
				irCoord(p.coord),
				ir_opfn(&null, irOperator("===", 2), [ p.expr.ir.value, L[i].expr.ir.value ], L[i].expr.ir.resume),
				irGoto(L[i].body.ir.start)
				])
			CG.emit(L[i].expr.ir.failure, [ irGoto(L[i+1].expr.ir.start) ])
			CG.emit(L[i].body.ir.success, [
				irMove(p.ir.value, L[i].body.ir.value),
				irMove(t, L[i].body.ir.resume),
				irGoto(p.ir.success)
				])
			CG.emit(L[i].body.ir.failure, [ irGoto(p.ir.failure) ])
		}
		CG.emit(L[-1].expr.ir.failure, [ irGoto(p.dflt.ir.start) ])
	}

	CG.emit(p.dflt.ir.success, [
		irMove(p.ir.value, p.dflt.ir.value),
		irMove(t, p.dflt.ir.resume),
		irGoto(p.ir.success)
		])
	CG.emit(p.dflt.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Every( expr body )
procedure ir_Every(p, st)
	local tmp

	init4ir_loop(p, st)
	put(loops, p)
	tmp := copy(st)
	ir(p.expr, tmp)
	ir(p.body, tmp)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.body.ir.start) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.resume) ])
end

# record Sectionop( op val left right )
procedure ir_Sectionop(p, st)
	init4ir(p, st)

	ir(p.val, st)
	ir(p.left, st)
	ir(p.right, st)

	CG.emit(p.ir.start, [ irGoto(p.val.ir.start) ])
	CG.emit(p.ir.resume, [
		irGoto(p.right.ir.resume)
		])
	CG.emit(p.val.ir.success, [ irGoto(p.left.ir.start) ])
	CG.emit(p.val.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.left.ir.success, [ irGoto(p.right.ir.start) ])
	CG.emit(p.left.ir.failure, [ irGoto(p.val.ir.resume) ])
	CG.emit(p.right.ir.success, [
		irCoord(p.coord),

		ir_opfn(p.ir.value, irOperator(p.op, 3), [ p.val.ir.value, p.left.ir.value, p.right.ir.value ], p.right.ir.resume),

		irGoto(p.ir.success)
		])
	CG.emit(p.right.ir.failure, [ irGoto(p.left.ir.resume) ])
end

# record Call( fn args )
procedure ir_Call(p, st)
	local closure, L, i

	init4ir(p, st)
	closure := ir_tmp_closure(st)

	ir(p.fn, st)
	every ir(!p.args.exprList, st)

	L := make_sentinel(p.args.exprList)

	CG.emit(p.ir.start, [ irGoto(p.fn.ir.start) ])
	CG.emit(p.ir.resume, [
		irCoord(p.coord),
		irResume(closure, L[-1].ir.resume, p.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.fn.ir.success, [ irGoto(L[1].ir.start) ])
	CG.emit(p.fn.ir.failure, [ irGoto(p.ir.failure) ])

	CG.emit(L[1].ir.start, [ irGoto(L[2].ir.start) ])
	CG.emit(L[1].ir.resume, [ irGoto(p.fn.ir.resume) ])
	args := []
	every i := 2 to *L-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i-1].ir.resume) ])
		put(args, L[i].ir.value)
	}
	CG.emit(L[-1].ir.start, [
		irCoord(p.coord),
		irMakeClosure(closure, p.fn.ir.value, args),
		irGoto(p.ir.resume)
		])
	CG.emit(L[-1].ir.resume, [ irGoto(L[-2].ir.resume) ])

end

# record Binop( op left right )
procedure ir_Binop(p, st)
	local closure, tmp, op
	static funcs	# functions for which resumption fails immediately.
	initial {
		funcs := set([
			":=",
			":=:",
			"&",
			".",
			"[]",
			"+",
			"-",
			"/",
			"*",
			"%",
			"^",
			"**",
			"++",
			"--",
			"<",
			"<=",
			"=",
			"~=",
			">=",
			">",
			"<<",
			"<<=",
			"==",
			"~==",
			">>=",
			">=",
			">>",
			"===",
			"~===",
			"|||",
			"||",
			"@"
		])
	}

	init4ir(p, st)
	closure := ir_tmp_closure(st)
	tmp := ir_tmp(st)

	ir(p.left, st)
	ir(p.right, st)

	CG.emit(p.ir.start, [ irGoto(p.left.ir.start) ])
	CG.emit(p.left.ir.success, [ irGoto(p.right.ir.start) ])
	CG.emit(p.left.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.right.ir.failure, [ irGoto(p.left.ir.resume) ])

	if find(":=", p.op) > 1 then {
		# augmented assignment
		op := (p.op ? tab(find(":=")))

		CG.emit(p.ir.resume, [ irGoto(p.right.ir.resume) ]) # augmented ops not resumed
		CG.emit(p.right.ir.success, [
			irCoord(p.coord),
			ir_opfn(tmp, irOperator(op, 2), [ p.left.ir.value, p.right.ir.value ], p.right.ir.resume),
			ir_opfn(p.ir.value, irOperator(":=", 2), [ p.left.ir.value, tmp ], p.right.ir.resume),
			irGoto(p.ir.success)
			])
	} else {
		if member(funcs, p.op) then {
			CG.emit(p.ir.resume, [
				irGoto(p.right.ir.resume)
				])
			CG.emit(p.right.ir.success, [
				irCoord(p.coord),
				ir_opfn(p.ir.value, irOperator(p.op, 2), [ p.left.ir.value, p.right.ir.value ], p.right.ir.resume),
				irGoto(p.ir.success)
				])
		} else {
			CG.emit(p.ir.resume, [
				irCoord(p.coord),
				irResume(closure, p.right.ir.resume, p.ir.value),
				irGoto(p.ir.success)
				])
			CG.emit(p.right.ir.success, [
				irCoord(p.coord),
				irMakeClosure(closure, irOperator(p.op, 2), [ p.left.ir.value, p.right.ir.value ]),
				irGoto(p.ir.resume)
				])
		}
	}
end

# record Unop( op operand )
procedure ir_Unop(p, st)
	local closure
	static funcs	# functions for which resumption fails immediately.
	initial {
		funcs := set([
			".",
			"/",
			"\\",
			"*",
			"?",
			"+",
			"-",
			"~",
			"^"
		])
	}

	init4ir(p, st)
	closure := ir_tmp_closure(st)

	ir(p.operand, st)

	CG.emit(p.ir.start, [ irGoto(p.operand.ir.start) ])
	if member(funcs, p.op) then {
		CG.emit(p.ir.resume, [
			irGoto(p.operand.ir.resume)
			])
		CG.emit(p.operand.ir.success, [
			irCoord(p.coord),
			ir_opfn(p.ir.value, irOperator(p.op, 1), [ p.operand.ir.value ], p.operand.ir.resume),
			irGoto(p.ir.success)
			])
	} else {
		CG.emit(p.ir.resume, [
			irCoord(p.coord),
			irResume(closure, p.operand.ir.resume, p.ir.value),
			irGoto(p.ir.success)
			])
		CG.emit(p.operand.ir.success, [
			irCoord(p.coord),
			irMakeClosure(closure, irOperator(p.op,1), [ p.operand.ir.value ]),
			irGoto(p.ir.resume)
			])
	}
	CG.emit(p.operand.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Global( idList )
procedure ir_Global(p, st)
	local globals

	globals := []
	every put(globals, (!p.idList).id)
	CG.globals(globals)
end

# record If( expr thenexpr elseexpr )
procedure ir_If(p, st)
	local t, tmp

	init4ir(p, st)
	t := ir_tmploc(st)

	ir(p.expr, copy(st))
	tmp := copy(st)
	ir(p.thenexpr, tmp)
	ir(p.elseexpr, st)
	max_st(st, tmp)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(t) ])
	CG.emit(p.expr.ir.success, [
		irMove(t, p.thenexpr.ir.resume),
		irGoto(p.thenexpr.ir.start)
		])
	CG.emit(p.expr.ir.failure, [
		irMove(t, p.elseexpr.ir.resume),
		irGoto(p.elseexpr.ir.start)
		])
	CG.emit(p.thenexpr.ir.success, [
		irMove(p.ir.value, p.thenexpr.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.thenexpr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.elseexpr.ir.success, [
		irMove(p.ir.value, p.elseexpr.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.elseexpr.ir.failure, [ irGoto(p.ir.failure) ])
end

# record Initial( expr )
procedure ir_Initial(p, st)
	loops := []
	scans := []

	init4ir(p, st)
	ir(p.expr, st)

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.success) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.success) ])
end

# record Invocable( ivocopList )
procedure ir_Invocable(p, st)
	local all, inv, i

	inv := []
	every i := !p.ivocopList do {
		case type(i) of {
		"Ident" : {
			if i.id == "all" then {
				all := 1
			}
			}
		"Stringlit" : {
			put(inv, i.str)
			}
		}
	}
	CG.invocables(all, inv)
end

# record Link( linkfileList )
procedure ir_Link(p, st)
	CG.links(p.linkfileList)
end

# record Intlit( int )
procedure ir_Intlit(p, st)

	init4ir(p, st)

	p.int := integer(p.int) | semantic_error(p.int || ": illegal integer literal", p.coord)
	CG.emit(p.ir.start, [
		irMove(p.ir.value, irIntLit(p.int)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Reallit( real )
procedure ir_Reallit(p, st)

	init4ir(p, st)

	p.real := real(p.real) | semantic_error(p.real || ": illegal real literal", p.coord)
	CG.emit(p.ir.start, [
		irMove(p.ir.value, irRealLit(p.real)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Stringlit( str )
procedure ir_Stringlit(p, st)

	init4ir(p, st)

	CG.emit(p.ir.start, [
		irMove(p.ir.value, irStrLit(p.str)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Csetlit( str )
procedure ir_Csetlit(p, st)

	init4ir(p, st)

	CG.emit(p.ir.start, [
		irMove(p.ir.value, irCsetLit(p.str)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record ProcDecl( ident paramList accumulate localsList code )
procedure ir_ProcDecl(p, st)
	local locals, statics, params, i, v

	v := set([])
	every i := !p.paramList | !(!p.localsList).idList do {
		if member(v, i.id) then {
			semantic_error(image(i.id) || ": redeclared identifier", i.coord)
		}
		insert(v, i.id)
	}

	locals := []
	statics := []
	every i := !p.localsList do {
		case type(i) of {
		"Statics" : every put(statics, (!i.idList).id)
		"Locals" : every put(locals, (!i.idList).id)
		}
	}
	params := []
	every put(params, (!p.paramList).id)

	ir_tmptable := table()
	ir_loctable := table()
	ir_clotable := table()

	CG.function(p.ident.id, params, p.accumulate, locals, statics, p.code, p.ident.coord)

end

# record ProcBody( nexprList )
procedure ir_ProcBody(p, st)
	local L, i

	loops := []
	scans := []

	init4ir(p, st)

	L := make_sentinel(p.nexprList)
	every ir(!p.nexprList, ir_stacks(0,0,0))

	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
	every i := 1 to *L-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i+1].ir.start) ])
	}
	CG.emit(L[-1].ir.success, [ irGoto(p.ir.success) ])
	CG.emit(L[-1].ir.failure, [ irGoto(p.ir.failure) ])
end

# record ProcCode( init body )
procedure ir_ProcCode(p, st)
	init4ir(p, st)

	ir(p.init, ir_stacks(0,0,0))
	ir(p.body, ir_stacks(0,0,0))

	CG.emit(p.ir.start, [
		irEnterInit(p.body.ir.start),
		irGoto(p.init.ir.start)
		])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
	CG.emit(p.init.ir.success, [ irGoto(p.body.ir.start) ])
	CG.emit(p.init.ir.failure, [ irGoto(p.body.ir.start) ])
	CG.emit(p.body.ir.success, [ irFail() ])
	CG.emit(p.body.ir.failure, [ irFail() ])
end

# record Record( ident idlist )
procedure ir_Record(p, st)
	local fields, v, i

	v := set([])
	every i := !p.idlist do {
		if member(v, i.id) then {
			semantic_error(image(i.id) || ": redeclared identifier", i.coord)
		}
		insert(v, i.id)
	}
	fields := []
	every put(fields, (!p.idlist).id)
	CG.records(p.ident.id, fields, p.ident.coord)
end

# record Repeat( expr )
procedure ir_Repeat(p, st)
	init4ir_loop(p, st)
	put(loops, p)
	ir(p.expr, copy(st))
	pull(loops)


	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.start) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.start) ])
end

# record Return( expr )
procedure ir_Return(p, st)
	init4ir(p, st)

	ir(p.expr, copy(st))

	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irFail() ])
	CG.emit(p.expr.ir.success,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irSucceed(p.expr.ir.value, &null)
		])
	CG.emit(p.expr.ir.failure,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irFail()
		])
end

# record Fail( )
procedure ir_Fail(p, st)

	init4ir(p, st)

	CG.emit(p.ir.start,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irFail()
		])
	CG.emit(p.ir.resume,
		([ irMove(irKey("subject"), scans[1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[1].ir.x.oldpos) ] | []) |||
		[
		irFail()
		])
end

# record Suspend( expr body )
procedure ir_Suspend(p, st)
	local t, tmp

	init4ir_loop(p, st)
	t := ir_label(p, "suspend")

	put(loops, p)
	tmp := copy(st)
	ir(p.expr, tmp)
	ir(p.body, tmp)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success,
		([ irScanSwap( scans[1].ir.x.oldsubject, scans[1].ir.x.oldpos ) ] | []) |||
		[
		irSucceed(p.expr.ir.value, t)
		])
	CG.emit(t,
		[ irRestore() ] |||
		([ irScanSwap( scans[1].ir.x.oldsubject, scans[1].ir.x.oldpos ) ] | []) |||
		[
		irGoto(p.body.ir.start)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.resume) ])
end

# record Until( expr body )
procedure ir_Until(p, st)
	local tmp

	init4ir_loop(p, st)
	put(loops, p)
	tmp := copy(st)
	ir(p.expr, tmp)
	ir(p.body, tmp)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.body.ir.start) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.start) ])
end

# record While( expr body )
procedure ir_While(p, st)
	local tmp

	init4ir_loop(p, st)
	put(loops, p)
	tmp := copy(st)
	ir(p.expr, tmp)
	ir(p.body, tmp)
	pull(loops)

	CG.emit(p.ir.x.nextlabel, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.start, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(p.ir.x.continue) ])
	CG.emit(p.expr.ir.success, [ irGoto(p.body.ir.start) ])
	CG.emit(p.expr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.body.ir.success, [ irGoto(p.expr.ir.start) ])
	CG.emit(p.body.ir.failure, [ irGoto(p.expr.ir.start) ])
end

# record Create( expr )
procedure ir_Create(p, st)
	init4ir(p, st)

	ir(p.expr, st)

	CG.emit(p.ir.start, [
		irCoord(p.coord),
		irMove(p.ir.value, irCreate(p.expr.ir.start)),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
	CG.emit(p.expr.ir.success, [ irCoRet(p.expr.ir.value, p.expr.ir.resume) ])
	CG.emit(p.expr.ir.failure, [ irCoFail() ])
end

# record Ident( id )
procedure ir_Ident(p, st)
	local v

	init4ir(p, st)

	v := ir_ident(p.id)

	CG.emit(p.ir.start, [
		irMove(p.ir.value, v),
		irGoto(p.ir.success)
		])
	CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
end

# record Next( )
procedure ir_Next(p, st)
	local curloop

	init4ir(p, st)

	curloop := loops[-1]
	CG.emit(p.ir.start,
		([ irMove(irKey("subject"), scans[curloop.ir.x.scanlevel+1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[curloop.ir.x.scanlevel+1].ir.x.oldpos) ] | []) |||
		[
		irGoto(curloop.ir.x.nextlabel)
		])
	CG.emit(p.ir.resume, [ irRunTimeError() ])
end

# record Break( expr )
procedure ir_Break(p, st)
	local curloop, oldloops, oldscans, tmp

	init4ir(p, st)

	curloop := loops[-1] 
	oldloops := loops
	oldscans := scans
	loops := loops[1:-1] 
	scans := scans[1:curloop.ir.x.scanlevel] 
	tmp := copy(curloop.ir.x.in_st)
	ir(p.expr, tmp)
	max_st(curloop.ir.x.out_st, tmp)
	loops := oldloops
	scans := oldscans

	CG.emit(p.ir.start,
		([ irMove(irKey("subject"), scans[curloop.ir.x.scanlevel+1].ir.x.oldsubject),
		irMove(irKey("pos"), scans[curloop.ir.x.scanlevel+1].ir.x.oldpos) ] | []) |||
		[
		irMove(curloop.ir.x.continue, p.ir.resume),
		irGoto(p.expr.ir.start)
		])
	CG.emit(p.ir.resume, [ irGoto(p.expr.ir.resume) ])
	CG.emit(p.expr.ir.success, [
		irMove(curloop.ir.value, p.expr.ir.value),
		irGoto(curloop.ir.success)
		])
	CG.emit(p.expr.ir.failure, [ irGoto(curloop.ir.failure) ])
end

# record ToBy( fromexpr toexpr byexpr )
procedure ir_ToBy(p, st)
	local closure

	init4ir(p, st)
	closure := ir_tmp_closure(st)

	ir(p.fromexpr, st)
	ir(p.toexpr, st)
	ir(p.byexpr, st)

	CG.emit(p.ir.start, [ irGoto(p.fromexpr.ir.start) ])
	CG.emit(p.ir.resume, [
		irCoord(p.coord),
		irResume(closure, p.byexpr.ir.resume, p.ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(p.fromexpr.ir.success, [ irGoto(p.toexpr.ir.start) ])
	CG.emit(p.fromexpr.ir.failure, [ irGoto(p.ir.failure) ])
	CG.emit(p.toexpr.ir.success, [ irGoto(p.byexpr.ir.start) ])
	CG.emit(p.toexpr.ir.failure, [ irGoto(p.fromexpr.ir.resume) ])
	CG.emit(p.byexpr.ir.success, [
		irCoord(p.coord),
		irMakeClosure(closure, irOperator("...", 3), [ p.fromexpr.ir.value, p.toexpr.ir.value, p.byexpr.ir.value ]),
		irGoto(p.ir.resume)
		])
	CG.emit(p.byexpr.ir.failure, [ irGoto(p.toexpr.ir.resume) ])

end

# record Mutual( exprList )
procedure ir_Mutual(p, st)
	local L, i

	init4ir(p, st)

	every ir(!p.exprList, st)

	L := make_sentinel(p.exprList)
	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(L[-1].ir.resume) ])

	CG.emit(L[1].ir.start, [ irGoto(L[2].ir.start) ])
	CG.emit(L[1].ir.resume, [ irGoto(p.ir.failure) ])
	every i := 2 to *p.exprList-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i-1].ir.resume) ])
	}
	CG.emit(L[-1].ir.start, [
		irMove(p.ir.value, L[-2].ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(L[-1].ir.resume, [ irGoto(L[-2].ir.resume) ])

end

# record Compound( exprList )
procedure ir_Compound(p, st)
	local L, i

	init4ir(p, st)

	every i := 1 to *p.exprList-1 do {
		ir(p.exprList[i], copy(st))
	}
	ir(p.exprList[-1], st)

	L := p.exprList
	*L > 0 | stop("fatal error in ir_Compound")
	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(L[-1].ir.resume) ])

	every i := 1 to *p.exprList-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i+1].ir.start) ])
	}
	CG.emit(L[-1].ir.success, [
		irMove(p.ir.value, L[-1].ir.value),
		irGoto(p.ir.success)
		])
	CG.emit(L[-1].ir.failure, [ irGoto(p.ir.failure) ])

end

# record Key( id )
procedure ir_Key(p, st)
	local k

	init4ir(p, st)

	case (p.id) of {
	"fail" : {
		CG.emit(p.ir.start, [ irGoto(p.ir.failure) ])
		CG.emit(p.ir.resume, [ irRunTimeError() ])
		}
	"line" : {
		CG.emit(p.ir.start, [
			irMove(p.ir.value, irIntLit(p.coord.line)),
			irGoto(p.ir.success)
			])
		CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
		}
	"file" : {
		CG.emit(p.ir.start, [
			irMove(p.ir.value, irStrLit(p.coord.file)),
			irGoto(p.ir.success)
			])
		CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
		}
	default: {
		k := ir_key(p.id)
		CG.emit(p.ir.start, [
			irMove(p.ir.value, k),
			irGoto(p.ir.success)
			])
		CG.emit(p.ir.resume, [ irGoto(p.ir.failure) ])
		}
	}
end

# record Arglist( exprList )
procedure ir_Arglist(p, st)
	stop("FATAL ERROR: Arglist should be handled in ir_Call(), file ", image(&file), ", line ", image(&line))
end

# record ListConstructor( exprList )
procedure ir_ListConstructor(p, st)
	local L, i

	init4ir(p, st)

	every ir(!p.exprList, st)

	L := make_sentinel(p.exprList)

	CG.emit(p.ir.start, [ irGoto(L[1].ir.start) ])
	CG.emit(p.ir.resume, [ irGoto(L[-1].ir.resume) ])

	CG.emit(L[1].ir.start, [ irGoto(L[2].ir.start) ])
	CG.emit(L[1].ir.resume, [ irGoto(p.ir.failure) ])
	args := []
	every i := 2 to *p.exprList-1 do {
		CG.emit(L[i].ir.success, [ irGoto(L[i+1].ir.start) ])
		CG.emit(L[i].ir.failure, [ irGoto(L[i-1].ir.resume) ])
		put(args, L[i].ir.value)
	}
	CG.emit(L[-1].ir.start, [
		irCoord(p.coord),
		irMakeList(p.ir.value, args),
		irGoto(p.ir.success)
		])
	CG.emit(L[-1].ir.resume, [ irGoto(L[-2].ir.resume) ])

end

procedure ir(p, st)
	local q
	case type(p) of {
	"NoOp" : q := ir_NoOp(p, st)
	"Field" : q := ir_Field(p, st)
	"Call" : q := ir_Call(p, st)
	"Scan" : q := ir_Scan(p, st)
	"Limitation" : q := ir_Limitation(p, st)
	"Not" : q := ir_Not(p, st)
	"CoexpList" : q := ir_CoexpList(p, st)
	"Alt" : q := ir_Alt(p, st)
	"ExclAlt" : q := ir_ExclAlt(p, st)
	"RepAlt" : q := ir_RepAlt(p, st)
	"Case" : q := ir_Case(p, st)
	"Every" : q := ir_Every(p, st)
	"Sectionop" : q := ir_Sectionop(p, st)
	"Binop" : q := ir_Binop(p, st)
	"Unop" : q := ir_Unop(p, st)
	"Global" : q := ir_Global(p, st)
	"If" : q := ir_If(p, st)
	"Initial" : q := ir_Initial(p, st)
	"Invocable" : q := ir_Invocable(p, st)
	"Link" : q := ir_Link(p, st)
	"Intlit" : q := ir_Intlit(p, st)
	"Reallit" : q := ir_Reallit(p, st)
	"Stringlit" : q := ir_Stringlit(p, st)
	"Csetlit" : q := ir_Csetlit(p, st)
	"ProcDecl" : q := ir_ProcDecl(p, st)
	"ProcBody" : q := ir_ProcBody(p, st)
	"ProcCode" : q := ir_ProcCode(p, st)
	"Record" : q := ir_Record(p, st)
	"Repeat" : q := ir_Repeat(p, st)
	"Return" : q := ir_Return(p, st)
	"Fail" : q := ir_Fail(p, st)
	"Suspend" : q := ir_Suspend(p, st)
	"Until" : q := ir_Until(p, st)
	"While" : q := ir_While(p, st)
	"Create" : q := ir_Create(p, st)
	"Ident" : q := ir_Ident(p, st)
	"Next" : q := ir_Next(p, st)
	"Break" : q := ir_Break(p, st)
	"ToBy" : q := ir_ToBy(p, st)
	"Mutual" : q := ir_Mutual(p, st)
	"Compound" : q := ir_Compound(p, st)
	"ListConstructor" : q := ir_ListConstructor(p, st)
	"Key" : q := ir_Key(p, st)
	"Arglist" : q := ir_Arglist(p, st)
	default : runerr(1000, p)
	}
	return q
end

procedure ir_opfn(lhs, op, args, failLabel)
	static neverfail
	initial {
		neverfail := list(3)
		neverfail[1] := set([
			"#", "+", "-", "~", "^", "*", "."
		])
		neverfail[2] := set([
			"+", "-", "*", "/", "%", "^", 
			"++", "--", "**", 
			"||", "|||",
			".", "&"
			# ":=", ":=:" omited because &pos:=*&subject+2 fails
		])
		neverfail[3] := set([ ])
	}
	if \noerror2failure & member(neverfail[op.arity],op.name) then {
		failLabel := &null
	}
	return irOpFunction(lhs, op, args, failLabel)
end

procedure init4ir(p, st)
	p.ir := ir_info()
	p.ir.value := ir_tmp(\st)
	p.ir.start := ir_label(p, "start")
	p.ir.resume := ir_label(p, "resume")
	p.ir.success := ir_label(p, "success")
	p.ir.failure := ir_label(p, "failure")
	return p
end

procedure init4ir_loop(p, st)
	init4ir(p, st)
	p.ir.x := ir_loopinfo()
	p.ir.x.continue := ir_tmploc(st)
	p.ir.x.nextlabel := ir_label(p, "next")
	p.ir.x.scanlevel := *scans
	p.ir.x.in_st := copy(st)
	p.ir.x.out_st := st
	return p
end

procedure ir_label(p, suffix)
	return irLabel(ir_naming(p, suffix))
end

procedure ir_naming(p, suffix)
	local s

	image(p) ? {
		tab(upto(' '))
		move(1)
		s := tab(upto('('))
	}
	return s || "_" || suffix
end

procedure ir_dump(insn)
	return dump(insn, set(["x"]))
end

procedure ir_ident(str)
	return irVar(str)
end

procedure ir_key(str)
	local k

	static keytable
	initial {
		keytable := table()
	}
	k := /keytable[str] := irKey(str)
	return \k | keytable[str]
end

procedure ir_tmp(st)
	st.tmp +:= 1
	/ir_tmptable[st.tmp] := irTmp("tmp" || st.tmp)
	return ir_tmptable[st.tmp]
end

procedure ir_tmploc(st)
	st.lab +:= 1
	/ir_loctable[st.lab] := irTmpLabel("loc" || st.lab)
	return ir_loctable[st.lab]
end

procedure ir_tmp_closure(st)
	st.clo +:= 1
	/ir_clotable[st.clo] := irTmpClosure("clo" || st.clo)
	return ir_clotable[st.clo]
end

procedure make_sentinel(L)
	put(L, init4ir(NoOp()))
	push(L, init4ir(NoOp()))
	return L
end

procedure semantic_error(msg, coord)
	stop("File ", coord.file, "; Line ", coord.line, " # ", msg)
end

procedure max_st(st, t)
	st.tmp <:= t.tmp
	st.lab <:= t.lab
	st.clo <:= t.clo
end
