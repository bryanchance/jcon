global java_create_exists
global java_suspend_flag
global java_declare_set
global java_undeclared_set
global java_function_name
global java_debug
global java_labels
global java_emit_table
global java_invoke_set
global java_invoke_all
global java_link_set
global java_global_set
global java_record_table
global java_proc_table
global java_op_table
global java_tmp_set
global java_tmploc_set
global java_tmpclosure_set
global java_var_set
global java_key_set
global java_args_set

global java_cset_table
global java_real_table
global java_string_table
global java_integer_table

# record irCoord( coord )
procedure gen_java_irCoord(p)
	local s

	s := ""
	s ||:= " file = "   || image(\(\p.coord).file)   || ";"
	s ||:=  "line = "   || image(\(\p.coord).line)   || ";"
	s ||:= " column = " || image(\(\p.coord).column) || ";"
	return s
end

# record irDeref( value )
procedure gen_java_irDeref(p)
	local s, x

	x := gen_java(p.value)
	s := x || ".deref()"
	return s
end

# record irTmp( name )
procedure gen_java_irTmp(p)
	local s

	s := p.name
	insert(java_tmp_set, s)
	return s
end

# record irTmpLabel( name )
procedure gen_java_irTmpLabel(p)
	local s

	s := p.name
	insert(java_tmploc_set, s)
	return s
end

# record irTmpClosure( name )
procedure gen_java_irTmpClosure(p)
	local s

	s := p.name
	insert(java_tmpclosure_set, s)
	return s
end

# record irLabel( value )
procedure gen_java_irLabel(p)
	local s

	s := java_labels[p]
	return s
end

# record irMove( lhs rhs )
procedure gen_java_irMove(p)
	local l, r, s

	\p.lhs | return ""

	l := gen_java(p.lhs)
	r := gen_java(p.rhs)
	case type(p.lhs) of {
	"irKey" |
	"irVar" : {
		s := l || ".Assign(" || r || ".deref());"
		}
	default : {
		s := l || " = " || r || ";"
		}
	}
	return s
end

# record irScanSwap( subject pos )
procedure gen_java_irScanSwap(p)
	local s, subject, pos, Ksubject, Kpos

	Ksubject := gen_java_irKey(irKey("subject"))
	Kpos := gen_java_irKey(irKey("pos"))

	subject := gen_java(p.subject)
	pos := gen_java(p.pos)

	s := "{ vDescriptor subject = " || Ksubject || ".deref(); "
	s ||:= "vDescriptor pos = " || Kpos || ".deref(); "
	s ||:= Ksubject || ".Assign(" || subject || ".deref()); "
	s ||:= Kpos || ".Assign(" || pos || ".deref()); "
	s ||:= subject || " = subject; "
	s ||:= pos || " = pos; "
	s ||:= "}"
	return s
end

# record irGoto( location )
procedure gen_java_irGoto(p)
	local s, t

	t := gen_java(p.location)
	s := "PC = " || t || "; continue; "
	return s
end

# record irVar( name )
procedure gen_java_irVar(p)
	local s

	s := "v$" || p.name
	insert(java_var_set, p.name)
	return s
end

# record irKey( name )
procedure gen_java_irKey(p)
	local s

	s := java_classname || ".$" || p.name
	insert(java_key_set, p.name)
	return s
end

# record irIntLit( val )
procedure gen_java_irIntLit(p)
	local s, i

	i := integer(p.val)
	/java_integer_table[i] := "li$" || map(i, "-", "m")
	s := java_classname || "." || java_integer_table[i]
	return s
end

# record irRealLit( val )
procedure gen_java_irRealLit(p)
	local s, r

	r := real(p.val)
	/java_real_table[r] := "lr$" || map(r, ".-+", "dmp")
	s := java_classname || "." || java_real_table[r]
	return s
end

procedure JavaString(i)
	local v
	static a,t

	initial {
		t := table()
		t[16r0008] := "\\b"
		t[16r0009] := "\\t"
		t[16r000a] := "\\n"
		t[16r000c] := "\\f"
		t[16r000d] := "\\r"
		t[16r0022] := "\\\""
		t[16r0027] := "\\'"
		t[16r005c] := "\\\\"
		a := ["0", "1", "2", "3", "4", "5", "6", "7",
		      "8", "9", "a", "b", "c", "d", "e", "f"]
	}

	i >= 0 | stop("ERROR: ", &file, " ", &line)
	if \t[i] then return t[i]
	v := ""
	while i > 0 do {
		v := a[(i % 16) + 1] || v
		i /:= 16
	}
	v := "\\u" || right(v, 4, "0")
	return v
end

# record irStrLit( val )
procedure gen_java_irStrLit(p)
	local s, v

	v := ""
	every v ||:= JavaString(ord(!p.val))
	/java_string_table[v] := "ls$" || *java_string_table
	s := java_classname || "." || java_string_table[v]
	return s
end

# record irCsetLit( val )
procedure gen_java_irCsetLit(p)
	local s, v

	v := ""
	every v ||:= JavaString(ord(!p.val))
	/java_cset_table[v] := "lc$" || *java_cset_table
	s := java_classname || "." || java_cset_table[v]
	return s
end

# record irSucceed( expr continuation )
procedure gen_java_irSucceed(p)
	local s, e, c

	e := gen_java(p.expr)
	s := ""
	if not (c := gen_java(\p.continuation)) then {
		s ||:= "returned = true; "
	} else {
		s ||:= "this.PC = " || c || "; "
		java_suspend_flag := 1
	}
	s ||:= "retvalue = " || e || "; "
	s ||:= "return;"
	return s
end

# record irFail( )
procedure gen_java_irFail(p)
	local s

	s := "retvalue = null; "
	s ||:= "return;"
	return s
end

# record irRunTimeError( )
procedure gen_java_irRunTimeError(p)
	local s

	s := "iRuntime.error(902);"
	return s
end

# record irResume( closure failLabel retValue )
procedure gen_java_irResume(p)
	local s, c, f, r

	c := gen_java(p.closure)
	f := gen_java(p.failLabel)
	s   := "if (" || c || ".returned) { PC = " || f || "; continue; } "
	s ||:= c || ".resume(); "
	s ||:= "if (" || c || ".retvalue == null) { PC = " || f || "; continue; } "
	if \p.retValue then {
		r := gen_java(p.retValue)
		s ||:= r || " = " || c || ".retvalue; "
	}
	return s
end

# record irMakeList( lhs valueList )
procedure gen_java_irMakeList(p)
	local s, lhs, v, i

	\p.lhs | return ""

	lhs := gen_java(p.lhs)
	s := "{ vDescriptor " || "tmp" || "[] = {"
	every i := 1 to *p.valueList do {
		v := gen_java(p.valueList[i])
		s ||:= v
		if \p.valueList[i+1] then {
			s ||:= ", "
		}
	}
	s ||:= "}; "
	s ||:= lhs || " = " || "iNew.List(tmp); }"
	return s
end

# record irOpClosure( lhs op )
procedure gen_java_irOpClosure(p)
	local s, lhs
	static optable
	initial optable := initoptable()

	\optable[p.op.arity][p.op.name] | runerr(1000, p)

	lhs := gen_java(p.lhs)
	s := lhs || " = rts." || optable[p.op.arity][p.op.name] || ".instance;"
	return s
end

# record irInstallArgs( closure argList )
procedure gen_java_irInstallArgs(p)
	local s, i

	s := gen_java(p.closure)
	s ||:= ".closure("
	every i := 1 to *p.argList do {
		s ||:= gen_java(p.argList[i]) || ", "
	}
	s ||:= "this);"
	return s
end

procedure gen_java_call_op(p)
	local s, l, f, v, n, i

	type(p.fn) == "irOperator" | stop("internal error ", image(&file), " ", image(&line))

	l := gen_java(p.lhs)
	f := gen_java(p.fn)

	s := l || " = " || f || ".instantiate("
	every i := 1 to *p.argList do {
		v := gen_java(p.argList[i])
		s ||:= v || ", "
	}
	s ||:= "this); "
	return s
end

# record irMakeClosure( lhs fn argList )
procedure gen_java_irMakeClosure(p)
	local s, l, f, v, n, i

	\p.lhs | return ""

	if type(p.fn) == "irOperator" then {
		return gen_java_call_op(p)
	}

	l := gen_java(p.lhs)
	f := gen_java(p.fn)

	n := (image(p) ? ( ="record ", tab(upto('(')) ))
	n ||:= "_args"
	insert(java_args_set, n)
	s := "if (" || n || " == null) {"
	s ||:= n || " = new vDescriptor[" || *p.argList || "]; "
	s ||:= "} "
	every i := 1 to *p.argList do {
		v := gen_java(p.argList[i])
		s ||:= n || "[" || i-1 || "] = " || v || "; "
	}
	s ||:= l || " = iInterface.Instantiate(" || f || ", " || n || ", this); "
	return s
end

# record irOperator( name arity )
procedure gen_java_irOperator(p)
	local s, n

	n := p.name || "," || p.arity
	/java_op_table[n] := "proc_" || *java_op_table
	s := java_classname || "." || java_op_table[n]
	return s
end

# record irCreate( location )
procedure gen_java_irCreate(p)
	local s, l

	l := gen_java(p.location)
	java_create_exists := 1
	s := "iCoexp.create(this.copy(" || l || "))"
	return s
end

# record irCoRet( value continuation )
procedure gen_java_irCoRet(p)
	local s, v, c

	v := gen_java(p.value)
	c := gen_java(p.continuation)
	s := "iEnv.cur_coexp.coret(" || v || ");"
	s ||:= " PC = " || c || "; continue;"
	return s
end

# record irCoFail( )
procedure gen_java_irCoFail(p)
	local s

	s := "iEnv.cur_coexp.cofail(); /* never returns */"
	return s
end

# record irEnterInit( startlabel )
procedure gen_java_irEnterInit(p)
	local s, l

	l := gen_java(p.startlabel)
	s := "prologue();"
	s ||:= " if (initialized) { PC = " || l || "; continue; }"
	s ||:= " initialized = true;"
	return s
end

procedure gen_java(p)
	case type(p) of {
	"irCoord" : return gen_java_irCoord(p)
	"irDeref" : return gen_java_irDeref(p)
	"irTmp" : return gen_java_irTmp(p)
	"irTmpLabel" : return gen_java_irTmpLabel(p)
	"irTmpClosure" : return gen_java_irTmpClosure(p)
	"irLabel" : return gen_java_irLabel(p)
	"irMove" : return gen_java_irMove(p)
	"irScanSwap" : return gen_java_irScanSwap(p)
	"irGoto" : return gen_java_irGoto(p)
	"irVar" : return gen_java_irVar(p)
	"irKey" : return gen_java_irKey(p)
	"irIntLit" : return gen_java_irIntLit(p)
	"irRealLit" : return gen_java_irRealLit(p)
	"irStrLit" : return gen_java_irStrLit(p)
	"irCsetLit" : return gen_java_irCsetLit(p)
	"irSucceed" : return gen_java_irSucceed(p)
	"irFail" : return gen_java_irFail(p)
	"irResume" : return gen_java_irResume(p)
	"irMakeList" : return gen_java_irMakeList(p)
	"irMakeClosure" : return gen_java_irMakeClosure(p)
	"irOpClosure" : return gen_java_irOpClosure(p)
	"irInstallArgs" : return gen_java_irInstallArgs(p)
	"irOperator" : return gen_java_irOperator(p)
	"irCreate" : return gen_java_irCreate(p)
	"irCoRet" : return gen_java_irCoRet(p)
	"irCoFail" : return gen_java_irCoFail(p)
	"irRunTimeError" : return gen_java_irRunTimeError(p)
	"irEnterInit" : return gen_java_irEnterInit(p)
	default : {
		write(&errout, "ERROR in gen_java: ", image(type(p)), "[", image(p), "]")
		runerr(1000);
		}
	}
end

procedure java_emit(label, code)
	return java_emit_table[label] := code
end

procedure java_invocables(all, L)
	every insert(java_invoke_set, !L)
	java_invoke_all := \all
end

procedure java_links(L)
	every insert(java_link_set, !L)
end

procedure java_records(name, fields, coord)
	if member(java_declare_set, name) then {
		semantic_error(image(name) || ": inconsistent redeclaration", coord)
	}
	insert(java_declare_set, name)

	java_record_table[name] := fields
end

procedure java_globals(L)
	every insert(java_global_set, !L)
end

procedure java_gen_temporaries()
	every write(outfile, "\tvDescriptor[] ", !java_args_set, ";")
	every write(outfile, "\tvDescriptor ", !java_tmp_set, ";")
	every write(outfile, "\tiClosure ", !java_tmpclosure_set, ";")
	every write(outfile, "\tint ", !java_tmploc_set, ";")
	write(outfile);
end

procedure java_init_temporaries()
	every write(outfile, "\t", !java_args_set, " = null;")
	every write(outfile, "\t", !java_tmp_set, " = null;")
	every write(outfile, "\t", !java_tmpclosure_set, " = null;")
	every write(outfile, "\t", !java_tmploc_set, " = 0;")
	write(outfile);
end

procedure java_function(name, params, accumulate, locals, statics, code, coord)
	local undeclared, sortedvars, op, i, classname, k, insns, nextval

	if member(java_declare_set, name) then {
		semantic_error(image(name) || ": inconsistent redeclaration", coord)
	}
	insert(java_declare_set, name)

	java_function_name := "p_" || java_classname || "$" || name
	java_proc_table[name] := if /accumulate then *params else -*params
	write(outfile, "public class p_" || java_classname || "$", name, " extends iClosure {")
	write(outfile)
	write(outfile, "\tstatic boolean initialized = false;")

	java_args_set := set();

	java_tmp_set := set([])
	java_tmploc_set := set([])
	java_tmpclosure_set := set([])
	java_var_set := set([])
	java_emit_table := table()
	java_create_exists := &null
	java_suspend_flag := &null

	ir(code)

	java_labels := table()
	java_labels[code.ir.start] := 1
	java_emit_table := optimize(java_emit_table, code.ir.start)
	every k := key(java_emit_table) do {
		/java_labels[k] := *java_labels + 1
	}


	every k := !statics do {
		every write(outfile, "\tstatic vVariable v$", k, " = iNew.SimpleVar(", image(k), "); // static")
	}
	write(outfile)

	nextval := ""
	nextval ||:= "\t\tint PC = this.PC;\n"
	nextval ||:= "\t\tfor (;;) {\n"
	nextval ||:= "\t\t\tswitch (PC) {\n"
	nextval ||:= "\t\t\tdefault: iRuntime.error(902);\n"
	every k := key(java_emit_table) do {
		nextval ||:= "\t\t\tcase " || java_labels[k] || ": // " || k.value || "\n"
		if \java_debug then {
			nextval ||:= "\t\t\t\tSystem.out.println(" || image(k.value) || ");" || "\n"
		}
		insns := java_emit_table[k]
		every nextval ||:= "\t\t\t\t" || gen_java(!insns) || "\n"
	}
	nextval ||:= "\t\t\t}\n"
	nextval ||:= "\t\t}\n"

	write(outfile, "\tpublic void nextval() {")
	if /java_suspend_flag & &fail then {
		java_gen_temporaries()
		java_init_temporaries()
	}
	write(outfile, nextval)
	write(outfile, "\t} // nextval()")
	write(outfile);

	if 1 | \java_suspend_flag then {
		java_gen_temporaries()
	}

	undeclared := java_var_set -- set(params) -- set(locals) -- set(statics)
	every insert(java_undeclared_set, !undeclared)
	every write(outfile, "\tvVariable v$", !params, "; // parameter")
	every write(outfile, "\tvVariable v$", !locals, "; // local")
	every write(outfile, "\tvVariable v$", !undeclared, "; // undeclared")
	write(outfile);

	sortedvars := sort(java_var_set ++ set(params) ++ set(locals) ++ set(statics))
	write(outfile, "\tpublic void locals() {")
	write(outfile, "\t\tint i = 0;")
	write(outfile, "\t\tnames = new String[", *sortedvars+1, "];")
	write(outfile, "\t\tvariables = new vVariable[", *sortedvars+1, "];")
	every k := !sortedvars do {
		if member(undeclared, k) then {
			writes(outfile, "\t\tif (", java_classname, ".v$", k, "$ == null) {")
			writes(outfile, " names[i] = ", image(k), ";")
			writes(outfile, " variables[i] = v$", k, ";")
			writes(outfile, " i++;")
			write(outfile, " }")
		} else {
			writes(outfile, "\t\tnames[i] = ", image(k), ";")
			writes(outfile, " variables[i] = v$", k, ";")
			write(outfile, " i++;")
		}
	}
	writes(outfile, "\t\tnames[i] = null; ")
	write(outfile, " variables[i] = null;")

	write(outfile, "\t} // locals ")
	write(outfile)

	write(outfile, "\tpublic void prologue() {")
	write(outfile, "\t\tcreateVars();")
	if *params > 0 then {
		write(outfile, "\t\targuments = iInterface.marshall(arguments, ", *params, ", ", if \accumulate then "true" else "false", ");")
	}
	every i := 1 to *params do {
		k := params[i]
		write(outfile, "\t\tv$", k, ".Assign(arguments[", i-1, "].deref());")
	}
	write(outfile, "\t} // prologue()")
	write(outfile)

	write(outfile, "\tpublic void createVars() {")
	every i := 1 to *params do {
		k := params[i]
		write(outfile, "\t\tv$", k, " = iNew.SimpleVar(", image(k), "); // parameter")
	}
	every k := !locals do {
		write(outfile, "\t\tv$", k, " = iNew.SimpleVar(", image(k), "); // local variable ")
	}
	every k := !undeclared do {
		write(outfile, "\t\tv$", k, " = (", java_classname, ".v$", k, "$ == null) ? iNew.SimpleVar(", image(k), ") : ", java_classname, ".v$", k, "$;")
	}
	write(outfile, "\t} // createVars()")
	write(outfile)

	classname := "p_" || java_classname || "$" || name

	if \java_create_exists then {
		write(outfile, "\tpublic iClosure copy(int PC) {")
		write(outfile, "\t\t", classname, " New = new ", classname, "();")
		write(outfile, "\t\tNew.createVars();")
		every k := !params | !locals do {
			write(outfile, "\t\tNew.v$", k, ".Assign(v$", k, ".deref());")
		}
		every k := !undeclared do {
			writes(outfile, "\t\tif (", java_classname, ".v$", k, "$ == null) ")
			write(outfile, " New.v$", k, ".Assign(v$", k, ".deref());")
		}
		write(outfile, "\t\tNew.PC = PC;")
		write(outfile, "\t\treturn New;")
		write(outfile, "\t} // copy()")
		write(outfile)
	}


	write(outfile, "} // ", name)
	write(outfile)
end

procedure java_File(getline, flagList)
	local k, i, op

	outfile := &output
	if "-debug" == !flagList then {
		java_debug := 1
	}
	if match("-O", !flagList) then {
		optimize_flag := 1
	}
	write(outfile, "import rts.*;")
	write(outfile)

	java_invoke_set := set([])
	java_invoke_all := &null
	java_link_set := set([])
	java_global_set := set([])
	java_proc_table := table()
	java_key_set := set([])
	java_record_table := table()
	java_undeclared_set := set([])
	java_key_set := set([])
	java_op_table := table()
	java_declare_set := set([])

	java_cset_table := table()
	java_string_table := table()
	java_integer_table := table()
	java_real_table := table()

	parse(getline)

	write(outfile, "public class ", java_classname, " extends iFile {")
	write(outfile, "\tpublic void declare() {")

	every k := !java_global_set do {
		write(outfile, "\t\tiEnv.declareGlobal(", image(k), ");")
	}

	every k := key(java_proc_table) do {
		write(outfile, "\t\tiEnv.declareProcedure(", image(k), ", ",
			image("p_" || java_classname || "$" || k), ", ", java_proc_table[k], ");")
	}

	every k := key(java_record_table) do {
		writes(outfile, "\t\t{ String[] fields = { ")
		every i := 1 to *java_record_table[k] do {
			writes(outfile, image(java_record_table[k][i]))
			if \java_record_table[k][i+1] then writes(outfile, ", ")
		}
		write(outfile, " };")
		write(outfile, "\t\tiEnv.declareRecord(", image(k), ", fields); }")
	}

	write(outfile, "\t} // declare()")
	write(outfile)

	write(outfile, "\tpublic void unresolved() {")
	every k := !java_invoke_set do {
		write(outfile, "\t\tiEnv.declareInvoke(", image(k), ");")
	}
	if \java_invoke_all then {
		write(outfile, "\t\tiEnv.declareInvokeAll();")
	}
	every k := !java_undeclared_set do {
		write(outfile, "\t\tiEnv.undeclared(", image(k), "); // undeclared variable")
	}
	write(outfile, "\t} // unresolved()")
	write(outfile)

	if *java_link_set > 0 then {
		write(outfile, "\tstatic boolean linked = false;")
		write(outfile, "\tpublic void link() {")
		write(outfile, "\t\tif (linked) return;")
		write(outfile, "\t\tlinked = true;")
		every k := !java_link_set do {
			write(outfile, "\t\tiInterface.link(", image("l$" || k), ");")
			write(outfile, "//JCON//links:", k)
		}
		write(outfile, "\t} // link()")
		write(outfile)
	}

	write(outfile, "\tpublic void resolve() {")
	every k := !java_undeclared_set do {
		write(outfile, "\t\tv$", k, "$ = iEnv.resolve(", image(k), "); // undeclared variable")
	}
	every k := !java_key_set do {
		write(outfile, "\t\t$", k, " = iEnv.resolveKey(", image(k), ");")
	}
	every k := key(java_op_table) do {
		k ? {
			op := tab(upto(','))
			move(1)
			args := tab(0)
		}
		write(outfile, "\t\t", java_op_table[k], " = iEnv.resolveProc(", image(op), ", ", args, ");")
	}
	write(outfile, "\t} // resolve()")
	write(outfile)

	every write(outfile, "\tstatic vVariable v$", !java_undeclared_set, "$;")
	every write(outfile, "\tstatic vDescriptor $", !java_key_set, ";")
	every write(outfile, "\tstatic vDescriptor ", !java_op_table, ";")
	write(outfile)

	every k := key(java_real_table) do {
		write(outfile, "\tstatic vReal ", java_real_table[k], " = iNew.Real(", k, ");")
	}
	every k := key(java_integer_table) do {
		write(outfile, "\tstatic vInteger ", java_integer_table[k], " = iNew.Integer(", k, "L);")
	}
	every k := key(java_string_table) do {
		write(outfile, "\tstatic vString ", java_string_table[k], " = iNew.String(\"", k, "\");")
	}
	every k := key(java_cset_table) do {
		write(outfile, "\tstatic vCset ", java_cset_table[k], " = iNew.Cset(\"", k, "\");")
	}
	write(outfile)

	write(outfile, "} // file")
end

procedure java_CG()
	return code_gen(java_emit,
			java_globals,
			java_invocables,
			java_links,
			java_function,
			java_records,
			java_File
			)
end
