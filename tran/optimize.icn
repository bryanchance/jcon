#  optimize.icn -- intermediate representation optimizer routines.

global optim_optimize_flag

procedure optim_optimize(t, start)
    local new, i

    new := t
    if \optim_optimize_flag then {
        new := optim_free_elimination(new, start)
        new := optim_dead_assignment(new, start)
        new := optim_goto_elimination(new, start)
        new := optim_copy_propagation(new, start)
    }
    return new
end

procedure optim_dead_assignment(t, start)
    local k, chunk, new, c, i

    new := table()
    every k := key(t) & chunk := t[k] do {
        c := []
        every i := !chunk do {
            if (type(i) == "ir_Move") & /i.lhs then {
                next
            }
            put(c, i)
        }
        new[k] := c
    }
    return new
end

procedure optim_free_elimination(t, start)
    local new, c, i, lab

    new := table()
    every lab := key(t) do {
        c := t[lab]
        new[lab] := []
        every i := !c do {
            if (type(i) ~== "ir_Free")
	       # | (*i.v.tmp > 0)
	       # | (*i.v.lab > 0)
               then {
                put(new[lab], i)
            }
        }
    }
    return new
end

procedure optim_copy_propagation(t, start)
    local rename, uses, defs, chunk, insn, newchunk, changes
    local k, i

    repeat {
        changes := &null
        uses := table(0)
        defs := table(0)
        every chunk := !t do {
            every insn := !chunk do {
                optim_def_use(insn, &null, uses, defs)
            }
        }
        rename := table()
        every k := key(t) & chunk := t[k] do {
            newchunk := []
            every insn := !chunk do {
                if type(insn) == "ir_Move" &
                   defs[insn.lhs] = 1 &
                   type(insn.lhs) == "ir_Tmp" &
                   (
                   (uses[insn.rhs] = 1 &
                   type(insn.rhs) == "ir_Tmp") |
                   type(insn.rhs) == ("ir_Var" |
                        "ir_Key" |
                        "ir_IntLit" |
                        "ir_RealLit" |
                        "ir_StrLit" |
                        "ir_CsetLit")
                   )
                   then {
                    rename[insn.lhs] := insn.rhs
                    changes := 1
                } else {
                    put(newchunk, insn)
                }
            }
            t[k] := newchunk
        }
        if /changes then break;
        every chunk := !t do {
            every i := 1 to *chunk do {
                chunk[i] := optim_rewrite(chunk[i], rename)
            }
        }
    }
    return t
end

procedure optim_def_use(p, this, uses, defs)
    case type(p) of {
    "ir_Free" :  { }
    "ir_Deref" : { optim_def_use(p.value, uses, uses, defs) }
    "ir_Tmp" :   { this[p]+:=1 }
    "ir_TmpLabel" :  { this[p]+:=1 }
    "ir_Label" : { this[p]+:=1 }
    "ir_Field" : { optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.expr, uses, uses, defs) }
    "ir_Move" :  { optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.rhs, uses, uses, defs) }
    "ir_ScanSwap" :  { optim_def_use(p.subject, defs, uses, defs);
            optim_def_use(p.subject, uses, uses, defs);
            optim_def_use(p.pos, defs, uses, defs);
            optim_def_use(p.pos, uses, uses, defs); }
    "ir_Goto" :  { optim_def_use(p.location, uses, uses, defs); }
    "ir_Var" :   { this[p]+:=1 }
    "ir_Key" :   { this[p]+:=1 }
    "ir_IntLit" :    { this[p]+:=1 }
    "ir_RealLit" :   { this[p]+:=1 }
    "ir_StrLit" :    { this[p]+:=1 }
    "ir_CsetLit" :   { this[p]+:=1 }
    "ir_Succeed" :   { optim_def_use(p.expr, uses, uses, defs);
            optim_def_use(\p.continuation, uses, uses, defs); }
    "ir_Fail" :  { }
    "ir_ResumeValue" :    { optim_def_use(p.value, uses, uses, defs);
            optim_def_use(p.failLabel, uses, uses, defs);
            optim_def_use(\p.retValue, defs, uses, defs); }
    "ir_MakeList" :  { optim_def_use(\p.lhs, defs, uses, defs);
            every optim_def_use(!p.valueList, uses, uses, defs); }
    "ir_Call" |
    "ir_OpFunction":{optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.fn, uses, uses, defs);
            optim_def_use(\p.failLabel, uses, uses, defs);
            every optim_def_use(!p.argList, uses, uses, defs); }
    "ir_Operator" :  { this[p]+:=1 }
    "ir_Create" :    {
	    optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.location, uses,uses, defs);}
    "ir_CoRet" : { optim_def_use(p.value, uses, uses, defs);
            optim_def_use(p.continuation, uses, uses, defs); }
    "ir_Restore" :   { }
    "ir_CoFail" :    { }
    "ir_RunTimeError":{ }
    "ir_EnterInit" : { optim_def_use(p.startlabel, uses, uses, defs) }

    default :   { runerr(500, p); }
    }
end

procedure optim_rewrite(p, rename)
    local i

    if member(rename, p) then {
        return optim_rewrite(rename[p], rename)
    }
    case type(p) of {
    "ir_Deref" : { p.value := optim_rewrite(p.value, rename); }
    "ir_Free" :  { }
    "ir_Tmp" :   { }
    "ir_TmpLabel" :  { }
    "ir_Label" : { }
    "ir_Move" :  { p.lhs := optim_rewrite(\p.lhs, rename);
            p.rhs := optim_rewrite(p.rhs, rename) }
    "ir_ScanSwap" :  { }
    "ir_Goto" :  { }
    "ir_Var" :   { }
    "ir_Key" :   { }
    "ir_IntLit" :    { }
    "ir_RealLit" :   { }
    "ir_StrLit" :    { }
    "ir_CsetLit" :   { }
    "ir_Restore" :   { }
    "ir_Succeed" :   { p.expr := optim_rewrite(p.expr, rename);
            p.continuation := optim_rewrite(\p.continuation, rename); }
    "ir_Fail" :  { }
    "ir_ResumeValue" :    { p.value := optim_rewrite(p.value, rename);
            p.failLabel := optim_rewrite(p.failLabel, rename);
            p.retValue := optim_rewrite(\p.retValue, rename); }
    "ir_MakeList" :  { p.lhs := optim_rewrite(\p.lhs, rename);
            every i := 1 to *p.valueList do {
                p.valueList[i] := optim_rewrite(p.valueList[i],
                                  rename); }
            }
    "ir_Field" : { p.lhs := optim_rewrite(\p.lhs, rename)
            p.expr := optim_rewrite(p.expr, rename)
            p.failLabel := optim_rewrite(\p.failLabel, rename)
            }
    "ir_Call" |
    "ir_OpFunction":{p.lhs := optim_rewrite(\p.lhs, rename);
            p.fn := optim_rewrite(p.fn, rename); 
            every i := 1 to *p.argList do {
                p.argList[i] := optim_rewrite(p.argList[i],
                                rename); }
            p.failLabel := optim_rewrite(\p.failLabel, rename);
            }
    "ir_Operator" :  { }
    "ir_Create" :    {
            p.lhs := optim_rewrite(\p.lhs, rename);
	    p.location := optim_rewrite(p.location, rename); }
    "ir_CoRet" : { p.value := optim_rewrite(p.value, rename);
            p.continuation := optim_rewrite(p.continuation, rename);}
    "ir_CoFail" :    { }
    "ir_RunTimeError":{ }
    "ir_EnterInit" : { p.startlabel := optim_rewrite(p.startlabel, rename) }

    default :   { runerr(500,p); }
    }
    return p;
end

procedure optim_goto_elimination(t, start)
    local new, i

    new := table()
    optim_goto_transitive(t, new, start)
    optim_test_elimination(new, start)
    if i := new[start] &
       type(i[1]) == "ir_EnterInit" &
       type(i[2]) == "ir_Goto" &
       i[1].startlabel === i[2].location then {
        new[start] := [ i[2] ]
    }
    optim_fallthrough(new)
    return new
end

procedure optim_fallthrough(new)
    local lab, insn, chunk, refcount

    refcount := optim_refcount(new)

    every lab := key(new) do {
        while chunk := \new[lab] &
              insn := chunk[-1] &
              type(insn) == "ir_Goto" &
              type(insn.location) == "ir_Label" &
              refcount[insn.location] = 1 do {
            \new[insn.location] | runerr(500, insn.location)
            new[lab] := chunk[1:-1] ||| new[insn.location]
            delete(new, insn.location)
        }
    }
end

procedure optim_refcount(t)
    local refcount

    refcount := table(0)
    every optim_refcountX(refcount, !!t)
    return refcount
end


procedure optim_goto_chain(lab, t)
    local chunk, seen

    seen := set([])
    while chunk := \t[lab] &
	  type(chunk[1]) == "ir_Goto" &
	  not member(seen, chunk[1].location) do {
        lab := chunk[1].location
        insert(seen, lab)
    }
    return lab
end

procedure optim_goto_chain_defer(lab, t)
    local chunk, seen

    seen := set([])
    while chunk := \t[lab] &
          type(chunk[1]) == "ir_Goto" &
	  not member(seen, chunk[1].location) &
          type(chunk[1].location) ~== "ir_TmpLabel" do {
        lab := chunk[1].location
        insert(seen, lab)
    }
    return lab
end

procedure optim_goto_transitive(t, new, lab)
    local p

    if /t[lab] | \new[lab] then {
	return
    }
    new[lab] := t[lab]

    every p := !t[lab] do {
	    case type(p) of {
	    "ir_Free" |
	    "ir_Restore" |
	    "ir_CoFail" |
	    "ir_RunTimeError" |
	    "ir_MakeList" |
	    "ir_Operator" |
	    "ir_Fail" |
	    "ir_Var" |
	    "ir_Key" |
	    "ir_IntLit" |
	    "ir_RealLit" |
	    "ir_StrLit" |
	    "ir_CsetLit" |
	    "ir_ScanSwap" |
	    "ir_Tmp" |
	    "ir_TmpLabel" |
	    "ir_Deref" : {
		# nothing
		}
	    "ir_Label" : {  # ir_Label : ( value )
		}
	    "ir_Move" : {  # ir_Move : ( lhs rhs )
		p.rhs := optim_goto_chain_defer(p.rhs, t)
		optim_goto_transitive(t, new, p.rhs)
		}
	    "ir_Goto" : {  # ir_Goto : ( location )
		p.location := optim_goto_chain(p.location, t)
		optim_goto_transitive(t, new, p.location)
		}
	    "ir_Succeed" : {  # ir_Succeed : ( expr continuation )
		p.continuation := optim_goto_chain(\p.continuation, t)
		optim_goto_transitive(t, new, \p.continuation)
		}
	    "ir_Field" : {  # ir_Field : ( lhs expr field failLabel )
		p.failLabel := optim_goto_chain(\p.failLabel, t)
		optim_goto_transitive(t, new, \p.failLabel)
		}
	    "ir_Call" |
	    "ir_OpFunction" : {  # ir_OpFunction : ( lhs fn argList failLabel )
		p.failLabel := optim_goto_chain(\p.failLabel, t)
		optim_goto_transitive(t, new, \p.failLabel)
		}
	    "ir_ResumeValue" : {  # ir_ResumeValue : ( value failLabel retValue )
		p.failLabel := optim_goto_chain(p.failLabel, t)
		optim_goto_transitive(t, new, p.failLabel)
		}
	    "ir_Create" : {  # ir_Create : ( lhs location )
		p.location := optim_goto_chain_defer(p.location, t)
		optim_goto_transitive(t, new, p.location)
		}
	    "ir_CoRet" : {  # ir_CoRet : ( value continuation )
		p.continuation := optim_goto_chain(p.continuation, t)
		optim_goto_transitive(t, new, p.continuation)
		}
	    "ir_EnterInit" : {  # ir_EnterInit : ( startlabel )
		p.startlabel := optim_goto_chain(p.startlabel, t)
		optim_goto_transitive(t, new, p.startlabel)
		}
	    default : runerr(500, p)
	    }
    }
end

procedure optim_refcountX(refcount, p)
    case type(p) of {
    "ir_Free" |
    "ir_Restore" |
    "ir_CoFail" |
    "ir_RunTimeError" |
    "ir_MakeList" |
    "ir_Operator" |
    "ir_Fail" |
    "ir_Var" |
    "ir_Key" |
    "ir_IntLit" |
    "ir_RealLit" |
    "ir_StrLit" |
    "ir_CsetLit" |
    "ir_ScanSwap" |
    "ir_Tmp" |
    "ir_TmpLabel" |
    "ir_Deref" : {
	# nothing
        }
    "ir_Label" : {  # ir_Label : ( value )
        }
    "ir_Move" : {  # ir_Move : ( lhs rhs )
	refcount[p.rhs] +:= 1
        }
    "ir_Goto" : {  # ir_Goto : ( location )
	refcount[p.location] +:= 1
        }
    "ir_Succeed" : {  # ir_Succeed : ( expr continuation )
	refcount[p.continuation] +:= 1
        }
    "ir_Field" : {  # ir_Field : ( lhs expr field failLabel )
	refcount[p.failLabel] +:= 1
        }
    "ir_Call" |
    "ir_OpFunction" : {  # ir_OpFunction : ( lhs fn argList failLabel )
	refcount[p.failLabel] +:= 1
        }
    "ir_ResumeValue" : {  # ir_ResumeValue : ( value failLabel retValue )
	refcount[p.failLabel] +:= 1
        }
    "ir_Create" : {  # ir_Create : ( lhs location )
	refcount[p.location] +:= 1
        }
    "ir_CoRet" : {  # ir_CoRet : ( value continuation )
	refcount[p.continuation] +:= 1
        }
    "ir_EnterInit" : {  # ir_EnterInit : ( startlabel )
	refcount[p.startlabel] +:= 1
        }
    default : runerr(500, p)
    }
end

procedure optim_test_elimination(t, start)
	local chunk

	every chunk := !t &
	      type(chunk[-1]) == "ir_Goto" &
	      type(chunk[-2]) == ("ir_Call" | "ir_OpFunction") &
	      chunk[-1].location === \chunk[-2].failLabel do {
	    chunk[-2].failLabel := &null
	}
end

