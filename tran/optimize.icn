#  optimize.icn -- intermediate representation optimizer routines.

global optim_optimize_flag
global optim_refcount

procedure optim_optimize(t, start)
    local new, i

    new := t
    if \optim_optimize_flag then {
        new := optim_free_elimination(new, start)
        new := optim_dead_assignment(new, start)
        new := optim_goto_elimination(new, start)
        new := optim_copy_propagation(new, start)
        # new := optim_coord_elimination(new, start)
    }
    if i := new[start] &
       type(i[1]) == "ir_EnterInit" &
       type(i[2]) == "ir_Goto" &
       i[1].startlabel === i[2].location then {
        new[start] := [ i[2] ]
    }
    return new
end

procedure optim_dead_assignment(t, start)
    local k, chunk, new, c, i

    new := table()
    every k := key(t) & chunk := t[k] do {
        c := []
        every i := !chunk do {
            if (type(i) == "ir_Move") & /i.lhs then {
                next
            }
            put(c, i)
        }
        new[k] := c
    }
    return new
end

procedure optim_free_elimination(t, start)
    local new, c, i, lab

    new := table()
    every lab := key(t) do {
        c := t[lab]
        new[lab] := []
        every i := !c do {
            if (type(i) ~== "ir_Free")
	       # | (*i.v.tmp > 0)
	       # | (*i.v.lab > 0)
               then {
                put(new[lab], i)
            }
        }
    }
    return new
end

procedure optim_coord_elimination(t, start)
    local file, line, column, insn, coord, chunk

    every chunk := !t do {
        file := "";
        line := 0;
        column := 0;
        every insn := !chunk &
              type(insn) == "ir_Coord" &
              coord := copy(\insn.coord) do {
            if file == coord.file then {
                coord.file := &null
            } else {
                file := coord.file
            }
            if line = coord.line then {
                coord.line := &null
            } else {
                line := coord.line
            }
            if column = coord.column then {
                coord.column := &null
            } else {
                column := coord.column
            }
            insn.coord := coord
        }
    }
end

procedure optim_copy_propagation(t, start)
    local rename, uses, defs, chunk, insn, newchunk, changes
    local k, i

    repeat {
        changes := &null
        uses := table(0)
        defs := table(0)
        every chunk := !t do {
            every insn := !chunk do {
                optim_def_use(insn, &null, uses, defs)
            }
        }
        rename := table()
        every k := key(t) & chunk := t[k] do {
            newchunk := []
            every insn := !chunk do {
                if type(insn) == "ir_Move" &
                   defs[insn.lhs] = 1 &
                   type(insn.lhs) == "ir_Tmp" &
                   (
                   (uses[insn.rhs] = 1 &
                   type(insn.rhs) == "ir_Tmp") |
                   type(insn.rhs) == ("ir_Var" |
                        "ir_Key" |
                        "ir_IntLit" |
                        "ir_RealLit" |
                        "ir_StrLit" |
                        "ir_CsetLit")
                   )
                   then {
                    rename[insn.lhs] := insn.rhs
                    changes := 1
                } else {
                    put(newchunk, insn)
                }
            }
            t[k] := newchunk
        }
        if /changes then break;
        every chunk := !t do {
            every i := 1 to *chunk do {
                chunk[i] := optim_rewrite(chunk[i], rename)
            }
        }
    }
    return t
end

procedure optim_def_use(p, this, uses, defs)
    case type(p) of {
    "ir_Free" :  { }
    "ir_Deref" : { optim_def_use(p.value, uses, uses, defs) }
    "ir_Tmp" :   { this[p]+:=1 }
    "ir_TmpLabel" :  { this[p]+:=1 }
    "ir_Label" : { this[p]+:=1 }
    "ir_Field" : { optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.expr, uses, uses, defs) }
    "ir_Move" :  { optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.rhs, uses, uses, defs) }
    "ir_ScanSwap" :  { optim_def_use(p.subject, defs, uses, defs);
            optim_def_use(p.subject, uses, uses, defs);
            optim_def_use(p.pos, defs, uses, defs);
            optim_def_use(p.pos, uses, uses, defs); }
    "ir_Goto" :  { optim_def_use(p.location, uses, uses, defs); }
    "ir_Var" :   { this[p]+:=1 }
    "ir_Key" :   { this[p]+:=1 }
    "ir_IntLit" :    { this[p]+:=1 }
    "ir_RealLit" :   { this[p]+:=1 }
    "ir_StrLit" :    { this[p]+:=1 }
    "ir_CsetLit" :   { this[p]+:=1 }
    "ir_Succeed" :   { optim_def_use(p.expr, uses, uses, defs);
            optim_def_use(\p.continuation, uses, uses, defs); }
    "ir_Fail" :  { }
    "ir_ResumeValue" :    { optim_def_use(p.value, uses, uses, defs);
            optim_def_use(p.failLabel, uses, uses, defs);
            optim_def_use(\p.retValue, defs, uses, defs); }
    "ir_MakeList" :  { optim_def_use(\p.lhs, defs, uses, defs);
            every optim_def_use(!p.valueList, uses, uses, defs); }
    "ir_Call" |
    "ir_OpFunction":{optim_def_use(\p.lhs, defs, uses, defs);
            optim_def_use(p.fn, uses, uses, defs);
            optim_def_use(\p.failLabel, uses, uses, defs);
            every optim_def_use(!p.argList, uses, uses, defs); }
    "ir_Operator" :  { this[p]+:=1 }
    "ir_Create" :    { this[p]+:=1; optim_def_use(p.location, uses,uses, defs);}
    "ir_CoRet" : { optim_def_use(p.value, uses, uses, defs);
            optim_def_use(p.continuation, uses, uses, defs); }
    "ir_Restore" :   { }
    "ir_CoFail" :    { }
    "ir_RunTimeError":{ }
    "ir_EnterInit" : { optim_def_use(p.startlabel, uses, uses, defs) }
    "ir_Coord" : { }

    default :   { runerr(500, p); }
    }
end

procedure optim_rewrite(p, rename)
    local i

    if member(rename, p) then {
        return optim_rewrite(rename[p], rename)
    }
    case type(p) of {
    "ir_Deref" : { p.value := optim_rewrite(p.value, rename); }
    "ir_Free" :  { }
    "ir_Tmp" :   { }
    "ir_TmpLabel" :  { }
    "ir_Label" : { }
    "ir_Move" :  { p.lhs := optim_rewrite(\p.lhs, rename);
            p.rhs := optim_rewrite(p.rhs, rename) }
    "ir_ScanSwap" :  { }
    "ir_Goto" :  { }
    "ir_Var" :   { }
    "ir_Key" :   { }
    "ir_IntLit" :    { }
    "ir_RealLit" :   { }
    "ir_StrLit" :    { }
    "ir_CsetLit" :   { }
    "ir_Restore" :   { }
    "ir_Succeed" :   { p.expr := optim_rewrite(p.expr, rename);
            p.continuation := optim_rewrite(\p.continuation, rename); }
    "ir_Fail" :  { }
    "ir_ResumeValue" :    { p.value := optim_rewrite(p.value, rename);
            p.failLabel := optim_rewrite(p.failLabel, rename);
            p.retValue := optim_rewrite(\p.retValue, rename); }
    "ir_MakeList" :  { p.lhs := optim_rewrite(\p.lhs, rename);
            every i := 1 to *p.valueList do {
                p.valueList[i] := optim_rewrite(p.valueList[i],
                                  rename); }
            }
    "ir_Field" : { p.lhs := optim_rewrite(\p.lhs, rename)
            p.expr := optim_rewrite(p.expr, rename)
            p.failLabel := optim_rewrite(\p.failLabel, rename)
            }
    "ir_Call" |
    "ir_OpFunction":{p.lhs := optim_rewrite(\p.lhs, rename);
            p.fn := optim_rewrite(p.fn, rename); 
            every i := 1 to *p.argList do {
                p.argList[i] := optim_rewrite(p.argList[i],
                                rename); }
            p.failLabel := optim_rewrite(\p.failLabel, rename);
            }
    "ir_Operator" :  { }
    "ir_Create" :    { p.location := optim_rewrite(p.location, rename); }
    "ir_CoRet" : { p.value := optim_rewrite(p.value, rename);
            p.continuation := optim_rewrite(p.continuation, rename);}
    "ir_CoFail" :    { }
    "ir_RunTimeError":{ }
    "ir_EnterInit" : { p.startlabel := optim_rewrite(p.startlabel, rename) }
    "ir_Coord" : { }

    default :   { runerr(500,p); }
    }
    return p;
end

procedure optim_goto_elimination(t, start)
    local new, wl, seen, lab, insn, chunk

    optim_refcount := table(0)

    new := table()
    wl := []
    seen := set()
    optim_add_label(start, wl, seen)

    while lab := pop(wl) do {
        new[lab] := \t[lab]
        every insn := !\t[lab] do {
            optim_gotos(insn, wl, seen,t)
        }
    }

    every lab := key(new) do {
        while chunk := \new[lab] &
              insn := chunk[-1] &
              type(insn) == "ir_Goto" &
              type(insn.location) == "ir_Label" &
              optim_refcount[insn.location] = 1 do {
            if /new[insn.location] then {
                runerr(500, insn.location)
            }
            new[lab] := chunk[1:-1] ||| new[insn.location]
            delete(new, insn.location)
        }
    }
    return new
end

procedure optim_add_label(lab, wl, seen)
    optim_refcount[lab] +:= 1
    if not member(seen, lab) then {
        insert(seen, lab)
        push(wl, lab)
    }
end

procedure optim_goto_chain(lab, t)
    local chunk, seen

    seen := set([])
    while chunk := \t[lab] &
          type(chunk[1]) == "ir_Goto" &
          not member(seen, lab) do {
        lab := chunk[1].location
        insert(seen, lab)
    }
    return lab
end

procedure optim_goto_chain_defer(lab, t)
    local chunk

    while chunk := \t[lab] &
          type(chunk[1]) == "ir_Goto" &
          type(chunk[1].location) ~== "ir_TmpLabel" do {
        lab := chunk[1].location
    }
    return lab
end

procedure optim_gotos(p, wl, seen, t)
    case type(p) of {
    "ir_Free" |
    "ir_Restore" |
    "ir_CoFail" |
    "ir_RunTimeError" |
    "ir_MakeList" |
    "ir_Operator" |
    "ir_Fail" |
    "ir_Var" |
    "ir_Key" |
    "ir_IntLit" |
    "ir_RealLit" |
    "ir_StrLit" |
    "ir_CsetLit" |
    "ir_ScanSwap" |
    "ir_Tmp" |
    "ir_TmpLabel" |
    "ir_Deref" |
    "ir_Coord" : {
        # nothing
        }
    "ir_Label" : {  # ir_Label : ( value )
        optim_add_label(p, wl, seen)
        }
    "ir_Move" : {  # ir_Move : ( lhs rhs )
        p.rhs := optim_goto_chain_defer(p.rhs, t)
        optim_gotos(p.rhs, wl, seen, t)
        }
    "ir_Goto" : {  # ir_Goto : ( location )
        p.location := optim_goto_chain(p.location, t)
        optim_gotos(p.location, wl, seen, t)
        }
    "ir_Succeed" : {  # ir_Succeed : ( expr continuation )
        p.continuation := optim_goto_chain(\p.continuation, t)
        optim_gotos(\p.continuation, wl, seen, t)
        }
    "ir_Field" : {  # ir_Field : ( lhs expr field failLabel )
        p.failLabel := optim_goto_chain(\p.failLabel, t)
        optim_gotos(\p.failLabel, wl, seen, t)
        }
    "ir_Call" |
    "ir_OpFunction" : {  # ir_OpFunction : ( lhs fn argList failLabel )
        p.failLabel := optim_goto_chain(\p.failLabel, t)
        optim_gotos(\p.failLabel, wl, seen, t)
        }
    "ir_ResumeValue" : {  # ir_ResumeValue : ( value failLabel retValue )
        p.failLabel := optim_goto_chain(p.failLabel, t)
        optim_gotos(p.failLabel, wl, seen, t)
        }
    "ir_Create" : {  # ir_Create : ( location )
        p.location := optim_goto_chain(p.location, t)
        optim_gotos(p.location, wl, seen, t)
        }
    "ir_CoRet" : {  # ir_CoRet : ( value continuation )
        p.continuation := optim_goto_chain(p.continuation, t)
        optim_gotos(p.continuation, wl, seen, t)
        }
    "ir_EnterInit" : {  # ir_EnterInit : ( startlabel )
        p.startlabel := optim_goto_chain(p.startlabel, t)
        optim_gotos(p.startlabel, wl, seen, t)
        }
    default : runerr(500, p)
    }
end
