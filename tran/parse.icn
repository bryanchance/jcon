global tok          # This is the coparse_expression that represents the scanner
global tok_rec      # This is the current token record

procedure parse(lex)
    local d

    tok := lex
    tok_rec := @tok
    suspend parse_program()
end

#  CASE  parse_expr  OF  LBRACE  parse_cclause {  SEMICOL  parse_cclause }  RBRACE 
procedure parse_do_case()
    local e, body, element, dflt, coord, bodyList

    coord := tok_rec.coord
    bodyList := []
    parse_eat_token()
    e := parse_expr()
    parse_match_token(OF)
    parse_match_token(LBRACE)
    body := []
    element := parse_cclause()
    if element.expr === DEFAULT then {
        dflt := element.body
    } else {
        put(body, element)  
    }
    while tok_rec === SEMICOL do {
        parse_match_token(SEMICOL)
        element := parse_cclause()
        if element.expr === DEFAULT then {
            (/dflt := element.body) |
                                   parse_error("more than one default clause")
        } else {
            put(body, element)  
        }
    }
    parse_match_token(RBRACE)
    return a_Case(e, body, dflt, coord)
end

procedure parse_cclause()
# case-clause
    local e, body, coord
    static parse_cclause_set
    initial {
    parse_cclause_set := set([CONJUNC, AT, BACKSLASH, BANG, BAR, BREAK, CARET, CASE,
                        CONCAT, CREATE, CSETLIT, DIFF, DOT, EQUIV, EVERY, FAIL,
                        IDENT, IF, INTER, INTLIT, LBRACE, LBRACK, LCONCAT,
                        LPAREN, MINUS, NOTEQUIV, NEXT, NUMEQ, NUMNE, NOT, PLUS,
                        QMARK, REALLIT, REPEAT, RETURN, LEXEQ, SLASH, LEXNE,
                        STAR, STRINGLIT, SUSPEND, TILDE, UNION, UNTIL, WHILE])
    }
    coord := tok_rec.coord
    if tok_rec === DEFAULT then {
        e := DEFAULT
        parse_eat_token()
        parse_match_token(COLON)
        body := parse_expr()
    } else if member(parse_cclause_set, tok_rec) then {
        e := parse_expr()
        parse_match_token(COLON)
        body := parse_expr()
    } else {
        parse_error("\""||tok_rec.str||"\": invalid case clause")
    }
    return a_Cclause(e, body, coord)
end

procedure parse_compound()
#  parse_nexpr {  SEMICOL  parse_nexpr } 
    local l, e
        
    l := [parse_nexpr()]
    while tok_rec === SEMICOL do {
        parse_eat_token()
        e := parse_nexpr()
        put(l, e)
    }
    return l
end

procedure parse_decl()
    case tok_rec of {
    RECORD    : return parse_do_record()
    PROCEDURE : return parse_do_proc()
    GLOBAL    : return parse_do_global()
    LINK      : return parse_do_link()
    INVOCABLE : return parse_do_invocable()
    default   : parse_error("Expecting parse_declaration")
    }
end

procedure parse_do_every()
#  EVERY  parse_expr [  DO  parse_expr ] 
    local e, body, coord
    coord := tok_rec.coord
    parse_eat_token()
    e := parse_expr()
    if tok_rec === DO then {
        parse_match_token(DO)
        body := parse_expr()
    } else {
        body := &null
    }
    return a_Every(e, body, coord)
end

procedure parse_expr()
#  parse_expr1a {  AND  parse_expr1 } 
    local ret, op, right

    ret := parse_expr1a()
    while tok_rec === CONJUNC do {
        op := parse_eat_token()
        right := parse_expr1a()
        ret := a_Binop(op, ret, right, ret.coord)
    }
    return ret
end

procedure parse_expr1()
    local ret, op, right
    static parse_expr1_set

    initial {
    parse_expr1_set := set([ASSIGN, AUGAND, AUGAT, CARETASGN, CONCATASGN, DIFFASGN,
                      AUGEQV, INTERASGN, LCONCATASGN, MINUSASGN, MODASGN,
                      AUGNEQV, AUGEQ, AUGGE, AUGGT, AUGLE, AUGLT, AUGNE,
                      PLUSASGN, SCANASGN, AUGSEQ, AUGSGE, AUGSGT, SLASHASGN,
                      AUGSLE, AUGSLT, AUGSNE, STARASGN, UNIONASGN, REVASSIGN,
                      REVSWAP, SWAP])
    }
        #  parse_expr2 {  parse_expr1op  parse_expr1 } (Right Associative)
    ret := parse_expr2()
    while member(parse_expr1_set, tok_rec) do {
        op := parse_eat_token()
        right := parse_expr1()
        if op == "?:=" then {
            ret := a_Scan(op, ret, right, ret.coord)
        } else {
            ret := a_Binop(op, ret, right, ret.coord)
        }
    }
    return ret
end

procedure parse_expr10()
    local op, operand, tmp_tok, coord
    static parse_expr10_set1, parse_expr10_set2, parse_expr10_set3

    initial {
    parse_expr10_set1 := set([CONJUNC, BREAK, CASE, CREATE, CSETLIT, EVERY, FAIL,
                        IDENT, IF, INTLIT, LBRACE, LBRACK, LPAREN, NEXT,
                        REALLIT, REPEAT, RETURN, STRINGLIT, SUSPEND, UNTIL,
                        WHILE])
    parse_expr10_set2 := set([AT, NOT, BAR, DOT, BANG, PLUS, STAR, SLASH, CARET,
                        TILDE, MINUS, NUMEQ, NUMNE, LEXEQ, LEXNE, EQUIV, QMARK,
                        NOTEQUIV, BACKSLASH])
    parse_expr10_set3 := set([CONCAT, LCONCAT, UNION, INTER, DIFF])
    }

    if member(parse_expr10_set1, tok_rec) then {
        return parse_expr11a()
    } else if member(parse_expr10_set2, tok_rec) then {
        coord := tok_rec.coord
        op := parse_eat_token()
        operand := parse_expr10()
        case (op) of {
        "|":        return a_RepAlt(operand, coord)
        "not":      return a_Not(operand, coord)
        default:    return a_Unop(op, operand, coord)
        }
    } else if member(parse_expr10_set3, tok_rec) then {
        tmp_tok := tok_rec
        coord := tok_rec.coord
        op := parse_eat_token()
        operand := parse_expr10()
        case tmp_tok of {
        CONCAT  : return a_RepAlt(operand, coord)
        LCONCAT : return a_RepAlt(operand, coord)
        UNION     : return a_Unop("+", operand, coord)
        INTER     : return a_Unop("*",a_Unop("*", operand, coord), coord)
        DIFF      : return a_Unop("-",a_Unop("-", operand, coord), coord)
        default     : runerr(500)
        }
    } else {
        parse_error("\""||tok_rec.str||"\": invalid argument")
    }
end

procedure parse_expr11()
    local e, id, coord
    case tok_rec of {
    CSETLIT |
    INTLIT  |
    REALLIT |
    STRINGLIT   :   # parse_literal 
        return parse_literal()
    FAIL    |
    RETURN  |
    SUSPEND :   # return 
        return parse_do_return()
    IF  :   # if 
        return parse_do_if()
    CASE    :   # case 
        return parse_do_case()
    WHILE   :   # while 
        return parse_do_while()
    UNTIL   :   # until 
        return parse_do_until()
    EVERY   :   # every 
        return parse_do_every()
    REPEAT  :   # repeat 
        return parse_do_repeat()
    CREATE  :   # CREATE  parse_expr 
        {
        coord := tok_rec.coord
        parse_eat_token()
        e := parse_expr()
        return a_Create(e, coord)
        }
    IDENT   :   # IDENT 
        {
        coord := tok_rec.coord
        id := parse_eat_token()
        return a_Ident(id, coord)
        }
    NEXT    :   # NEXT 
        {
        coord := tok_rec.coord
        parse_eat_token()
        return a_Next(coord)
        }
    BREAK   :   # BREAK  parse_nexpr 
        {
        coord := tok_rec.coord
        parse_eat_token()
        e := parse_nexpr()
        return a_Break(e, coord)
        }
    LPAREN  :   # LPAREN  parse_exprlist  RPAREN 
        {
        coord := tok_rec.coord
        parse_eat_token()
        e := parse_exprlist()
        parse_match_token(RPAREN)
        return a_Mutual(e, coord)
        }
    LBRACE  :   # LBRACE  parse_compound  RBRACE 
        {
        coord := tok_rec.coord
        parse_eat_token()
        e := parse_compound()
        parse_match_token(RBRACE)
        return a_Compound(e, coord)
        }
    LBRACK  :   # LBRACK  parse_exprlist  RBRACK 
        {
        coord := tok_rec.coord
        parse_eat_token()
        e := parse_exprlist()
        parse_match_token(RBRACK)
        return a_ListConstructor(e, coord)
        }
    CONJUNC :   # AND ( FAIL  |  IDENT )
        {
        coord := tok_rec.coord
        parse_eat_token()
        case tok_rec of {
        FAIL : {
            return a_Key(parse_eat_token(), coord)
        }
        IDENT : {
            return a_Key(parse_eat_token(), coord)
        }
        default : {
            parse_error("\""||tok_rec.str||"\": invalid keyword construction")
        }
        }
        }
    default : {
        parse_error("Expecting parse_expression")
    }
    }
end

procedure parse_expr11a()
    local left, right, op, oprec
    static parse_expr11_set

    initial {
    parse_expr11_set := set([DOT, LBRACE, LBRACK, LPAREN])
    }
    #  parse_expr11 {  parse_expr11suffix } 
    left := parse_expr11()
    while member(parse_expr11_set, tok_rec) do {
        left := parse_expr11suffix(left)
    }
    return left
end

procedure parse_expr11suffix(lhs)
    local left, right, l, op, id, coord, x
    static parse_expr11suffix_set1, parse_expr11suffix_set2

    initial {
        parse_expr11suffix_set1 := set([CONJUNC, AT, BACKSLASH, BANG, BAR, BREAK,
                                  CARET, CASE, COMMA, CONCAT, CREATE, CSETLIT,
                                  DIFF, DOT, EQUIV, EVERY, FAIL, IDENT, IF,
                                  INTER, INTLIT, LBRACE, LBRACK, LCONCAT,
                                  LPAREN, MINUS, NOTEQUIV, NEXT, NUMEQ, NUMNE,
                                  NOT, PLUS, QMARK, REALLIT, REPEAT, RETURN,
                                  LEXEQ, SLASH, LEXNE, STAR, STRINGLIT, SUSPEND,
                                  TILDE, UNION, UNTIL, WHILE])
        parse_expr11suffix_set2 := set([COLON, MCOLON, PCOLON])
    }

    case tok_rec of {
    LBRACE  :   # LBRACE [  parse_pdcolist ]  RBRACE 
        {
        parse_eat_token()
        if member(parse_expr11suffix_set1, tok_rec) then {
            l := parse_pdcolist()
        }
        parse_match_token(RBRACE)
        return a_Call(lhs, a_CoexpList(l),lhs.coord)
        }
    LPAREN  :   # LPAREN  parse_exprlist  RPAREN 
        {
        parse_eat_token()
        l := parse_exprlist()
        parse_match_token(RPAREN)
        return a_Call(lhs, a_Arglist(l), lhs.coord)
        }
    DOT :   # DOT  IDENT 
        {
        coord := tok_rec.coord
        x := parse_eat_token()
        id := parse_match_token(IDENT)
        return a_Field(lhs, a_Ident(id, coord), lhs.coord)
        }
    LBRACK  :   # LBRACK  parse_expr [  sectop  parse_expr ]  RBRACK 
        {
        parse_eat_token()
        repeat {
            left := parse_nexpr()
            if member(parse_expr11suffix_set2, tok_rec) then {
                op := "[" || parse_eat_token() || "]"
                right := parse_expr()
                lhs := a_Sectionop(op, lhs, left, right, lhs.coord)
            } else {
                lhs := a_Binop("[]", lhs, left, lhs.coord)
            }
            if tok_rec ~=== COMMA then break
            parse_match_token(COMMA)
        }
        parse_match_token(RBRACK)
        return lhs
        }
    default : {
        parse_error("Malformed argument list")
    }
    }
end

procedure parse_expr1a()
#  parse_expr1 {  QMARK  parse_expr1a } 
    local left, right

    left := parse_expr1()
    while tok_rec === QMARK do {
        parse_eat_token()
        right := parse_expr1()
        left := a_Scan("?", left, right, left.coord)
    }
    return left
end

procedure parse_expr2()
#  parse_expr3 {  TO  parse_expr2 [  BY  parse_expr3 ] } 
    local e1, e2, e3, ret

    e1 := parse_expr3()
    e2 := &null
    e3 := &null
    ret := e1
    while tok_rec === TO do {
        parse_eat_token()
        e2 := parse_expr3()
        if tok_rec === BY then {
            parse_match_token(BY)
            e3 := parse_expr3()
        }
        ret := a_ToBy(e1, e2, e3, e1.coord)
        e1 := ret
    }
    return ret
end

procedure parse_expr3()
#  parse_expr4 {  BAR  parse_expr3 } 
    local ret, a

    ret := parse_expr4()
    while tok_rec === BAR do {
        /a := a_Alt([ret], tok_rec.coord)
        parse_eat_token()
        put(a.eList, parse_expr4())
    }
    ret := \a
    return ret
end

procedure parse_expr4()
    local ret, op, right
    static parse_expr4_set

    initial {
        parse_expr4_set := set([EQUIV, NOTEQUIV, NUMEQ, NUMGE, NUMGT, NUMLE, NUMLT,
                          NUMNE, LEXEQ, LEXGE, LEXGT, LEXLE, LEXLT, LEXNE])
    }
    #  parse_expr5 {  parse_expr4op  parse_expr4 } 
    ret := parse_expr5()

    while member(parse_expr4_set, tok_rec) do {
        op := parse_eat_token()
        right := parse_expr5()
        ret := a_Binop(op, ret, right, ret.coord)
    }
    return ret
end

procedure parse_expr5()
#  parse_expr6 {  parse_expr5op  parse_expr5 } 
    local ret, right, op

    ret := parse_expr6()
    while tok_rec === CONCAT | tok_rec === LCONCAT do {
        op := parse_eat_token()
        right := parse_expr6()
        ret := a_Binop(op, ret, right, ret.coord)
    }
    return ret
end


procedure parse_expr6()
#  parse_expr7 {  parse_expr6op  parse_expr6 } 
    local ret, op, right
    static parse_expr6_set

    initial {
        parse_expr6_set := set([DIFF, MINUS, PLUS, UNION])
    }

    ret := parse_expr7()
    while member(parse_expr6_set, tok_rec) do {
        op := parse_eat_token()
        right := parse_expr7()
        ret := a_Binop(op, ret, right, ret.coord)
    }
    return ret
end

procedure parse_expr7()
#  parse_expr8 {  parse_expr7op  parse_expr7 } 
    local ret, op, right
    static parse_expr7_set

    initial {
        parse_expr7_set := set([INTER, MOD, SLASH, STAR])
    }

    ret := parse_expr8()

    while member(parse_expr7_set, tok_rec) do {
        op := parse_eat_token()
        right := parse_expr8()
        ret := a_Binop(op, ret, right, ret.coord)
    }
    return ret
end

procedure parse_expr8()
#  parse_expr9 {  CARET  parse_expr8 }  (Right Associative)
    local ret, op, right

    ret := parse_expr9()
    while tok_rec === CARET do {
        op := parse_eat_token()
        right := parse_expr8()
        ret := a_Binop(op, ret, right, ret.coord)
    }
    return ret
end

procedure parse_expr9()
#  parse_expr10 {  parse_expr9op  parse_expr9 } 
    local ret, op, right

    ret := parse_expr10()
    while tok_rec === AT | tok_rec === BACKSLASH | tok_rec === BANG do {
        op := parse_eat_token()
        right := parse_expr10()
        if op == "\\" then {
            ret := a_Limitation(ret, right, ret.coord)
        } else {
            ret := a_Binop(op, ret, right, ret.coord)
        }
    }
    return ret
end

procedure parse_exprlist()
    local l, e
    #  parse_nexpr {  COMMA  parse_nexpr } 
    e := parse_nexpr()
    if \e | (tok_rec === COMMA) then {
        l := [ e ]
    } else {
        l := []
    }
    while tok_rec === COMMA do {
        parse_eat_token()
        e := parse_nexpr()
        put(l, e)
    }
    return l
end

#  GLOBAL  parse_idlist, coord
procedure parse_do_global()
    local coord

    coord := tok_rec.coord
    parse_match_token(GLOBAL)
    return a_Global(parse_idlist(), coord)
end

procedure parse_idlist()
#  IDENT {  COMMA  IDENT } 
    local l, id, coord

    coord := tok_rec.coord

    l := [a_Ident(parse_match_token(IDENT), coord)]
    while tok_rec === COMMA do {
        parse_eat_token()
        coord := tok_rec.coord
        id := a_Ident(parse_match_token(IDENT), coord)
        put(l, id)
    }
    return l
end

procedure parse_do_if()
#  IF  parse_expr  THEN  parse_expr [  ELSE  parse_expr ] 
    local ex, theparse_nexpr, elseparse_expr, coord

    coord := tok_rec.coord
    parse_match_token(IF)
    ex := parse_expr()
    parse_match_token(THEN)
    theparse_nexpr := parse_expr()
    elseparse_expr := &null
    if tok_rec === ELSE then {
        parse_eat_token()
        elseparse_expr := parse_expr()
    }
    return a_If(ex, theparse_nexpr, elseparse_expr, coord)
end

procedure parse_do_initial()
# [  INITIAL  parse_expr  SEMICOL ] 
    local e, coord

    if tok_rec === INITIAL then {
        coord := tok_rec.coord
        parse_eat_token()
        e := parse_expr()
        parse_match_token(SEMICOL)
    }
    return a_Initial(e, tok_rec.coord)
end

procedure parse_do_invocable()
#  INVOCABLE  parse_invocop {  COMMA  parse_invocop } 
    local l, op, coord

    coord := tok_rec.coord
    parse_match_token(INVOCABLE)
    l := [parse_invocop()]
    while tok_rec === COMMA do {
        parse_eat_token()
        op := parse_invocop()
        put(l, op)
    }
    return a_Invocable(l, coord)
end

procedure parse_invocop()
    local ret, t, coord
    coord := tok_rec.coord
    case tok_rec of {
    IDENT   :   # IDENT 
        return a_Ident(parse_eat_token(), coord)
    STRINGLIT   :   # STRINGLIT [  COLON  INTLIT ] 
        return a_Stringlit(parse_eat_token(), coord)
    default : 
        parse_error("\""||tok_rec.str||"\": invocable list expected")
    }
end

procedure parse_do_link()
#  LINK  parse_lnkfile {  COMMA  parse_lnkfile } 
    local l, lnkf, coord

    coord := tok_rec.coord
    parse_match_token(LINK)
    l := [parse_lnkfile()]
    while tok_rec === COMMA do {
        parse_eat_token()
        lnkf := parse_lnkfile()
        put(l, lnkf)
    }
    return a_Link(l, coord)
end

procedure parse_literal()
    local coord
    coord := tok_rec.coord
    case tok_rec of {
    INTLIT  :   # INTLIT 
        return a_Intlit(integer(parse_eat_token()), coord)
    REALLIT :   # REALLIT 
        return a_Reallit(real(parse_eat_token()), coord)
    STRINGLIT   :   # STRINGLIT 
        return a_Stringlit(parse_eat_token(), coord)
    CSETLIT :   # CSETLIT 
        return a_Csetlit(cset(parse_eat_token()), coord)
    default :
        parse_error("Expecting parse_literal")
    }
end

procedure parse_lnkfile()
    case tok_rec of {
    IDENT   :   # IDENT 
        return parse_eat_token()
    STRINGLIT   :   # STRINGLIT 
        return parse_eat_token()
    default :
        parse_error("\""||tok_rec.str||"\": link list expected")
    }
end

procedure parse_locals()
# {  retention  parse_idlist  SEMICOL } 
    local ret, l, vars, coord

    l := []
    while tok_rec === LOCAL | tok_rec === STATIC do {
    if tok_rec === LOCAL then {
        coord := tok_rec.coord
        parse_eat_token()
        vars := parse_idlist()
        parse_match_token(SEMICOL)
        ret := a_Locals(vars, coord)
        put(l, ret)
    } else {
        coord := tok_rec.coord
        parse_eat_token()
        vars := parse_idlist()
        parse_match_token(SEMICOL)
        ret := a_Statics(vars, coord)
        put(l, ret)
    }
    }
    return l
end

procedure parse_nexpr()
# [  parse_expr ] 
    static parse_nexpr_set

    initial {
    parse_nexpr_set := set([CONJUNC, AT, BACKSLASH, BANG, BAR, BREAK, CARET, CASE,
                      CONCAT, CREATE, CSETLIT, DIFF, DOT, EQUIV, EVERY, FAIL,
                      IDENT, IF, INTER, INTLIT, LBRACE, LBRACK, LCONCAT,
                      LPAREN, MINUS, NOTEQUIV, NEXT, NUMEQ, NUMNE, NOT, PLUS,
                      QMARK, REALLIT, REPEAT, RETURN, LEXEQ, SLASH, LEXNE,
                      STAR, STRINGLIT, SUSPEND, TILDE, UNION, UNTIL, WHILE])
    }
    if member(parse_nexpr_set, tok_rec) then {
        return parse_expr()
    }
    return &null
end

procedure parse_pdcolist()
#  parse_nexpr {  COMMA  parse_nexpr } 
    local l, e

    l := [parse_nexpr()]
    while tok_rec === COMMA do {
        parse_eat_token()
        e := parse_nexpr()
        put(l, e)
    }
    return l
end

procedure parse_do_proc()
    local ident, paramList, accumulate, loc, init, parse_nexprList, e, coord, idcoord
    static parse_do_proc_set

    initial {
    parse_do_proc_set := set([CONJUNC, AT, BACKSLASH, BANG, BAR, BREAK, CARET, CASE,
                        CONCAT, CREATE, CSETLIT, DIFF, DOT, EQUIV, EVERY, FAIL,
                        IDENT, IF, INTER, INTLIT, LBRACE, LBRACK, LCONCAT,
                        LPAREN, MINUS, NOTEQUIV, NEXT, NUMEQ, NUMNE, NOT, PLUS,
                        QMARK, REALLIT, REPEAT, RETURN, SEMICOL, LEXEQ, SLASH,
                        LEXNE, STAR, STRINGLIT, SUSPEND, TILDE, UNION, UNTIL,
                        WHILE])
    }
    #  prochead  SEMICOL  locals  initial  procbody  END 
    coord := tok_rec.coord
    parse_match_token(PROCEDURE)
    idcoord := tok_rec.coord
    ident := a_Ident(parse_match_token(IDENT), idcoord)
    parse_match_token(LPAREN)
    paramList := []
    if tok_rec === IDENT then {
        paramList := parse_idlist()
        if tok_rec === LBRACK then {
            parse_eat_token()
            parse_match_token(RBRACK)
            accumulate := 1
        }
    }
    parse_match_token(RPAREN)
    parse_match_token(SEMICOL)
    loc := parse_locals()
    init := parse_do_initial()
    parse_nexprList := []
    while member(parse_do_proc_set, tok_rec) do {
        e := parse_nexpr()
        put(parse_nexprList, e)
        parse_match_token(SEMICOL)
    }
    parse_match_token(END)
    return a_ProcDecl(ident, paramList, accumulate, loc,
                    a_ProcCode(init, a_ProcBody(parse_nexprList)), coord)
end

procedure parse_program()  # {  parse_decl } 
    static parse_program_set
    local d

    initial {
        parse_program_set := set([GLOBAL, INVOCABLE, LINK, PROCEDURE, RECORD])
    }

    while member(parse_program_set, tok_rec) do {
        d := parse_decl()
        suspend d
    }
    if tok_rec ~=== EOFX then {
        parse_error("\""||tok_rec.str||"\": invalid parse_declaration")
    }
end

procedure parse_do_record()
#  RECORD  IDENT  LPAREN [  parse_idlist ]  RPAREN 
    local id, l, coord, idcoord
    coord := tok_rec.coord
    parse_match_token(RECORD)
    idcoord := tok_rec.coord
    id := a_Ident(parse_match_token(IDENT), idcoord)
    parse_match_token(LPAREN)
    l := []
    if tok_rec === IDENT then {
        l := parse_idlist()
    }
    parse_match_token(RPAREN)
    return a_Record(id, l, coord)
end

procedure parse_do_repeat()
    local e, coord
    #  REPEAT  parse_expr 
    coord := tok_rec.coord
    parse_match_token(REPEAT)
    e := parse_expr()
    return a_Repeat(e, coord)
end

procedure parse_do_return()
    local e, coord, doparse_expr

    coord := tok_rec.coord
    case tok_rec of {
    FAIL    :   # FAIL 
        {
        parse_eat_token()
        return a_Fail(coord)
        }
    RETURN  :   # RETURN  parse_nexpr 
        {
        parse_eat_token()
        e := parse_nexpr()
        return a_Return(e, coord)
        }
    SUSPEND :   # SUSPEND  parse_expr [  DO  parse_expr ] 
        {
        parse_eat_token()
        e := parse_nexpr()
        doparse_expr := &null
        if tok_rec === DO then {
            parse_eat_token()
            doparse_expr := parse_expr()
        }
        return a_Suspend(e, doparse_expr, coord)
        }
    default :
        parse_error("Expecting FAIL, RETURN, or SUSPEND")
    }
end

#  UNTIL  parse_expr [  DO  parse_expr ] 
procedure parse_do_until()
    local e, dparse_expr, coord

    coord := tok_rec.coord
    parse_match_token(UNTIL)
    e := parse_expr()
    dparse_expr := &null
    if tok_rec === DO then {
        parse_eat_token()
        dparse_expr := parse_expr()
    }
    return a_Until(e, dparse_expr, coord)
end

#  WHILE  parse_expr [  DO  parse_expr ] 
procedure parse_do_while()
    local e, dparse_expr, coord

    coord := tok_rec.coord
    parse_match_token(WHILE)
    e := parse_expr()
        dparse_expr := &null
    if tok_rec === DO then {
        parse_eat_token()
        dparse_expr := parse_expr()
    }
    return a_While(e, dparse_expr, coord)
end

procedure parse_match_token(which_token)
    local saved
    saved := tok_rec.str
    if tok_rec === which_token then {
        tok_rec := @tok
        return saved
    } else {
        parse_error("Expecting "||which_token.str)
    }
end

procedure parse_eat_token()
    local saved
    saved := tok_rec.str
    tok_rec := @tok
    return saved
end


procedure parse_error(msg)
    stop("File ", tok_rec.coord.file, "; Line ", tok_rec.coord.line, " # ", msg)
end
